// @ts-nocheck -- skip type checking
import { _runtimeAsync, buildConfig } from "fumadocs-mdx/runtime/async"
const [err, _sourceConfig] = buildConfig(_source)
if (!_sourceConfig) throw new Error(err)
import { _runtime } from "fumadocs-mdx"
import * as _source from "../source.config"
export const docs = _runtimeAsync.docs<typeof _source.docs>([{"info":{"path":"index.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/index.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Hello World","description":"Your first document","index":false},"content":"\nWelcome to the docs! You can start writing documents in `/content/docs`.\n\n## What is Next?\n\n<Cards>\n  <Card title=\"Learn more about Next.js\" href=\"https://nextjs.org/docs\" />\n  <Card title=\"Learn more about Fumadocs\" href=\"https://fumadocs.vercel.app\" />\n</Cards>\n"}, {"info":{"path":"framework/concepts.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/concepts.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Core Concepts","description":"Deep dive into routers, procedures, context, middleware, and error handling","icon":"IconBrain","index":false},"content":"\nUnderstanding tRPC's core concepts is essential for building robust, type-safe APIs. This guide covers the fundamental building blocks that make tRPC powerful and easy to use.\n\n## Router\n\nA **router** defines your API structure and groups related procedures together. Think of it as your API's blueprint that organizes endpoints logically.\n\n### Basic Router\n\n```typescript title=\"server/router.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Simple greeting procedure\n  hello: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query(({ input }) => {\n      return { message: `Hello, ${input.name}!` };\n    }),\n\n  // Get current time\n  time: t.procedure\n    .query(() => {\n      return { timestamp: new Date().toISOString() };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### Nested Routers\n\nOrganize complex APIs with nested routers for better maintainability:\n\n```typescript title=\"server/routers/_app.ts\"\nimport { t } from '../trpc';\nimport { userRouter } from './users';\nimport { postRouter } from './posts';\nimport { authRouter } from './auth';\n\nexport const appRouter = t.router({\n  // Nested routers for organization\n  users: userRouter,\n  posts: postRouter,\n  auth: authRouter,\n\n  // Root-level procedures\n  health: t.procedure.query(() => ({ status: 'ok' })),\n});\n```\n\n```typescript title=\"server/routers/users.ts\"\nimport { t } from '../trpc';\nimport { z } from 'zod';\n\nexport const userRouter = t.router({\n  getById: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      return await db.user.findUnique({ where: { id: input } });\n    }),\n\n  list: t.procedure\n    .input(z.object({\n      limit: z.number().min(1).max(100).default(10),\n      cursor: z.string().optional(),\n    }))\n    .query(async ({ input }) => {\n      const users = await db.user.findMany({\n        take: input.limit + 1,\n        cursor: input.cursor ? { id: input.cursor } : undefined,\n        orderBy: { createdAt: 'desc' },\n      });\n\n      return {\n        users: users.slice(0, input.limit),\n        nextCursor: users.length > input.limit ? users[input.limit].id : undefined,\n      };\n    }),\n\n  create: t.procedure\n    .input(z.object({\n      email: z.string().email(),\n      name: z.string().min(1),\n    }))\n    .mutation(async ({ input }) => {\n      return await db.user.create({ data: input });\n    }),\n});\n```\n\n## Procedures\n\n**Procedures** are the individual endpoints of your API. There are three types, each serving different purposes:\n\n### Query Procedures\n\nUse `query` for reading data (GET-like operations):\n\n```typescript\nconst getUser = t.procedure\n  .input(z.string())\n  .query(async ({ input }) => {\n    const user = await db.user.findUnique({ where: { id: input } });\n    if (!user) throw new TRPCError({ code: 'NOT_FOUND' });\n    return user;\n  });\n```\n\n**Client usage:**\n\n```typescript\n// Automatically typed as User | undefined\nconst userQuery = useQuery(trpc.getUser.queryOptions('user_123'));\n```\n\n### Mutation Procedures\n\nUse `mutation` for creating, updating, or deleting data:\n\n```typescript\nconst createPost = t.procedure\n  .input(z.object({\n    title: z.string().min(1),\n    content: z.string(),\n    authorId: z.string(),\n  }))\n  .mutation(async ({ input }) => {\n    return await db.post.create({\n      data: input,\n      include: { author: true },\n    });\n  });\n```\n\n**Client usage:**\n\n```typescript\nconst createPostMutation = useMutation(trpc.createPost.mutationOptions({\n  onSuccess: (newPost) => {\n    // Invalidate relevant queries\n    queryClient.invalidateQueries(trpc.posts.list.queryKey());\n  },\n}));\n```\n\n### Subscription Procedures\n\nUse `subscription` for real-time data streams:\n\n```typescript\nconst onPostUpdate = t.procedure\n  .input(z.object({ postId: z.string() }))\n  .subscription(async function* ({ input }) {\n    // Set up your real-time source (WebSocket, Server-Sent Events, etc.)\n    const unsubscribe = subscribeToPostUpdates(input.postId, (update) => {\n      // Yield updates to the client\n      yield update;\n    });\n\n    // Cleanup when subscription ends\n    return () => unsubscribe();\n  });\n```\n\n## Input & Output Validation\n\ntRPC uses schema validation to ensure type safety and runtime validation:\n\n### Input Validation with Zod\n\n```typescript\nconst createUser = t.procedure\n  .input(z.object({\n    email: z.string().email('Invalid email format'),\n    name: z.string().min(2, 'Name must be at least 2 characters'),\n    age: z.number().int().min(13, 'Must be at least 13 years old'),\n    role: z.enum(['user', 'admin']).default('user'),\n  }))\n  .mutation(async ({ input }) => {\n    // input is fully typed and validated\n    return await db.user.create({ data: input });\n  });\n```\n\n### Output Validation\n\nWhile output validation is optional, it can catch bugs and ensure consistency:\n\n```typescript\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  name: z.string(),\n  createdAt: z.date(),\n});\n\nconst getUser = t.procedure\n  .input(z.string())\n  .output(UserSchema)\n  .query(async ({ input }) => {\n    const user = await db.user.findUnique({ where: { id: input } });\n    if (!user) throw new TRPCError({ code: 'NOT_FOUND' });\n\n    // Output will be validated against UserSchema\n    return user;\n  });\n```\n\n## Context\n\n**Context** provides request-scoped data to all procedures, such as user sessions, database connections, and request metadata.\n\n### Creating Context\n\n```typescript title=\"server/context.ts\"\nimport { type CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '../auth';\nimport { prisma } from '../db';\n\nexport async function createTRPCContext(opts: CreateNextContextOptions) {\n  const { req, res } = opts;\n\n  // Get user session\n  const session = await getServerSession(req, res, authOptions);\n\n  return {\n    prisma,\n    session,\n    req,\n    res,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createTRPCContext>>;\n```\n\n### Using Context in Procedures\n\n```typescript title=\"server/trpc.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const publicProcedure = t.procedure;\n\n// Middleware to check authentication\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.session?.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.session.user, // Authenticated user\n    },\n  });\n});\n```\n\n```typescript\n// Using context in procedures\nconst getCurrentUser = protectedProcedure\n  .query(async ({ ctx }) => {\n    // ctx.user is available and typed\n    return await ctx.prisma.user.findUnique({\n      where: { id: ctx.user.id },\n    });\n  });\n```\n\n## Middleware\n\n**Middleware** runs before procedures and can:\n\n- Authenticate users\n- Log requests\n- Rate limit\n- Transform input/output\n- Add additional context\n\n### Authentication Middleware\n\n```typescript title=\"server/middleware/auth.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { t } from '../trpc';\n\nexport const requireAuth = t.middleware(({ ctx, next }) => {\n  if (!ctx.session?.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You must be logged in to access this resource',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.session.user,\n    },\n  });\n});\n\nexport const requireAdmin = t.middleware(({ ctx, next }) => {\n  if (!ctx.session?.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  if (ctx.session.user.role !== 'admin') {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Admin access required',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.session.user,\n    },\n  });\n});\n```\n\n### Logging Middleware\n\n```typescript title=\"server/middleware/logging.ts\"\nexport const withLogging = t.middleware(async ({ path, type, next }) => {\n  const start = Date.now();\n  console.log(`üìû ${type.toUpperCase()} ${path} - started`);\n\n  const result = await next();\n\n  const duration = Date.now() - start;\n\n  if (result.ok) {\n    console.log(`‚úÖ ${type.toUpperCase()} ${path} - completed in ${duration}ms`);\n  } else {\n    console.log(`‚ùå ${type.toUpperCase()} ${path} - failed in ${duration}ms`);\n  }\n\n  return result;\n});\n```\n\n### Composing Middleware\n\n```typescript\n// Create reusable procedure builders\nexport const publicProcedure = t.procedure.use(withLogging);\n\nexport const protectedProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth);\n\nexport const adminProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth)\n  .use(requireAdmin);\n```\n\n## Error Handling\n\ntRPC provides structured error handling with specific error codes and custom messages:\n\n### Built-in Error Codes\n\n```typescript\nimport { TRPCError } from '@trpc/server';\n\n// Throw specific errors\nthrow new TRPCError({\n  code: 'NOT_FOUND',\n  message: 'User not found',\n});\n\nthrow new TRPCError({\n  code: 'UNAUTHORIZED',\n  message: 'Please log in to continue',\n});\n\nthrow new TRPCError({\n  code: 'FORBIDDEN',\n  message: 'You do not have permission to perform this action',\n});\n\nthrow new TRPCError({\n  code: 'BAD_REQUEST',\n  message: 'Invalid input provided',\n  cause: validationError,\n});\n```\n\n### Global Error Handler\n\n```typescript title=\"server/trpc.ts\"\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\n```\n\n### Client-Side Error Handling\n\n```typescript\n// In React components\nconst createPostMutation = useMutation(trpc.posts.create.mutationOptions({\n  onError: (error) => {\n    switch (error.data?.code) {\n      case 'UNAUTHORIZED':\n        router.push('/login');\n        break;\n      case 'BAD_REQUEST':\n        // Handle validation errors\n        setFormErrors(error.data.zodError?.fieldErrors);\n        break;\n      default:\n        toast.error('Something went wrong');\n    }\n  },\n}));\n\n// With React Query's error boundaries\nconst postsQuery = useQuery(trpc.posts.list.queryOptions(), {\n  throwOnError: true, // Throws to nearest error boundary\n});\n```\n\n## Advanced Patterns\n\n### Conditional Procedures\n\nUse middleware to create conditional logic:\n\n```typescript\nconst getPostByIdOrThrow = t.procedure\n  .input(z.string())\n  .use(async ({ input, next }) => {\n    const post = await db.post.findUnique({ where: { id: input } });\n    if (!post) {\n      throw new TRPCError({ code: 'NOT_FOUND', message: 'Post not found' });\n    }\n\n    return next({\n      ctx: { post }, // Add post to context\n    });\n  })\n  .query(({ ctx }) => {\n    // ctx.post is guaranteed to exist\n    return ctx.post;\n  });\n```\n\n### Reusable Input Schemas\n\n```typescript title=\"server/schemas.ts\"\nimport { z } from 'zod';\n\nexport const PaginationSchema = z.object({\n  limit: z.number().min(1).max(100).default(10),\n  cursor: z.string().optional(),\n});\n\nexport const UserCreateSchema = z.object({\n  email: z.string().email(),\n  name: z.string().min(2),\n  role: z.enum(['user', 'admin']).default('user'),\n});\n\nexport const PostCreateSchema = z.object({\n  title: z.string().min(1).max(200),\n  content: z.string().min(1),\n  tags: z.array(z.string()).max(10).default([]),\n});\n```\n\n### Procedure Composition\n\n```typescript\n// Base procedures with common middleware\nconst baseMutation = t.procedure.use(withLogging).use(requireAuth);\n\n// Specialized procedures\nconst userMutation = baseMutation.input(UserCreateSchema);\nconst postMutation = baseMutation.input(PostCreateSchema);\n\n// Use in router\nexport const appRouter = t.router({\n  users: t.router({\n    create: userMutation.mutation(async ({ input, ctx }) => {\n      return await ctx.prisma.user.create({ data: input });\n    }),\n  }),\n  posts: t.router({\n    create: postMutation.mutation(async ({ input, ctx }) => {\n      return await ctx.prisma.post.create({\n        data: { ...input, authorId: ctx.user.id },\n      });\n    }),\n  }),\n});\n```\n\n## Best Practices\n\n<Callout title=\"Organizing Your Code\">\n  - **Group related procedures** in nested routers - **Reuse middleware** for\n  common functionality - **Create typed context** for request-scoped data -\n  **Use consistent naming** conventions - **Validate inputs** with Zod schemas\n</Callout>\n\n### Folder Structure\n\n```\nserver/\n‚îú‚îÄ‚îÄ routers/\n‚îÇ   ‚îú‚îÄ‚îÄ _app.ts          # Main router\n‚îÇ   ‚îú‚îÄ‚îÄ users.ts         # User procedures\n‚îÇ   ‚îú‚îÄ‚îÄ posts.ts         # Post procedures\n‚îÇ   ‚îî‚îÄ‚îÄ auth.ts          # Auth procedures\n‚îú‚îÄ‚îÄ middleware/\n‚îÇ   ‚îú‚îÄ‚îÄ auth.ts          # Authentication\n‚îÇ   ‚îú‚îÄ‚îÄ logging.ts       # Request logging\n‚îÇ   ‚îî‚îÄ‚îÄ rateLimit.ts     # Rate limiting\n‚îú‚îÄ‚îÄ schemas/\n‚îÇ   ‚îú‚îÄ‚îÄ user.ts          # User schemas\n‚îÇ   ‚îú‚îÄ‚îÄ post.ts          # Post schemas\n‚îÇ   ‚îî‚îÄ‚îÄ common.ts        # Shared schemas\n‚îú‚îÄ‚îÄ context.ts           # Context creation\n‚îî‚îÄ‚îÄ trpc.ts             # tRPC initialization\n```\n\n### Type Safety Tips\n\n1. **Always export router types** for client consumption\n2. **Use strict TypeScript** configuration\n3. **Leverage inference** - let TypeScript infer types when possible\n4. **Validate at boundaries** - server input/output and client data\n\n```typescript\n// Good: Let TypeScript infer\nconst result = await trpc.users.getById.query('user_123');\n// result is typed as User | null\n\n// Good: Use query options for additional React Query features\nconst userQuery = useQuery(trpc.users.getById.queryOptions('user_123'), {\n  staleTime: 5 * 60 * 1000, // 5 minutes\n});\n```\n\n---\n\nUnderstanding these core concepts will help you build robust, type-safe APIs with tRPC. The combination of routers, procedures, context, and middleware provides a powerful foundation for any application.\n"}, {"info":{"path":"framework/context-and-middleware.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/context-and-middleware.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Context & Middleware","description":"Master request context and middleware patterns for powerful tRPC APIs","icon":"IconSettings","index":false},"content":"\nContext and middleware are powerful features that enable you to share data across procedures and implement cross-cutting concerns like authentication, logging, and validation in your tRPC API.\n\n## Understanding Context\n\n**Context** is request-scoped data that's available to all procedures. It's created once per request and provides access to things like user sessions, database connections, request metadata, and more.\n\n<Cards>\n  <Card icon={<IconUser />} title=\"User Sessions\">\n    Access authenticated user data across all procedures\n  </Card>\n\n<Card icon={<IconDatabase />} title=\"Database Connections\">\n  Share database instances and transaction contexts\n</Card>\n\n<Card icon={<IconGlobe />} title=\"Request Metadata\">\n  Access headers, IP addresses, and request information\n</Card>\n\n  <Card icon={<IconKey />} title=\"External Services\">\n    Inject API clients, caches, and external service connections\n  </Card>\n</Cards>\n\n## Creating Context\n\n### Basic Context Setup\n\nDefine your context creation function:\n\n```typescript title=\"server/context.ts\"\nimport { type CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from './auth';\nimport { prisma } from './db';\n\nexport async function createTRPCContext(opts: CreateNextContextOptions) {\n  const { req, res } = opts;\n\n  // Get the session from the request\n  const session = await getServerSession(req, res, authOptions);\n\n  return {\n    prisma,\n    session,\n    req,\n    res,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createTRPCContext>>;\n```\n\n### Advanced Context with External Services\n\n```typescript title=\"server/context.ts\"\nimport { type CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { Redis } from 'ioredis';\nimport { S3Client } from '@aws-sdk/client-s3';\nimport { getServerSession } from 'next-auth';\n\n// Initialize external services\nconst redis = new Redis(process.env.REDIS_URL);\nconst s3 = new S3Client({ region: process.env.AWS_REGION });\n\nexport async function createTRPCContext(opts: CreateNextContextOptions) {\n  const { req, res } = opts;\n\n  // Extract request information\n  const userAgent = req.headers['user-agent'];\n  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n\n  // Get authentication\n  const session = await getServerSession(req, res, authOptions);\n\n  // Create logger with request context\n  const logger = createLogger({\n    requestId: crypto.randomUUID(),\n    userAgent,\n    ip,\n    userId: session?.user?.id,\n  });\n\n  return {\n    // Database\n    prisma,\n\n    // Caching\n    redis,\n\n    // File storage\n    s3,\n\n    // Authentication\n    session,\n    user: session?.user || null,\n\n    // Request data\n    req,\n    res,\n    userAgent,\n    ip,\n\n    // Utilities\n    logger,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createTRPCContext>>;\n```\n\n### Context with Dependency Injection\n\n```typescript title=\"server/context.ts\"\nimport { Container } from 'typedi';\nimport { UserService } from './services/user-service';\nimport { EmailService } from './services/email-service';\nimport { PaymentService } from './services/payment-service';\n\nexport async function createTRPCContext(opts: CreateNextContextOptions) {\n  const { req, res } = opts;\n\n  // Get services from DI container\n  const userService = Container.get(UserService);\n  const emailService = Container.get(EmailService);\n  const paymentService = Container.get(PaymentService);\n\n  const session = await getServerSession(req, res, authOptions);\n\n  return {\n    // Core\n    prisma,\n    session,\n    req,\n    res,\n\n    // Services\n    services: {\n      user: userService,\n      email: emailService,\n      payment: paymentService,\n    },\n  };\n}\n```\n\n## Using Context in Procedures\n\n### Accessing Context Data\n\n```typescript title=\"server/routers/users.ts\"\nexport const usersRouter = t.router({\n  // Get current user profile\n  profile: t.procedure\n    .query(async ({ ctx }) => {\n      // Access user from context\n      if (!ctx.session?.user) {\n        throw new TRPCError({\n          code: 'UNAUTHORIZED',\n          message: 'You must be logged in'\n        });\n      }\n\n      return await ctx.prisma.user.findUnique({\n        where: { id: ctx.session.user.id },\n        include: { posts: true, followers: true }\n      });\n    }),\n\n  // Update profile with logging\n  updateProfile: t.procedure\n    .input(z.object({\n      name: z.string().optional(),\n      bio: z.string().optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      if (!ctx.user) {\n        throw new TRPCError({ code: 'UNAUTHORIZED' });\n      }\n\n      // Log the action\n      ctx.logger.info('User updating profile', {\n        userId: ctx.user.id,\n        changes: input,\n      });\n\n      return await ctx.prisma.user.update({\n        where: { id: ctx.user.id },\n        data: input,\n      });\n    }),\n\n  // Cache user data\n  byId: t.procedure\n    .input(z.string())\n    .query(async ({ input, ctx }) => {\n      const cacheKey = `user:${input}`;\n\n      // Try cache first\n      const cached = await ctx.redis.get(cacheKey);\n      if (cached) {\n        return JSON.parse(cached);\n      }\n\n      // Fetch from database\n      const user = await ctx.prisma.user.findUnique({\n        where: { id: input },\n      });\n\n      if (user) {\n        // Cache for 5 minutes\n        await ctx.redis.setex(cacheKey, 300, JSON.stringify(user));\n      }\n\n      return user;\n    }),\n});\n```\n\n## Understanding Middleware\n\n**Middleware** runs before procedures and can:\n\n- Authenticate requests\n- Log operations\n- Transform input/output\n- Add data to context\n- Implement rate limiting\n- Handle CORS\n\n### Middleware Execution Flow\n\n```\nRequest ‚Üí Context Creation ‚Üí Middleware Chain ‚Üí Procedure ‚Üí Response\n                              ‚Üì\n                          [Auth] ‚Üí [Logging] ‚Üí [Validation] ‚Üí [Procedure]\n```\n\n## Authentication Middleware\n\n### Basic Authentication\n\n```typescript title=\"server/middleware/auth.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { t } from '../trpc';\n\n// Require authentication\nexport const requireAuth = t.middleware(({ ctx, next }) => {\n  if (!ctx.session?.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You must be logged in to access this resource',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      // Ensure user is typed as non-null\n      user: ctx.session.user,\n    },\n  });\n});\n\n// Require specific role\nexport const requireRole = (role: string) =>\n  t.middleware(({ ctx, next }) => {\n    if (!ctx.session?.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    if (ctx.session.user.role !== role) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `This action requires ${role} privileges`,\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user: ctx.session.user,\n      },\n    });\n  });\n\n// Multiple roles\nexport const requireAnyRole = (roles: string[]) =>\n  t.middleware(({ ctx, next }) => {\n    if (!ctx.session?.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    if (!roles.includes(ctx.session.user.role)) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `This action requires one of: ${roles.join(', ')}`,\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user: ctx.session.user,\n      },\n    });\n  });\n```\n\n### Advanced Authentication\n\n```typescript title=\"server/middleware/auth.ts\"\n// Resource ownership check\nexport const requireOwnership = (getOwnerId: (input: any) => string) =>\n  t.middleware(async ({ ctx, input, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    const ownerId = getOwnerId(input);\n\n    if (ctx.user.id !== ownerId) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: 'You can only access your own resources',\n      });\n    }\n\n    return next({ ctx });\n  });\n\n// API key authentication\nexport const requireApiKey = t.middleware(({ ctx, next }) => {\n  const apiKey = ctx.req.headers['x-api-key'];\n\n  if (!apiKey) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'API key required',\n    });\n  }\n\n  // Validate API key\n  const validKey = validateApiKey(apiKey);\n  if (!validKey) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Invalid API key',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      apiKey: validKey,\n    },\n  });\n});\n```\n\n## Logging Middleware\n\n### Request Logging\n\n```typescript title=\"server/middleware/logging.ts\"\nexport const withLogging = t.middleware(async ({ path, type, next, ctx }) => {\n  const start = Date.now();\n\n  ctx.logger.info('Request started', {\n    path,\n    type,\n    userId: ctx.user?.id,\n    userAgent: ctx.userAgent,\n    ip: ctx.ip,\n  });\n\n  const result = await next();\n\n  const duration = Date.now() - start;\n\n  if (result.ok) {\n    ctx.logger.info('Request completed', {\n      path,\n      type,\n      duration,\n      userId: ctx.user?.id,\n    });\n  } else {\n    ctx.logger.error('Request failed', {\n      path,\n      type,\n      duration,\n      error: result.error,\n      userId: ctx.user?.id,\n    });\n  }\n\n  return result;\n});\n\n// Detailed operation logging\nexport const withOperationLogging = (operation: string) =>\n  t.middleware(async ({ next, ctx, input }) => {\n    ctx.logger.info(`${operation} started`, {\n      operation,\n      input,\n      userId: ctx.user?.id,\n    });\n\n    const result = await next();\n\n    if (result.ok) {\n      ctx.logger.info(`${operation} completed`, {\n        operation,\n        userId: ctx.user?.id,\n      });\n    } else {\n      ctx.logger.error(`${operation} failed`, {\n        operation,\n        error: result.error.message,\n        userId: ctx.user?.id,\n      });\n    }\n\n    return result;\n  });\n```\n\n### Audit Logging\n\n```typescript title=\"server/middleware/audit.ts\"\nexport const withAuditLog = (action: string) =>\n  t.middleware(async ({ next, ctx, input }) => {\n    const result = await next();\n\n    if (result.ok && ctx.user) {\n      // Log successful actions for audit trail\n      await ctx.prisma.auditLog.create({\n        data: {\n          action,\n          userId: ctx.user.id,\n          input: JSON.stringify(input),\n          timestamp: new Date(),\n          ip: ctx.ip,\n          userAgent: ctx.userAgent,\n        },\n      });\n    }\n\n    return result;\n  });\n```\n\n## Rate Limiting Middleware\n\n### Simple Rate Limiting\n\n```typescript title=\"server/middleware/rate-limit.ts\"\nexport const withRateLimit = (options: {\n  max: number;\n  windowMs: number;\n  keyGenerator?: (ctx: Context) => string;\n}) =>\n  t.middleware(async ({ ctx, next }) => {\n    const key = options.keyGenerator\n      ? options.keyGenerator(ctx)\n      : ctx.user?.id || ctx.ip || 'anonymous';\n\n    const rateLimitKey = `rate_limit:${key}`;\n\n    const current = await ctx.redis.incr(rateLimitKey);\n\n    if (current === 1) {\n      // First request in window\n      await ctx.redis.expire(rateLimitKey, Math.ceil(options.windowMs / 1000));\n    }\n\n    if (current > options.max) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Rate limit exceeded',\n      });\n    }\n\n    return next();\n  });\n\n// Usage with different limits for different actions\nexport const withUserRateLimit = withRateLimit({\n  max: 100,\n  windowMs: 60 * 1000, // 1 minute\n  keyGenerator: (ctx) => `user:${ctx.user?.id || ctx.ip}`,\n});\n\nexport const withStrictRateLimit = withRateLimit({\n  max: 10,\n  windowMs: 60 * 1000,\n  keyGenerator: (ctx) => `strict:${ctx.user?.id || ctx.ip}`,\n});\n```\n\n### Advanced Rate Limiting\n\n```typescript title=\"server/middleware/advanced-rate-limit.ts\"\n// Different limits for different user tiers\nexport const withTieredRateLimit = t.middleware(async ({ ctx, next }) => {\n  if (!ctx.user) {\n    // Anonymous users: 10 requests per minute\n    return withRateLimit({ max: 10, windowMs: 60 * 1000 })({ ctx, next });\n  }\n\n  const limits = {\n    basic: { max: 100, windowMs: 60 * 1000 },\n    premium: { max: 500, windowMs: 60 * 1000 },\n    enterprise: { max: 2000, windowMs: 60 * 1000 },\n  };\n\n  const userLimit = limits[ctx.user.tier] || limits.basic;\n\n  return withRateLimit({\n    ...userLimit,\n    keyGenerator: () => `user:${ctx.user.id}`,\n  })({ ctx, next });\n});\n```\n\n## Validation Middleware\n\n### Input Sanitization\n\n```typescript title=\"server/middleware/validation.ts\"\n// Sanitize string inputs\nexport const withInputSanitization = t.middleware(({ input, next }) => {\n  if (typeof input === 'object' && input !== null) {\n    const sanitized = sanitizeObject(input);\n    return next({ input: sanitized });\n  }\n\n  return next();\n});\n\nfunction sanitizeObject(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(sanitizeObject);\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      sanitized[key] = sanitizeObject(value);\n    }\n    return sanitized;\n  }\n\n  if (typeof obj === 'string') {\n    // Remove potential XSS\n    return obj.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  }\n\n  return obj;\n}\n\n// File upload validation\nexport const withFileValidation = (options: {\n  maxSize: number;\n  allowedTypes: string[];\n}) =>\n  t.middleware(({ input, next }) => {\n    if (input && typeof input === 'object' && 'file' in input) {\n      const file = input.file as any;\n\n      if (file.size > options.maxSize) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: `File too large. Maximum size: ${options.maxSize} bytes`,\n        });\n      }\n\n      if (!options.allowedTypes.includes(file.type)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: `Invalid file type. Allowed: ${options.allowedTypes.join(', ')}`,\n        });\n      }\n    }\n\n    return next();\n  });\n```\n\n## Composing Middleware\n\n### Creating Procedure Builders\n\n```typescript title=\"server/procedures.ts\"\nimport { t } from './trpc';\nimport { requireAuth, requireRole } from './middleware/auth';\nimport { withLogging } from './middleware/logging';\nimport { withRateLimit } from './middleware/rate-limit';\n\n// Base procedure with logging\nexport const publicProcedure = t.procedure.use(withLogging);\n\n// Authenticated procedure\nexport const protectedProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth);\n\n// Admin procedure\nexport const adminProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth)\n  .use(requireRole('admin'));\n\n// Rate-limited procedure\nexport const rateLimitedProcedure = t.procedure\n  .use(withLogging)\n  .use(withRateLimit({ max: 10, windowMs: 60 * 1000 }));\n\n// Premium feature procedure\nexport const premiumProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth)\n  .use(requireAnyRole(['premium', 'enterprise']));\n```\n\n### Complex Middleware Chains\n\n```typescript title=\"server/procedures/complex.ts\"\n// File upload procedure\nexport const fileUploadProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth)\n  .use(withFileValidation({\n    maxSize: 10 * 1024 * 1024, // 10MB\n    allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],\n  }))\n  .use(withRateLimit({ max: 5, windowMs: 60 * 1000 }))\n  .use(withAuditLog('file_upload'));\n\n// Sensitive data procedure\nexport const sensitiveDataProcedure = t.procedure\n  .use(withLogging)\n  .use(requireAuth)\n  .use(requireRole('admin'))\n  .use(withStrictRateLimit)\n  .use(withInputSanitization)\n  .use(withAuditLog('sensitive_data_access'));\n\n// Public API procedure\nexport const publicApiProcedure = t.procedure\n  .use(withLogging)\n  .use(requireApiKey)\n  .use(withTieredRateLimit)\n  .use(withInputSanitization);\n```\n\n## Error Handling in Middleware\n\n### Graceful Error Handling\n\n```typescript title=\"server/middleware/error-handling.ts\"\nexport const withErrorHandling = t.middleware(async ({ next, ctx, path }) => {\n  try {\n    return await next();\n  } catch (error) {\n    // Log the error\n    ctx.logger.error('Procedure error', {\n      path,\n      error: error.message,\n      stack: error.stack,\n      userId: ctx.user?.id,\n    });\n\n    // Handle specific error types\n    if (error instanceof PrismaClientKnownRequestError) {\n      if (error.code === 'P2002') {\n        throw new TRPCError({\n          code: 'CONFLICT',\n          message: 'Resource already exists',\n          cause: error,\n        });\n      }\n    }\n\n    // Re-throw tRPC errors\n    if (error instanceof TRPCError) {\n      throw error;\n    }\n\n    // Handle unexpected errors\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred',\n      cause: error,\n    });\n  }\n});\n```\n\n## Testing Context and Middleware\n\n### Unit Testing\n\n```typescript title=\"__tests__/middleware.test.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { requireAuth } from '../middleware/auth';\n\nconst t = initTRPC.context<Context>().create();\n\ndescribe('Authentication Middleware', () => {\n  it('should throw UNAUTHORIZED when no user', async () => {\n    const procedure = t.procedure.use(requireAuth).query(() => 'success');\n\n    const caller = t.createCallerFactory(t.router({ test: procedure }));\n    const ctx = { session: null, user: null } as Context;\n\n    await expect(caller(ctx).test()).rejects.toThrow(TRPCError);\n  });\n\n  it('should pass through when user exists', async () => {\n    const procedure = t.procedure.use(requireAuth).query(() => 'success');\n\n    const caller = t.createCallerFactory(t.router({ test: procedure }));\n    const ctx = {\n      session: { user: { id: '1', role: 'user' } },\n      user: { id: '1', role: 'user' }\n    } as Context;\n\n    const result = await caller(ctx).test();\n    expect(result).toBe('success');\n  });\n});\n```\n\n### Integration Testing\n\n```typescript title=\"__tests__/integration.test.ts\"\nimport { createTRPCMockContext } from '../test-utils';\nimport { appRouter } from '../routers/_app';\n\ndescribe('User Router Integration', () => {\n  it('should update user profile', async () => {\n    const mockCtx = createTRPCMockContext({\n      user: { id: '1', role: 'user' },\n      prisma: mockPrisma,\n    });\n\n    const caller = appRouter.createCaller(mockCtx);\n\n    const result = await caller.users.updateProfile({\n      name: 'John Doe',\n      bio: 'Software developer',\n    });\n\n    expect(result.name).toBe('John Doe');\n    expect(mockPrisma.user.update).toHaveBeenCalledWith({\n      where: { id: '1' },\n      data: { name: 'John Doe', bio: 'Software developer' },\n    });\n  });\n});\n```\n\n## Best Practices\n\n<Accordions>\n<Accordion id='context-design' title=\"Context Design\">\n\n- **Keep context lean**: Only include data that's needed across multiple procedures\n- **Use factories**: Create context factories for different environments (test, dev, prod)\n- **Type safety**: Always type your context for better DX\n- **Lazy loading**: Only initialize expensive services when needed\n\n```typescript\n// Good: Focused context\nexport type Context = {\n  prisma: PrismaClient;\n  user: User | null;\n  logger: Logger;\n}\n\n// Avoid: Kitchen sink context\nexport type Context = {\n  // Too many responsibilities\n  prisma: PrismaClient;\n  redis: Redis;\n  s3: S3Client;\n  stripe: Stripe;\n  sendgrid: SendGridAPI;\n  // ... many more services\n}\n```\n\n</Accordion>\n\n<Accordion id='middleware-composition' title=\"Middleware Composition\">\n\n- **Single responsibility**: Each middleware should have one clear purpose\n- **Composable**: Design middleware to work well together\n- **Order matters**: Be intentional about middleware execution order\n- **Error handling**: Handle errors gracefully and consistently\n\n```typescript\n// Good: Clear middleware chain\nexport const sensitiveActionProcedure = t.procedure\n  .use(withLogging)        // Log everything\n  .use(requireAuth)        // Ensure authenticated\n  .use(requireRole('admin')) // Check permissions\n  .use(withAuditLog('sensitive_action')) // Audit trail\n  .use(withRateLimit({ max: 5, windowMs: 60000 })); // Rate limit\n```\n\n</Accordion>\n\n<Accordion id='security' title=\"Security Considerations\">\n\n- **Input validation**: Always validate and sanitize inputs\n- **Rate limiting**: Implement rate limiting for all public endpoints\n- **Audit logging**: Log sensitive operations for compliance\n- **Error information**: Don't leak sensitive data in error messages\n\n```typescript\n// Good: Secure error handling\nif (!user) {\n  throw new TRPCError({\n    code: 'NOT_FOUND',\n    message: 'Resource not found', // Don't reveal if user exists\n  });\n}\n```\n\n</Accordion>\n</Accordions>\n\n---\n\nContext and middleware are essential for building robust, secure, and maintainable tRPC APIs. They enable you to implement cross-cutting concerns while keeping your procedure logic focused and clean.\n"}, {"info":{"path":"framework/example-apps.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/example-apps.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Example Applications","description":"Complete working examples for different frameworks and use cases","icon":"IconApps","index":false},"content":"\nExplore real-world tRPC applications that demonstrate best practices, common patterns, and integration with popular frameworks. Each example includes complete source code, setup instructions, and key learning points.\n\n## Featured Examples\n\n### Next.js Full-Stack Applications\n\n<Cards>\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/next-minimal-starter\"\n    title=\"Next.js Minimal Starter\"\n    icon={<IconBrandNextjs />}\n  >\n    Clean starting point for Next.js projects with App Router, TanStack React\n    Query, and modern patterns.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/next-prisma-starter\"\n    title=\"Next.js + Prisma\"\n    icon={<IconDatabase />}\n  >\n    Full-stack blog with Prisma ORM, authentication, CRUD operations, and\n    type-safe database access.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/next-prisma-websockets-starter\"\n    title=\"Real-time Chat App\"\n    icon={<IconMessage />}\n  >\n    WebSocket subscriptions, real-time messaging, user presence, and live\n    notifications.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/next-sse-chat\"\n    title=\"Server-Sent Events Chat\"\n    icon={<IconBroadcast />}\n  >\n    Real-time chat using Server-Sent Events, Drizzle ORM, and modern streaming\n    patterns.\n  </Card>\n</Cards>\n\n### Server Runtime Examples\n\n<Cards>\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/cloudflare-workers\"\n    title=\"Cloudflare Workers\"\n    icon={<IconCloud />}\n  >\n    Edge runtime deployment with Fetch API adapter and serverless patterns.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/deno-deploy\"\n    title=\"Deno Deploy\"\n    icon={<IconBrandDeno />}\n  >\n    Modern TypeScript runtime with native Fetch API and edge deployment.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/bun\"\n    title=\"Bun Runtime\"\n    icon={<IconZap />}\n  >\n    Ultra-fast JavaScript runtime with built-in bundler and package manager.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/lambda-api-gateway\"\n    title=\"AWS Lambda\"\n    icon={<IconCloud />}\n  >\n    Serverless deployment with API Gateway integration and infrastructure as\n    code.\n  </Card>\n</Cards>\n\n### Framework Integrations\n\n<Cards>\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/express-server\"\n    title=\"Express.js\"\n    icon={<IconServer />}\n  >\n    Traditional Node.js server with middleware, CORS, and API documentation.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/fastify-server\"\n    title=\"Fastify\"\n    icon={<IconBolt />}\n  >\n    High-performance server with plugins, WebSocket support, and validation.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/tanstack-start\"\n    title=\"TanStack Start\"\n    icon={<IconStack />}\n  >\n    Modern full-stack framework with file-based routing and server functions.\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc/tree/main/examples/standalone-server\"\n    title=\"Standalone Server\"\n    icon={<IconTerminal />}\n  >\n    Pure Node.js HTTP server without additional frameworks or dependencies.\n  </Card>\n</Cards>\n\n## Detailed Examples\n\n### 1. Blog Application with Authentication\n\n**Stack**: Next.js, Prisma, NextAuth.js, TailwindCSS\n\nA complete blog platform showcasing:\n\n- User authentication and authorization\n- CRUD operations with optimistic updates\n- Pagination and infinite scrolling\n- Image uploads and file handling\n- SEO optimization and meta tags\n\n```typescript title=\"Key Features\"\n// Protected procedures with user context\nexport const protectedProcedure = publicProcedure.use(requireAuth);\n\n// Paginated posts with cursor-based pagination\nposts: router({\n  infinite: publicProcedure\n    .input(z.object({\n      limit: z.number().min(1).max(100).default(10),\n      cursor: z.string().optional(),\n    }))\n    .query(async ({ input }) => {\n      const posts = await db.post.findMany({\n        take: input.limit + 1,\n        cursor: input.cursor ? { id: input.cursor } : undefined,\n        orderBy: { createdAt: 'desc' },\n        include: { author: true, _count: { select: { comments: true } } },\n      });\n\n      return {\n        posts: posts.slice(0, input.limit),\n        nextCursor: posts.length > input.limit ? posts[input.limit].id : undefined,\n      };\n    }),\n}),\n```\n\n**Client-side infinite scrolling**:\n\n```typescript\nconst postsQuery = useInfiniteQuery(\n  trpc.posts.infinite.infiniteQueryOptions({\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n  })\n);\n\n// Load more posts\nconst loadMore = () => postsQuery.fetchNextPage();\n```\n\n### 2. Real-time Collaboration Tool\n\n**Stack**: Next.js, WebSockets, Redis, Prisma\n\nFeatures real-time collaboration with:\n\n- Live document editing\n- User presence indicators\n- Conflict resolution\n- Operational transforms\n- History and versioning\n\n```typescript title=\"Real-time Subscriptions\"\n// Server-side subscription\nonDocumentUpdate: publicProcedure\n  .input(z.object({ documentId: z.string() }))\n  .subscription(async function* ({ input }) {\n    const channel = `document:${input.documentId}`;\n\n    // Subscribe to Redis pub/sub\n    const subscription = redis.subscribe(channel);\n\n    try {\n      for await (const message of subscription) {\n        yield {\n          type: message.type,\n          data: JSON.parse(message.data),\n          timestamp: Date.now(),\n        };\n      }\n    } finally {\n      subscription.unsubscribe();\n    }\n  }),\n```\n\n**Client-side real-time updates**:\n\n```typescript\n// Subscribe to document changes\ntrpc.documents.onUpdate.useSubscription(\n  { documentId },\n  {\n    onData: (update) => {\n      // Apply operational transform\n      applyOperation(update);\n\n      // Update editor state\n      setEditorState(prev => applyUpdate(prev, update));\n    },\n  }\n);\n```\n\n### 3. E-commerce API with Complex Queries\n\n**Stack**: Express, Prisma, Stripe, Redis\n\nDemonstrates advanced patterns:\n\n- Complex database relationships\n- Payment processing integration\n- Inventory management\n- Order processing workflows\n- Performance optimization\n\n```typescript title=\"Complex Business Logic\"\n// Order processing with transactions\ncreateOrder: protectedProcedure\n  .input(CreateOrderSchema)\n  .mutation(async ({ input, ctx }) => {\n    return await ctx.db.$transaction(async (tx) => {\n      // Check inventory\n      const items = await tx.product.findMany({\n        where: { id: { in: input.items.map(i => i.productId) } },\n      });\n\n      // Validate availability\n      for (const orderItem of input.items) {\n        const product = items.find(p => p.id === orderItem.productId);\n        if (!product || product.stock < orderItem.quantity) {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: `Insufficient stock for ${product?.name}`,\n          });\n        }\n      }\n\n      // Update inventory\n      await Promise.all(\n        input.items.map(item =>\n          tx.product.update({\n            where: { id: item.productId },\n            data: { stock: { decrement: item.quantity } },\n          })\n        )\n      );\n\n      // Create order\n      const order = await tx.order.create({\n        data: {\n          userId: ctx.user.id,\n          items: {\n            create: input.items.map(item => ({\n              productId: item.productId,\n              quantity: item.quantity,\n              price: items.find(p => p.id === item.productId)!.price,\n            })),\n          },\n        },\n        include: { items: { include: { product: true } } },\n      });\n\n      return order;\n    });\n  }),\n```\n\n### 4. File Upload and Processing Service\n\n**Stack**: Fastify, S3, ImageMagick, Bull Queue\n\nShows file handling patterns:\n\n- Multipart file uploads\n- Image processing pipelines\n- Background job processing\n- Cloud storage integration\n- Progress tracking\n\n```typescript title=\"File Upload Pipeline\"\n// File upload with processing\nuploadImage: protectedProcedure\n  .input(z.object({\n    filename: z.string(),\n    contentType: z.string(),\n    size: z.number().max(10 * 1024 * 1024), // 10MB max\n  }))\n  .mutation(async ({ input, ctx }) => {\n    // Generate signed upload URL\n    const uploadUrl = await generateSignedUploadUrl({\n      key: `uploads/${ctx.user.id}/${input.filename}`,\n      contentType: input.contentType,\n    });\n\n    // Create processing job\n    const job = await imageProcessingQueue.add('process-image', {\n      userId: ctx.user.id,\n      filename: input.filename,\n      operations: ['resize', 'watermark', 'optimize'],\n    });\n\n    return {\n      uploadUrl,\n      jobId: job.id,\n    };\n  }),\n\n// Check processing status\ngetProcessingStatus: protectedProcedure\n  .input(z.string())\n  .query(async ({ input }) => {\n    const job = await imageProcessingQueue.getJob(input);\n    return {\n      status: job?.finishedOn ? 'completed' : job?.processedOn ? 'processing' : 'pending',\n      progress: job?.progress || 0,\n      result: job?.returnvalue,\n    };\n  }),\n```\n\n### 5. Microservices Architecture\n\n**Stack**: Multiple services, Docker, nginx, Redis\n\nDemonstrates service-oriented architecture:\n\n- Inter-service communication\n- Service discovery\n- Shared type definitions\n- Gateway pattern\n- Load balancing\n\n```typescript title=\"Service Communication\"\n// User service\nexport const userRouter = router({\n  getProfile: publicProcedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      return await userService.getProfile(input);\n    }),\n});\n\n// Order service calling user service\nconst createOrder = protectedProcedure\n  .input(CreateOrderSchema)\n  .mutation(async ({ input, ctx }) => {\n    // Call user service to validate user\n    const user = await userServiceClient.getProfile.query(ctx.userId);\n    if (!user) {\n      throw new TRPCError({ code: 'NOT_FOUND' });\n    }\n\n    // Process order...\n    return await orderService.create(input);\n  });\n```\n\n## Pattern Examples\n\n### Advanced Authentication Patterns\n\n```typescript title=\"Role-based Access Control\"\n// Middleware for role-based access\nconst requireRole = (roles: string[]) =>\n  t.middleware(({ ctx, next }) => {\n    if (!ctx.user || !roles.includes(ctx.user.role)) {\n      throw new TRPCError({ code: 'FORBIDDEN' });\n    }\n    return next({ ctx });\n  });\n\n// Admin-only procedures\nexport const adminProcedure = protectedProcedure.use(requireRole(['admin']));\n\n// Multi-tenant access control\nexport const tenantProcedure = protectedProcedure.use(({ ctx, next }) => {\n  return next({\n    ctx: {\n      ...ctx,\n      // Add tenant-scoped database queries\n      db: ctx.db.tenant(ctx.user.tenantId),\n    },\n  });\n});\n```\n\n### Caching Strategies\n\n```typescript title=\"Intelligent Caching\"\n// Server-side caching with Redis\nconst getCachedUser = publicProcedure\n  .input(z.string())\n  .query(async ({ input }) => {\n    const cacheKey = `user:${input}`;\n\n    // Try cache first\n    let user = await redis.get(cacheKey);\n    if (user) return JSON.parse(user);\n\n    // Fetch from database\n    user = await db.user.findUnique({ where: { id: input } });\n\n    // Cache for 5 minutes\n    if (user) {\n      await redis.setex(cacheKey, 300, JSON.stringify(user));\n    }\n\n    return user;\n  });\n\n// Client-side with React Query\nconst userQuery = useQuery(trpc.users.getById.queryOptions(userId), {\n  staleTime: 5 * 60 * 1000, // 5 minutes\n  cacheTime: 10 * 60 * 1000, // 10 minutes\n  refetchOnWindowFocus: false,\n});\n```\n\n### Error Handling Patterns\n\n```typescript title=\"Structured Error Handling\"\n// Custom error types\nclass ValidationError extends TRPCError {\n  constructor(issues: z.ZodIssue[]) {\n    super({\n      code: 'BAD_REQUEST',\n      message: 'Validation failed',\n      cause: { issues },\n    });\n  }\n}\n\n// Global error handler\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        validationErrors: error.cause?.issues || null,\n        timestamp: new Date().toISOString(),\n      },\n    };\n  },\n});\n\n// Client-side error boundary\nfunction AppErrorBoundary({ children }: { children: React.ReactNode }) {\n  return (\n    <ErrorBoundary\n      FallbackComponent={({ error, resetErrorBoundary }) => (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong</h2>\n          <details>\n            <summary>Error details</summary>\n            <pre>{error.message}</pre>\n          </details>\n          <button onClick={resetErrorBoundary}>Try again</button>\n        </div>\n      )}\n    >\n      {children}\n    </ErrorBoundary>\n  );\n}\n```\n\n## Testing Examples\n\n### Unit Testing\n\n```typescript title=\"Testing tRPC Procedures\"\n// Test setup\nimport { createCallerFactory } from '@trpc/server';\nimport { appRouter } from '../src/router';\n\nconst createCaller = createCallerFactory(appRouter);\n\ndescribe('User procedures', () => {\n  it('should create a user', async () => {\n    const caller = createCaller({ user: null, db: mockDb });\n\n    const result = await caller.users.create({\n      email: 'test@example.com',\n      name: 'Test User',\n    });\n\n    expect(result).toMatchObject({\n      email: 'test@example.com',\n      name: 'Test User',\n    });\n  });\n\n  it('should throw error for invalid email', async () => {\n    const caller = createCaller({ user: null, db: mockDb });\n\n    await expect(\n      caller.users.create({\n        email: 'invalid-email',\n        name: 'Test User',\n      })\n    ).rejects.toThrow('Invalid email');\n  });\n});\n```\n\n### Integration Testing\n\n```typescript title=\"End-to-End Testing\"\n// Playwright test\nimport { test, expect } from '@playwright/test';\n\ntest('user can create and view posts', async ({ page }) => {\n  // Login\n  await page.goto('/login');\n  await page.fill('[data-testid=email]', 'test@example.com');\n  await page.fill('[data-testid=password]', 'password');\n  await page.click('[data-testid=submit]');\n\n  // Create post\n  await page.goto('/posts/new');\n  await page.fill('[data-testid=title]', 'Test Post');\n  await page.fill('[data-testid=content]', 'This is a test post');\n  await page.click('[data-testid=publish]');\n\n  // Verify post appears\n  await expect(page.locator('text=Test Post')).toBeVisible();\n});\n```\n\n## Deployment Examples\n\n### Docker Deployment\n\n```dockerfile title=\"Dockerfile\"\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# Copy source code\nCOPY . .\n\n# Build application\nRUN npm run build\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1\n\n# Start application\nCMD [\"npm\", \"start\"]\n```\n\n### Kubernetes Configuration\n\n```yaml title=\"k8s-deployment.yaml\"\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: trpc-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: trpc-app\n  template:\n    metadata:\n      labels:\n        app: trpc-app\n    spec:\n      containers:\n        - name: app\n          image: trpc-app:latest\n          ports:\n            - containerPort: 3000\n          env:\n            - name: DATABASE_URL\n              valueFrom:\n                secretKeyRef:\n                  name: db-secret\n                  key: url\n          resources:\n            requests:\n              memory: '256Mi'\n              cpu: '250m'\n            limits:\n              memory: '512Mi'\n              cpu: '500m'\n```\n\n## Performance Optimization Examples\n\n### Request Batching\n\n```typescript title=\"Optimized Batching\"\n// Client configuration for optimal batching\nconst trpc = createTRPCContext<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: '/api/trpc',\n      // Batch requests that occur within 10ms\n      maxBatchSize: 10,\n      // Custom batching logic\n      batchCondition: (requests) => requests.length <= 5,\n    }),\n  ],\n});\n\n// These queries will be batched automatically\nconst user = useQuery(trpc.users.getById.queryOptions('1'));\nconst posts = useQuery(trpc.posts.getByUserId.queryOptions('1'));\nconst comments = useQuery(trpc.comments.getByUserId.queryOptions('1'));\n```\n\n### Database Optimization\n\n```typescript title=\"Efficient Database Queries\"\n// Optimized queries with proper includes\nconst getPostWithDetails = publicProcedure\n  .input(z.string())\n  .query(async ({ input }) => {\n    return await db.post.findUnique({\n      where: { id: input },\n      include: {\n        author: {\n          select: { id: true, name: true, avatar: true }\n        },\n        comments: {\n          take: 10,\n          orderBy: { createdAt: 'desc' },\n          include: {\n            author: {\n              select: { id: true, name: true, avatar: true }\n            }\n          }\n        },\n        _count: {\n          select: {\n            likes: true,\n            comments: true\n          }\n        }\n      }\n    });\n  });\n```\n\n---\n\nThese examples demonstrate tRPC's flexibility and power across different use cases. Each example is production-ready and follows best practices for scalability, maintainability, and performance.\n"}, {"info":{"path":"framework/getting-started.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/getting-started.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Getting Started","description":"Learn the fundamentals of building APIs with tRPC","icon":"IconPlayCircle","index":false},"content":"\nWelcome to tRPC! This guide will walk you through the fundamentals of building type-safe APIs with tRPC, from basic concepts to building your first application.\n\n## What is tRPC?\n\ntRPC (TypeScript Remote Procedure Call) is a library that lets you build fully type-safe APIs without any code generation or runtime bloat. You write functions on your server, and call them directly from your client - all with complete TypeScript type safety.\n\n### Key Benefits\n\n**End-to-End Type Safety**: Your client automatically knows the exact shape of your server's data\n**No Code Generation**: Types are inferred directly from your server code\n**Excellent DX**: Autocomplete, go-to-definition, and refactoring work across your entire stack\n**React Query Integration**: Built on top of TanStack React Query for optimal data fetching\n\n## Before You Start\n\nTo follow this guide, you'll need:\n\n- Basic TypeScript knowledge\n- Understanding of React (for frontend examples)\n- Node.js 18+ installed\n- A code editor with TypeScript support\n\n## Your First tRPC Application\n\nLet's build a simple blog API to understand tRPC fundamentals.\n\n### Step 1: Set Up Your Project\n\nCreate a new project and install dependencies:\n\n```bash\nmkdir my-trpc-app\ncd my-trpc-app\nnpm init -y\nnpm install typescript @types/node tsx\nnpm install @trpc/server @trpc/client zod\n```\n\n### Step 2: Create Your Server\n\nFirst, initialize tRPC:\n\n```typescript title=\"src/server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\n\n// Initialize tRPC\nconst t = initTRPC.create();\n\n// Export reusable router and procedure helpers\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\nCreate your first router:\n\n```typescript title=\"src/server/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Mock database\nconst posts = [\n  { id: 1, title: 'Hello World', content: 'This is my first post!' },\n  { id: 2, title: 'TypeScript Tips', content: 'Learn TypeScript with tRPC' },\n];\n\nexport const appRouter = router({\n  // Simple greeting\n  hello: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .query(({ input }) => {\n      return { message: `Hello, ${input.name}!` };\n    }),\n\n  // Get all posts\n  posts: publicProcedure\n    .query(() => {\n      return posts;\n    }),\n\n  // Get post by ID\n  post: publicProcedure\n    .input(z.number())\n    .query(({ input }) => {\n      const post = posts.find(p => p.id === input);\n      if (!post) throw new Error('Post not found');\n      return post;\n    }),\n\n  // Create a new post\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string(),\n      content: z.string(),\n    }))\n    .mutation(({ input }) => {\n      const newPost = {\n        id: posts.length + 1,\n        ...input,\n      };\n      posts.push(newPost);\n      return newPost;\n    }),\n});\n\n// Export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n### Step 3: Create HTTP Server\n\nLet's serve our tRPC router with Express:\n\n```bash\nnpm install express cors\nnpm install -D @types/express @types/cors\n```\n\n```typescript title=\"src/server/index.ts\"\nimport express from 'express';\nimport cors from 'cors';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport { appRouter } from './router';\n\nconst app = express();\nconst port = 3001;\n\n// Enable CORS\napp.use(cors());\n\n// Create tRPC middleware\napp.use('/api/trpc', createExpressMiddleware({\n  router: appRouter,\n  createContext: () => ({}), // We'll add context later\n}));\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});\n```\n\nStart your server:\n\n```bash\nnpx tsx src/server/index.ts\n```\n\nYour API is now running at `http://localhost:3001/api/trpc`!\n\n### Step 4: Test Your API\n\nYou can test your endpoints directly:\n\n- `GET http://localhost:3001/api/trpc/posts` - Get all posts\n- `GET http://localhost:3001/api/trpc/hello?input={\"name\":\"World\"}` - Say hello\n\n## Understanding the Architecture\n\n### Routers vs Procedures\n\n**Router**: A collection of procedures grouped together\n**Procedure**: A single API endpoint (query, mutation, or subscription)\n\n```typescript\nconst appRouter = router({\n  // This is a procedure\n  hello: publicProcedure.query(() => 'Hello'),\n\n  // This is a nested router\n  posts: router({\n    list: publicProcedure.query(() => posts),\n    create: publicProcedure.mutation(() => {/* ... */}),\n  }),\n});\n\n// Usage: trpc.hello.query()\n// Usage: trpc.posts.list.query()\n// Usage: trpc.posts.create.mutate()\n```\n\n### Query vs Mutation vs Subscription\n\n**Query**: For reading data (idempotent, cacheable)\n\n```typescript\ngetPosts: publicProcedure.query(() => posts)\n```\n\n**Mutation**: For writing data (side effects)\n\n```typescript\ncreatePost: publicProcedure\n  .input(PostSchema)\n  .mutation(({ input }) => createPost(input))\n```\n\n**Subscription**: For real-time data (advanced)\n\n```typescript\nonPostCreated: publicProcedure\n  .subscription(() => observable)\n```\n\n### Input Validation\n\ntRPC uses Zod for runtime validation and TypeScript inference:\n\n```typescript\nconst createUser = publicProcedure\n  .input(z.object({\n    name: z.string().min(1, 'Name is required'),\n    email: z.string().email('Invalid email'),\n    age: z.number().min(13).max(120),\n  }))\n  .mutation(({ input }) => {\n    // input is fully typed and validated\n    return createUser(input);\n  });\n```\n\n## Building the Frontend\n\nNow let's create a React frontend that uses our API.\n\n### Step 1: Set Up React Client\n\n```bash\nnpm install react react-dom @tanstack/react-query\nnpm install -D @types/react @types/react-dom\n```\n\n### Step 2: Create tRPC Client\n\n```typescript title=\"src/client/trpc.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server/router';\n\n// Vanilla client (for Node.js, testing, etc.)\nexport const trpcClient = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3001/api/trpc',\n    }),\n  ],\n});\n```\n\n### Step 3: Set Up React Query Integration\n\n```bash\nnpm install @trpc/tanstack-react-query\n```\n\n```typescript title=\"src/client/trpc-react.ts\"\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n\n// Create React Query context\nexport const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();\n```\n\n### Step 4: Create React App\n\n```typescript title=\"src/client/App.tsx\"\nimport React, { useState } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { TRPCProvider } from './trpc-react';\nimport { PostsList } from './components/PostsList';\n\nconst queryClient = new QueryClient();\n\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3001/api/trpc',\n    }),\n  ],\n});\n\nexport function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        <div style={{ padding: '2rem' }}>\n          <h1>My tRPC Blog</h1>\n          <PostsList />\n        </div>\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n### Step 5: Use tRPC in Components\n\n```typescript title=\"src/client/components/PostsList.tsx\"\nimport React, { useState } from 'react';\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from '../trpc-react';\n\nexport function PostsList() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n\n  // Fetch posts with React Query\n  const postsQuery = useQuery(trpc.posts.queryOptions());\n\n  // Create post mutation\n  const createPostMutation = useMutation(trpc.createPost.mutationOptions({\n    onSuccess: () => {\n      // Refetch posts after creating\n      queryClient.invalidateQueries(trpc.posts.queryKey());\n      setTitle('');\n      setContent('');\n    },\n  }));\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (title && content) {\n      createPostMutation.mutate({ title, content });\n    }\n  };\n\n  if (postsQuery.isLoading) return <div>Loading...</div>;\n  if (postsQuery.error) return <div>Error: {postsQuery.error.message}</div>;\n\n  return (\n    <div>\n      <h2>Posts</h2>\n\n      {/* Create Post Form */}\n      <form onSubmit={handleSubmit} style={{ marginBottom: '2rem' }}>\n        <div style={{ marginBottom: '1rem' }}>\n          <input\n            type=\"text\"\n            placeholder=\"Title\"\n            value={title}\n            onChange={(e) => setTitle(e.target.value)}\n            style={{ width: '100%', padding: '0.5rem', marginBottom: '0.5rem' }}\n          />\n          <textarea\n            placeholder=\"Content\"\n            value={content}\n            onChange={(e) => setContent(e.target.value)}\n            style={{ width: '100%', padding: '0.5rem', minHeight: '100px' }}\n          />\n        </div>\n        <button type=\"submit\" disabled={createPostMutation.isPending}>\n          {createPostMutation.isPending ? 'Creating...' : 'Create Post'}\n        </button>\n      </form>\n\n      {/* Posts List */}\n      <div>\n        {postsQuery.data?.map((post) => (\n          <div key={post.id} style={{ border: '1px solid #ccc', padding: '1rem', marginBottom: '1rem' }}>\n            <h3>{post.title}</h3>\n            <p>{post.content}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n## Key Features Explained\n\n### Automatic Type Safety\n\nNotice how you get full type safety without any manual type definitions:\n\n```typescript\n// On the client, this is fully typed!\nconst postsQuery = useQuery(trpc.posts.queryOptions());\n// postsQuery.data is typed as Post[] | undefined\n\nconst post = await trpc.post.query(1);\n// post is typed as Post\n\nconst newPost = await trpc.createPost.mutate({\n  title: 'Hello',\n  content: 'World'\n});\n// newPost is typed as Post\n```\n\n### Request Batching\n\nMultiple tRPC calls are automatically batched:\n\n```typescript\n// These three queries will be sent as a single HTTP request\nconst user = useQuery(trpc.user.query());\nconst posts = useQuery(trpc.posts.query());\nconst comments = useQuery(trpc.comments.query());\n```\n\n### Error Handling\n\ntRPC provides structured error handling:\n\n```typescript\n// Server\nif (!user) {\n  throw new TRPCError({\n    code: 'NOT_FOUND',\n    message: 'User not found',\n  });\n}\n\n// Client\nconst mutation = useMutation(trpc.createPost.mutationOptions({\n  onError: (error) => {\n    if (error.data?.code === 'NOT_FOUND') {\n      // Handle not found error\n    }\n  },\n}));\n```\n\n## Adding Context & Authentication\n\nReal applications need context for database connections, user sessions, etc.\n\n### Server Context\n\n```typescript title=\"src/server/context.ts\"\nimport { CreateExpressContextOptions } from '@trpc/server/adapters/express';\n\nexport function createContext({ req, res }: CreateExpressContextOptions) {\n  // Get user from JWT token, session, etc.\n  const user = getUserFromRequest(req);\n\n  return {\n    user,\n    db, // Database connection\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n### Protected Procedures\n\n```typescript title=\"src/server/trpc.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const publicProcedure = t.procedure;\n\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.user, // Now user is guaranteed to exist\n    },\n  });\n});\n```\n\n## Common Patterns\n\n### Pagination\n\n```typescript\nconst getPosts = publicProcedure\n  .input(z.object({\n    limit: z.number().min(1).max(100).default(10),\n    cursor: z.string().optional(),\n  }))\n  .query(async ({ input }) => {\n    const posts = await db.post.findMany({\n      take: input.limit + 1,\n      cursor: input.cursor ? { id: input.cursor } : undefined,\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return {\n      posts: posts.slice(0, input.limit),\n      nextCursor: posts.length > input.limit ? posts[input.limit].id : undefined,\n    };\n  });\n```\n\n### Nested Resources\n\n```typescript\nconst appRouter = router({\n  users: router({\n    list: publicProcedure.query(() => getUsers()),\n    byId: publicProcedure\n      .input(z.string())\n      .query(({ input }) => getUserById(input)),\n    posts: publicProcedure\n      .input(z.string())\n      .query(({ input }) => getPostsByUserId(input)),\n  }),\n});\n\n// Usage: trpc.users.byId.query('123')\n// Usage: trpc.users.posts.query('123')\n```\n\n### Optimistic Updates\n\n```typescript\nconst createPostMutation = useMutation(trpc.posts.create.mutationOptions({\n  onMutate: async (newPost) => {\n    // Cancel outgoing refetches\n    await queryClient.cancelQueries(trpc.posts.list.queryKey());\n\n    // Snapshot the previous value\n    const previousPosts = queryClient.getQueryData(trpc.posts.list.queryKey());\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(trpc.posts.list.queryKey(), (old) => [\n      ...(old || []),\n      { ...newPost, id: Date.now() }, // Temporary ID\n    ]);\n\n    return { previousPosts };\n  },\n  onError: (err, newPost, context) => {\n    // Rollback to previous value on error\n    queryClient.setQueryData(\n      trpc.posts.list.queryKey(),\n      context?.previousPosts\n    );\n  },\n  onSettled: () => {\n    // Always refetch after error or success\n    queryClient.invalidateQueries(trpc.posts.list.queryKey());\n  },\n}));\n```\n\n## Next Steps\n\nNow that you understand the basics, you can:\n\n<Cards>\n  <Card\n    href=\"/docs/framework/concepts\"\n    title=\"Learn Core Concepts\"\n    icon={<IconBrain />}\n  >\n    Deep dive into routers, procedures, context, and middleware\n  </Card>\n  <Card\n    href=\"/docs/framework/quickstart\"\n    title=\"Follow the Quickstart\"\n    icon={<IconRocket />}\n  >\n    Build a complete application step-by-step\n  </Card>\n  <Card\n    href=\"/docs/framework/example-apps\"\n    title=\"Explore Examples\"\n    icon={<IconApps />}\n  >\n    See real-world applications and patterns\n  </Card>\n  <Card\n    href=\"/docs/server/introduction\"\n    title=\"Server Documentation\"\n    icon={<IconServer />}\n  >\n    Learn about server-specific features and adapters\n  </Card>\n</Cards>\n\n## Best Practices\n\n**Project Structure**: Organize routers by domain (users, posts, auth)\n**Type Safety**: Always export your router type for client consumption\n**Error Handling**: Use tRPC's structured error system\n**Validation**: Validate inputs with Zod schemas\n**Caching**: Leverage React Query's caching strategies\n\nRemember: tRPC's power comes from its simplicity. You write TypeScript functions on the server, and call them type-safely from the client. Everything else is just optimization and organization.\n"}, {"info":{"path":"framework/index.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/index.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"tRPC","description":"End-to-end typesafe APIs made easy","icon":"IconBrandTypescript","index":false},"content":"\n## What is tRPC?\n\n**tRPC** <span className='text-muted-foreground text-sm'>(TypeScript Remote Procedure Call)</span> enables you to build fully typesafe APIs without schemas or code generation. You write TypeScript functions on your server, and call them directly from your client with complete type safety and IDE support.\n\n<Callout title=\"The magic of tRPC\">\n  With traditional REST APIs, you define endpoints and hope your client matches\n  the expected types. With tRPC, your client automatically knows exactly what\n  your server returns - and TypeScript will catch any breaking changes at build\n  time.\n</Callout>\n\n## How it works\n\ntRPC creates a bridge between your TypeScript server and client through three simple steps:\n\n1. **Define procedures** on your server with full TypeScript types\n2. **Export your router type** (just the type, not the implementation)\n3. **Import the type** on your client for automatic type inference\n\n```typescript\n// 1. Server: Define your API\nexport const appRouter = t.router({\n  getUser: t.procedure\n    .input(z.string())\n    .query(({ input }) => getUserById(input))\n});\n\n// 2. Export the type\nexport type AppRouter = typeof appRouter;\n\n// 3. Client: Fully typed automatically\nconst user = await trpc.getUser.query('123');\n//    ^? User | null - TypeScript knows the exact return type\n```\n\n## Server vs Client\n\ntRPC is split into two main parts that work together:\n\n<Cards>\n  <Card \n    href=\"/docs/server\" \n    title=\"tRPC Server\" \n    icon={<IconServer className=\"text-blue-500\" />}\n  >\n    Build your API with procedures, routers, middleware, and validation. This is where you define your backend logic.\n  </Card>\n\n  <Card \n    href=\"/docs/client\" \n    title=\"tRPC Client\" \n    icon={<IconDeviceDesktop className=\"text-green-500\" />}\n  >\n    Connect your frontend to your tRPC server with React, Next.js, or vanilla JavaScript. Get full type safety and great DX.\n  </Card>\n</Cards>\n\n<Callout title=\"Start with the right section\">\n  **Building an API?** Start with [tRPC Server](/docs/server) to define your\n  procedures and routers. **Integrating with a frontend?** Jump to [tRPC\n  Client](/docs/client) to set up your React, Next.js, or vanilla client.\n</Callout>\n\n## Quick Example\n\nHere's what a complete tRPC setup looks like:\n\n<Tabs items={['Server', 'Client', 'React Component']}>\n<Tab value=\"Server\">\n\n```typescript title=\"server/router.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getPosts: t.procedure\n    .query(async () => {\n      return await db.post.findMany();\n    }),\n\n  createPost: t.procedure\n    .input(z.object({\n      title: z.string(),\n      content: z.string()\n    }))\n    .mutation(async ({ input }) => {\n      return await db.post.create({ data: input });\n    })\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n</Tab>\n\n<Tab value=\"Client\">\n```typescript title=\"client/trpc.ts\"\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n</Tab>\n\n<Tab value=\"React Component\">\n```typescript title=\"components/blog.tsx\"\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport { trpc } from '../client/trpc';\n\nexport function Blog() {\n  const utils = trpc.useUtils();\n\n// Fetch posts with full type safety\nconst postsQuery = useQuery(trpc.getPosts.queryOptions());\n\n// Create post mutation with optimistic updates\nconst createPost = useMutation(trpc.createPost.mutationOptions({\nonSuccess: () => {\nutils.getPosts.invalidate();\n}\n}));\n\nif (postsQuery.isLoading) return <div>Loading...</div>;\n\nreturn (\n\n<div>\n  {postsQuery.data?.map((post) => (\n    <article key={post.id}>\n      <h2>{post.title}</h2>\n      <p>{post.content}</p>\n    </article>\n  ))}\n</div>\n); }\n\n```\n\n</Tab>\n</Tabs>\n\n## Get Started\n\nReady to experience end-to-end type safety? Choose your path:\n\n<Cards>\n  <Card\n    href=\"/docs/framework/installation\"\n    title=\"Installation\"\n    icon={<IconDownload />}\n  >\n    Install tRPC and set up your first project in minutes\n  </Card>\n\n<Card\n  href=\"/docs/framework/quickstart\"\n  title=\"Quickstart Guide\"\n  icon={<IconRocket />}\n>\n  Build your first tRPC API with step-by-step instructions\n</Card>\n\n<Card\n  href=\"/docs/framework/concepts\"\n  title=\"Core Concepts\"\n  icon={<IconBrain />}\n>\n  Understand routers, procedures, and the tRPC architecture\n</Card>\n\n  <Card\n    href=\"/docs/framework/example-apps\"\n    title=\"Example Apps\"\n    icon={<IconApps />}\n  >\n    Explore complete applications built with tRPC\n  </Card>\n</Cards>\n\n---\n\ntRPC transforms how you build TypeScript applications by eliminating the gap between your client and server. Start with our [installation guide](/docs/framework/installation) to experience the magic of end-to-end type safety.\n```\n"}, {"info":{"path":"framework/installation.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/installation.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Installation","description":"Get started with tRPC installation for your project","icon":"IconDownload","index":false},"content":"\ntRPC is split into server and client packages. Choose the installation path based on what you're building:\n\n## Choose Your Path\n\n<Cards>\n  <Card \n    href=\"/docs/server/installation\" \n    title=\"Server Installation\" \n    icon={<IconServer className=\"text-blue-500\" />}\n  >\n    **Building an API?** Install tRPC server to create your backend procedures and routers.\n  </Card>\n\n  <Card \n    href=\"/docs/client/installation\" \n    title=\"Client Installation\" \n    icon={<IconDeviceDesktop className=\"text-green-500\" />}\n  >\n    **Building a frontend?** Install tRPC client to connect your React, Next.js, or vanilla JS app.\n  </Card>\n</Cards>\n\n## Full-Stack Setup\n\nFor complete full-stack applications, you'll need both:\n\n<Steps>\n  <Step title=\"Server Setup\">\n    Start with the server to define your API:\n    \n    ```bash\n    npm install @trpc/server zod\n    ```\n    \n    [Complete server setup guide ‚Üí](/docs/server/installation)\n  </Step>\n\n  <Step title=\"Client Setup\">\n    Then add the client to connect your frontend:\n    \n    ```bash\n    npm install @trpc/client @trpc/react-query @tanstack/react-query\n    ```\n    \n    [Complete client setup guide ‚Üí](/docs/client/installation)\n  </Step>\n</Steps>\n\n<Callout title=\"Need help choosing?\">\n  **New to tRPC?** Start with our [quickstart guide](/docs/framework/quickstart)\n  for a complete walkthrough. **Building an API?** Go to [Server\n  Installation](/docs/server/installation). **Connecting a frontend?** Go to\n  [Client Installation](/docs/client/installation).\n</Callout>\n"}, {"info":{"path":"framework/procedures.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/procedures.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Procedures","description":"Build type-safe queries, mutations, and subscriptions with tRPC procedures","icon":"IconFunction","index":false},"content":"\nProcedures are the building blocks of your tRPC API. They define individual endpoints that your client can call with complete type safety. Learn how to create powerful, type-safe procedures for every use case.\n\n## What are Procedures?\n\nA **procedure** is a function on your tRPC server that can be called from your client. Think of procedures as your API endpoints, but with automatic type inference and validation.\n\n```typescript\n// Server: Define a procedure\nconst getUserById = t.procedure\n  .input(z.string())\n  .query(({ input }) => {\n    return db.user.findUnique({ where: { id: input } });\n  });\n\n// Client: Call it with full type safety\nconst user = await trpc.getUserById.query('user_123');\n//    ^? User | null - TypeScript automatically knows the return type\n```\n\n## Types of Procedures\n\ntRPC has three types of procedures, each optimized for different use cases:\n\n<Cards>\n  <Card icon={<IconSearch />} title=\"Query\">\n    For reading data. Safe, cacheable, and idempotent operations.\n  </Card>\n\n<Card icon={<IconEdit />} title=\"Mutation\">\n  For writing data. Operations that change server state.\n</Card>\n\n  <Card icon={<IconWifi />} title=\"Subscription\">\n    For real-time data streams. Push updates from server to client.\n  </Card>\n</Cards>\n\n## Query Procedures\n\nUse `.query()` for operations that **read** data without side effects:\n\n### Basic Query\n\n```typescript title=\"server/routers/posts.ts\"\nimport { z } from 'zod';\nimport { t } from '../trpc';\n\nexport const postsRouter = t.router({\n  // Get all posts\n  list: t.procedure\n    .query(async () => {\n      return await db.post.findMany({\n        orderBy: { createdAt: 'desc' },\n        include: { author: true }\n      });\n    }),\n\n  // Get post by ID\n  byId: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      const post = await db.post.findUnique({\n        where: { id: input },\n        include: { author: true, comments: true }\n      });\n\n      if (!post) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found'\n        });\n      }\n\n      return post;\n    }),\n});\n```\n\n### Query with Complex Input\n\n```typescript title=\"server/routers/search.ts\"\nconst searchSchema = z.object({\n  query: z.string().min(1),\n  category: z.enum(['posts', 'users', 'comments']).optional(),\n  limit: z.number().min(1).max(100).default(20),\n  offset: z.number().min(0).default(0),\n  sortBy: z.enum(['relevance', 'date', 'popularity']).default('relevance'),\n});\n\nexport const searchRouter = t.router({\n  search: t.procedure\n    .input(searchSchema)\n    .query(async ({ input }) => {\n      const { query, category, limit, offset, sortBy } = input;\n\n      // Build dynamic search query\n      const results = await searchService.search({\n        query,\n        category,\n        limit,\n        offset,\n        sortBy,\n      });\n\n      return {\n        results,\n        totalCount: results.length,\n        hasMore: results.length === limit,\n      };\n    }),\n});\n```\n\n### Client Usage\n\n```tsx title=\"components/posts.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc';\n\nexport function PostsList() {\n  const trpc = useTRPC();\n\n  // Simple query\n  const postsQuery = useQuery(trpc.posts.list.queryOptions());\n\n  // Query with input\n  const featuredPostQuery = useQuery(\n    trpc.posts.byId.queryOptions('featured-post-id')\n  );\n\n  // Complex search query\n  const searchQuery = useQuery(\n    trpc.search.search.queryOptions({\n      query: 'react hooks',\n      category: 'posts',\n      limit: 10,\n      sortBy: 'relevance'\n    })\n  );\n\n  return (\n    <div>\n      {postsQuery.data?.map(post => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>By {post.author.name}</p>\n        </article>\n      ))}\n    </div>\n  );\n}\n```\n\n## Mutation Procedures\n\nUse `.mutation()` for operations that **modify** server state:\n\n### Basic Mutations\n\n```typescript title=\"server/routers/posts.ts\"\nexport const postsRouter = t.router({\n  // Create a new post\n  create: t.procedure\n    .input(z.object({\n      title: z.string().min(1).max(200),\n      content: z.string().min(1),\n      tags: z.array(z.string()).max(10).default([]),\n      published: z.boolean().default(false),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Check if user is authenticated\n      if (!ctx.user) {\n        throw new TRPCError({\n          code: 'UNAUTHORIZED',\n          message: 'You must be logged in to create a post'\n        });\n      }\n\n      const post = await db.post.create({\n        data: {\n          ...input,\n          authorId: ctx.user.id,\n        },\n        include: { author: true }\n      });\n\n      // Optionally trigger side effects\n      await notificationService.notifyFollowers(ctx.user.id, post);\n\n      return post;\n    }),\n\n  // Update existing post\n  update: t.procedure\n    .input(z.object({\n      id: z.string(),\n      title: z.string().min(1).max(200).optional(),\n      content: z.string().min(1).optional(),\n      tags: z.array(z.string()).max(10).optional(),\n      published: z.boolean().optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      const { id, ...updateData } = input;\n\n      // Check ownership\n      const existingPost = await db.post.findUnique({\n        where: { id },\n        select: { authorId: true }\n      });\n\n      if (!existingPost) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found'\n        });\n      }\n\n      if (existingPost.authorId !== ctx.user?.id) {\n        throw new TRPCError({\n          code: 'FORBIDDEN',\n          message: 'You can only edit your own posts'\n        });\n      }\n\n      return await db.post.update({\n        where: { id },\n        data: updateData,\n        include: { author: true }\n      });\n    }),\n\n  // Delete post\n  delete: t.procedure\n    .input(z.string())\n    .mutation(async ({ input: postId, ctx }) => {\n      const post = await db.post.findUnique({\n        where: { id: postId },\n        select: { authorId: true, title: true }\n      });\n\n      if (!post) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found'\n        });\n      }\n\n      if (post.authorId !== ctx.user?.id) {\n        throw new TRPCError({\n          code: 'FORBIDDEN',\n          message: 'You can only delete your own posts'\n        });\n      }\n\n      await db.post.delete({ where: { id: postId } });\n\n      return { success: true, title: post.title };\n    }),\n});\n```\n\n### Batch Operations\n\n```typescript title=\"server/routers/batch.ts\"\nexport const batchRouter = t.router({\n  // Bulk create posts\n  createMany: t.procedure\n    .input(z.array(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n      tags: z.array(z.string()).default([])\n    })).max(10)) // Limit batch size\n    .mutation(async ({ input, ctx }) => {\n      if (!ctx.user) {\n        throw new TRPCError({ code: 'UNAUTHORIZED' });\n      }\n\n      const posts = await db.$transaction(\n        input.map(post =>\n          db.post.create({\n            data: {\n              ...post,\n              authorId: ctx.user.id\n            }\n          })\n        )\n      );\n\n      return posts;\n    }),\n\n  // Bulk update\n  updateMany: t.procedure\n    .input(z.object({\n      ids: z.array(z.string()).min(1).max(50),\n      data: z.object({\n        published: z.boolean().optional(),\n        tags: z.array(z.string()).optional(),\n      })\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Verify user owns all posts\n      const posts = await db.post.findMany({\n        where: {\n          id: { in: input.ids },\n          authorId: ctx.user?.id\n        },\n        select: { id: true }\n      });\n\n      if (posts.length !== input.ids.length) {\n        throw new TRPCError({\n          code: 'FORBIDDEN',\n          message: 'You can only update your own posts'\n        });\n      }\n\n      await db.post.updateMany({\n        where: { id: { in: input.ids } },\n        data: input.data\n      });\n\n      return { updated: input.ids.length };\n    }),\n});\n```\n\n### Client Usage\n\n```tsx title=\"components/post-form.tsx\"\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc';\n\nexport function PostForm() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n\n  // Create post mutation\n  const createPost = useMutation(trpc.posts.create.mutationOptions({\n    onSuccess: (newPost) => {\n      // Update the posts list cache\n      queryClient.invalidateQueries(trpc.posts.list.queryKey());\n\n      // Add new post to cache\n      queryClient.setQueryData(\n        trpc.posts.byId.queryKey(newPost.id),\n        newPost\n      );\n\n      // Show success message\n      toast.success(`Post \"${newPost.title}\" created!`);\n    },\n    onError: (error) => {\n      toast.error(error.message);\n    }\n  }));\n\n  // Update post mutation\n  const updatePost = useMutation(trpc.posts.update.mutationOptions({\n    onSuccess: (updatedPost) => {\n      // Update specific post in cache\n      queryClient.setQueryData(\n        trpc.posts.byId.queryKey(updatedPost.id),\n        updatedPost\n      );\n\n      // Optionally invalidate list to reorder\n      queryClient.invalidateQueries(trpc.posts.list.queryKey());\n    }\n  }));\n\n  const handleSubmit = (data: PostFormData) => {\n    if (editingPost) {\n      updatePost.mutate({ id: editingPost.id, ...data });\n    } else {\n      createPost.mutate(data);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Form fields */}\n      <button\n        type=\"submit\"\n        disabled={createPost.isPending || updatePost.isPending}\n      >\n        {editingPost ? 'Update' : 'Create'} Post\n      </button>\n    </form>\n  );\n}\n```\n\n## Subscription Procedures\n\nUse `.subscription()` for real-time data streams:\n\n### Basic Subscription\n\n```typescript title=\"server/routers/realtime.ts\"\nimport { observable } from '@trpc/server/observable';\nimport { EventEmitter } from 'events';\n\n// Global event emitter for this example\nconst ee = new EventEmitter();\n\nexport const realtimeRouter = t.router({\n  // Post updates subscription\n  onPostUpdate: t.procedure\n    .input(z.object({ postId: z.string() }))\n    .subscription(({ input }) => {\n      return observable<{ type: string; post: Post }>((emit) => {\n        const onUpdate = (data: { postId: string; post: Post }) => {\n          if (data.postId === input.postId) {\n            emit.next({ type: 'update', post: data.post });\n          }\n        };\n\n        const onDelete = (data: { postId: string }) => {\n          if (data.postId === input.postId) {\n            emit.next({ type: 'delete', post: null });\n          }\n        };\n\n        // Listen for events\n        ee.on('post:update', onUpdate);\n        ee.on('post:delete', onDelete);\n\n        // Cleanup function\n        return () => {\n          ee.off('post:update', onUpdate);\n          ee.off('post:delete', onDelete);\n        };\n      });\n    }),\n\n  // Live comments stream\n  onNewComment: t.procedure\n    .input(z.object({ postId: z.string() }))\n    .subscription(({ input }) => {\n      return observable<Comment>((emit) => {\n        const onComment = (comment: Comment) => {\n          if (comment.postId === input.postId) {\n            emit.next(comment);\n          }\n        };\n\n        ee.on('comment:new', onComment);\n\n        return () => {\n          ee.off('comment:new', onComment);\n        };\n      });\n    }),\n});\n```\n\n### Advanced Subscription with Authentication\n\n```typescript title=\"server/routers/notifications.ts\"\nexport const notificationsRouter = t.router({\n  // User-specific notifications\n  onNotification: protectedProcedure\n    .subscription(({ ctx }) => {\n      return observable<Notification>((emit) => {\n        const userId = ctx.user.id;\n\n        const onNotification = (notification: Notification) => {\n          if (notification.userId === userId) {\n            emit.next(notification);\n          }\n        };\n\n        ee.on('notification:new', onNotification);\n\n        // Send existing unread notifications\n        db.notification.findMany({\n          where: { userId, read: false },\n          orderBy: { createdAt: 'desc' }\n        }).then(notifications => {\n          notifications.forEach(notification => {\n            emit.next(notification);\n          });\n        });\n\n        return () => {\n          ee.off('notification:new', onNotification);\n        };\n      });\n    }),\n});\n```\n\n### Client Usage\n\n```tsx title=\"components/live-comments.tsx\"\nimport { useTRPC } from '../lib/trpc';\n\nexport function LiveComments({ postId }: { postId: string }) {\n  const trpc = useTRPC();\n  const [comments, setComments] = useState<Comment[]>([]);\n\n  // Subscribe to new comments\n  trpc.realtime.onNewComment.useSubscription(\n    { postId },\n    {\n      onData: (comment) => {\n        setComments(prev => [comment, ...prev]);\n      },\n      onError: (error) => {\n        console.error('Subscription error:', error);\n      },\n    }\n  );\n\n  return (\n    <div>\n      <h3>Live Comments</h3>\n      {comments.map(comment => (\n        <div key={comment.id}>\n          <strong>{comment.author.name}</strong>: {comment.content}\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n## Input Validation\n\n### Zod Schemas\n\ntRPC works perfectly with Zod for input validation:\n\n```typescript title=\"server/schemas/post.ts\"\nimport { z } from 'zod';\n\nexport const createPostSchema = z.object({\n  title: z.string()\n    .min(1, 'Title is required')\n    .max(200, 'Title too long'),\n  content: z.string()\n    .min(10, 'Content must be at least 10 characters')\n    .max(50000, 'Content too long'),\n  tags: z.array(z.string())\n    .max(10, 'Too many tags')\n    .default([]),\n  published: z.boolean().default(false),\n  scheduledFor: z.date().optional(),\n});\n\nexport const updatePostSchema = createPostSchema\n  .partial()\n  .extend({\n    id: z.string(),\n  });\n\nexport const postFiltersSchema = z.object({\n  author: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  published: z.boolean().optional(),\n  createdAfter: z.date().optional(),\n  createdBefore: z.date().optional(),\n  limit: z.number().min(1).max(100).default(20),\n  offset: z.number().min(0).default(0),\n});\n```\n\n### Custom Validation\n\n```typescript title=\"server/routers/posts.ts\"\nexport const postsRouter = t.router({\n  create: t.procedure\n    .input(createPostSchema.refine(\n      (data) => {\n        // Custom validation: if scheduled, must be in future\n        if (data.scheduledFor && data.scheduledFor <= new Date()) {\n          return false;\n        }\n        return true;\n      },\n      {\n        message: 'Scheduled date must be in the future',\n        path: ['scheduledFor']\n      }\n    ))\n    .mutation(async ({ input, ctx }) => {\n      // Additional validation in the procedure\n      if (input.published && !ctx.user?.canPublish) {\n        throw new TRPCError({\n          code: 'FORBIDDEN',\n          message: 'You do not have permission to publish posts'\n        });\n      }\n\n      return await db.post.create({\n        data: {\n          ...input,\n          authorId: ctx.user.id\n        }\n      });\n    }),\n});\n```\n\n## Output Transformation\n\n### Basic Output Shaping\n\n```typescript title=\"server/routers/users.ts\"\nexport const usersRouter = t.router({\n  profile: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      const user = await db.user.findUnique({\n        where: { id: input },\n        include: {\n          posts: {\n            select: { id: true, title: true, createdAt: true },\n            orderBy: { createdAt: 'desc' },\n            take: 5\n          },\n          _count: {\n            select: {\n              posts: true,\n              followers: true,\n              following: true\n            }\n          }\n        }\n      });\n\n      if (!user) {\n        throw new TRPCError({ code: 'NOT_FOUND' });\n      }\n\n      // Transform output\n      return {\n        id: user.id,\n        name: user.name,\n        bio: user.bio,\n        avatar: user.avatar,\n        joinedAt: user.createdAt,\n        stats: {\n          posts: user._count.posts,\n          followers: user._count.followers,\n          following: user._count.following\n        },\n        recentPosts: user.posts\n      };\n    }),\n});\n```\n\n### Conditional Fields\n\n```typescript title=\"server/routers/posts.ts\"\nexport const postsRouter = t.router({\n  byId: t.procedure\n    .input(z.object({\n      id: z.string(),\n      includeComments: z.boolean().default(false),\n      includeAnalytics: z.boolean().default(false),\n    }))\n    .query(async ({ input, ctx }) => {\n      const { id, includeComments, includeAnalytics } = input;\n\n      const post = await db.post.findUnique({\n        where: { id },\n        include: {\n          author: true,\n          comments: includeComments ? {\n            include: { author: true },\n            orderBy: { createdAt: 'desc' }\n          } : false,\n          // Only include analytics for post author\n          analytics: includeAnalytics && ctx.user?.id === post?.authorId\n        }\n      });\n\n      if (!post) {\n        throw new TRPCError({ code: 'NOT_FOUND' });\n      }\n\n      return post;\n    }),\n});\n```\n\n## Error Handling\n\n### Custom Error Types\n\n```typescript title=\"server/errors.ts\"\nimport { TRPCError } from '@trpc/server';\n\nexport class ValidationError extends TRPCError {\n  constructor(message: string, field?: string) {\n    super({\n      code: 'BAD_REQUEST',\n      message,\n      cause: { field }\n    });\n  }\n}\n\nexport class NotFoundError extends TRPCError {\n  constructor(resource: string, id?: string) {\n    super({\n      code: 'NOT_FOUND',\n      message: `${resource} not found`,\n      cause: { resource, id }\n    });\n  }\n}\n\nexport class ForbiddenError extends TRPCError {\n  constructor(action: string) {\n    super({\n      code: 'FORBIDDEN',\n      message: `You are not allowed to ${action}`,\n      cause: { action }\n    });\n  }\n}\n```\n\n### Error Handling in Procedures\n\n```typescript title=\"server/routers/posts.ts\"\nexport const postsRouter = t.router({\n  update: t.procedure\n    .input(updatePostSchema)\n    .mutation(async ({ input, ctx }) => {\n      try {\n        const { id, ...updateData } = input;\n\n        // Check if post exists\n        const existingPost = await db.post.findUnique({\n          where: { id },\n          select: { authorId: true, published: true }\n        });\n\n        if (!existingPost) {\n          throw new NotFoundError('Post', id);\n        }\n\n        // Check ownership\n        if (existingPost.authorId !== ctx.user?.id) {\n          throw new ForbiddenError('edit this post');\n        }\n\n        // Validate business rules\n        if (existingPost.published && updateData.published === false) {\n          throw new ValidationError(\n            'Cannot unpublish a published post',\n            'published'\n          );\n        }\n\n        return await db.post.update({\n          where: { id },\n          data: updateData,\n          include: { author: true }\n        });\n\n      } catch (error) {\n        // Log error for debugging\n        console.error('Post update failed:', error);\n\n        // Re-throw tRPC errors\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n\n        // Handle unexpected errors\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'An unexpected error occurred',\n          cause: error\n        });\n      }\n    }),\n});\n```\n\n## Best Practices\n\n<Accordions>\n<Accordion id='input-validation' title=\"Input Validation\">\n\n- Always validate inputs with Zod schemas\n- Use descriptive error messages\n- Validate business rules in procedures\n- Consider rate limiting for expensive operations\n\n```typescript\n// Good: Comprehensive validation\nconst schema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  confirmPassword: z.string()\n}).refine(data => data.password === data.confirmPassword, {\n  message: 'Passwords must match',\n  path: ['confirmPassword']\n});\n```\n\n</Accordion>\n\n<Accordion id='error-handling' title=\"Error Handling\">\n\n- Use specific error codes for different scenarios\n- Provide helpful error messages\n- Log errors appropriately\n- Handle both expected and unexpected errors\n\n```typescript\n// Good: Specific error handling\nif (!user) {\n  throw new TRPCError({\n    code: 'NOT_FOUND',\n    message: 'User not found'\n  });\n}\n\nif (user.id !== ctx.user?.id) {\n  throw new TRPCError({\n    code: 'FORBIDDEN',\n    message: 'You can only edit your own profile'\n  });\n}\n```\n\n</Accordion>\n\n<Accordion id='performance' title=\"Performance\">\n\n- Use database indexes for frequently queried fields\n- Implement pagination for large datasets\n- Consider caching for expensive operations\n- Use database transactions for related operations\n\n```typescript\n// Good: Efficient querying with pagination\nconst posts = await db.post.findMany({\n  take: input.limit,\n  skip: input.offset,\n  orderBy: { createdAt: 'desc' },\n  include: {\n    author: {\n      select: { id: true, name: true, avatar: true }\n    }\n  }\n});\n```\n\n</Accordion>\n</Accordions>\n\n---\n\nProcedures are the foundation of your tRPC API. With proper input validation, error handling, and type safety, they provide a robust foundation for building reliable applications.\n"}, {"info":{"path":"framework/quickstart.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/quickstart.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Quickstart Guide","description":"Set up your first tRPC API with React Query in 5 minutes","icon":"IconRocket","index":false},"content":"\nGet up and running with tRPC and TanStack React Query in just a few minutes. This guide will walk you through creating a simple but complete tRPC application.\n\n## Prerequisites\n\nBefore you start, make sure you have:\n\n- **Node.js 18+** installed\n- **TypeScript 5.7.2+** knowledge\n- **React 18+** for the frontend\n- A new or existing TypeScript project\n\n## 1. Installation\n\nInstall the required packages:\n\n<Tabs groupId='package-manager' persist items={['npm', 'pnpm', 'yarn', 'bun']} label='Install Dependencies'>\n```bash tab=\"npm\"\nnpm install @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query zod\n```\n\n```bash tab=\"pnpm\"\npnpm add @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query zod\n```\n\n```bash tab=\"yarn\"\nyarn add @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query zod\n```\n\n```bash tab=\"bun\"\nbun add @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query zod\n```\n\n</Tabs>\n\n## 2. Create Your tRPC Server\n\nFirst, let's create a simple tRPC server with some example procedures:\n\n```typescript title=\"server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\n// Initialize tRPC - this is done once per application\nconst t = initTRPC.create();\n\n// Export reusable router and procedure helpers\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n```typescript title=\"server/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Mock database\nconst posts = [\n  { id: '1', title: 'Hello tRPC!', content: 'This is my first tRPC post.' },\n  { id: '2', title: 'TypeScript is awesome', content: 'Type safety everywhere!' },\n];\n\nlet postIdCounter = 3;\n\nexport const appRouter = router({\n  // Query to get all posts\n  getPosts: publicProcedure\n    .query(async () => {\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return posts;\n    }),\n\n  // Query to get a single post by ID\n  getPost: publicProcedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      const post = posts.find(p => p.id === input);\n      if (!post) throw new Error('Post not found');\n      return post;\n    }),\n\n  // Mutation to create a new post\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1, 'Title is required'),\n      content: z.string().min(1, 'Content is required')\n    }))\n    .mutation(async ({ input }) => {\n      const newPost = {\n        id: postIdCounter.toString(),\n        title: input.title,\n        content: input.content,\n      };\n      postIdCounter++;\n      posts.push(newPost);\n      return newPost;\n    }),\n\n  // Mutation to delete a post\n  deletePost: publicProcedure\n    .input(z.string())\n    .mutation(async ({ input }) => {\n      const index = posts.findIndex(p => p.id === input);\n      if (index === -1) throw new Error('Post not found');\n\n      const deletedPost = posts[index];\n      posts.splice(index, 1);\n      return deletedPost;\n    }),\n});\n\n// Export the router type - this is important!\nexport type AppRouter = typeof appRouter;\n```\n\n## 3. Create HTTP Server\n\nNow let's serve our tRPC router over HTTP. Choose your preferred method:\n\n<Tabs items={['Next.js API Routes', 'Express Server', 'Standalone Server']}>\n<Tab value=\"Next.js API Routes\">\nIf you're using Next.js, create an API route:\n\n```typescript title=\"pages/api/trpc/[trpc].ts\"\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { appRouter } from '../../../server/router';\n\n// Export API handler\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: () => ({}), // No context for this example\n});\n```\n\nFor Next.js App Router, create:\n\n```typescript title=\"app/api/trpc/[trpc]/route.ts\"\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '../../../../server/router';\n\nconst handler = (req: Request) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({}),\n  });\n\nexport { handler as GET, handler as POST };\n```\n\n</Tab>\n\n<Tab value=\"Express Server\">\nIf you're using Express:\n\n```typescript title=\"server/server.ts\"\nimport express from 'express';\nimport cors from 'cors';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport { appRouter } from './router';\n\nconst app = express();\nconst port = 3001;\n\n// Enable CORS for your frontend\napp.use(cors({\n  origin: 'http://localhost:3000', // Your frontend URL\n}));\n\n// Create tRPC middleware\napp.use('/api/trpc', createExpressMiddleware({\n  router: appRouter,\n  createContext: () => ({}),\n}));\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});\n```\n\n</Tab>\n\n<Tab value=\"Standalone Server\">\nFor a standalone HTTP server:\n\n```typescript title=\"server/server.ts\"\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './router';\n\nconst server = createHTTPServer({\n  router: appRouter,\n  createContext: () => ({}),\n});\n\nconst port = 3001;\nserver.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});\n```\n\n</Tab>\n</Tabs>\n\n## 4. Set Up the Client\n\nNow let's create the client-side setup with React Query integration:\n\n```typescript title=\"utils/trpc.ts\"\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router'; // Import the router type\n\n// Create tRPC context with full type safety\nexport const { TRPCProvider, useTRPC, useTRPCClient } = createTRPCContext<AppRouter>();\n```\n\n## 5. Configure Your App\n\nWrap your app with the necessary providers:\n\n```typescript title=\"App.tsx\"\nimport React, { useState } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { TRPCProvider } from './utils/trpc';\nimport { PostsList } from './components/PostsList';\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000, // 1 minute\n        retry: 3,\n      },\n      mutations: {\n        retry: 1,\n      },\n    },\n  });\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined;\n\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  } else {\n    // Browser: make a new query client if we don't already have one\n    if (!browserQueryClient) browserQueryClient = makeQueryClient();\n    return browserQueryClient;\n  }\n}\n\nexport default function App() {\n  const queryClient = getQueryClient();\n\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3001/api/trpc', // Your tRPC server URL\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        <div className=\"min-h-screen bg-gray-50 py-8\">\n          <div className=\"max-w-4xl mx-auto px-4\">\n            <h1 className=\"text-3xl font-bold mb-8\">My tRPC Blog</h1>\n            <PostsList />\n          </div>\n        </div>\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n## 6. Use tRPC in Your Components\n\nFinally, let's create components that use our tRPC procedures:\n\n```typescript title=\"components/PostsList.tsx\"\nimport React, { useState } from 'react';\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from '../utils/trpc';\n\nexport function PostsList() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n\n  // Fetch all posts\n  const postsQuery = useQuery(trpc.getPosts.queryOptions());\n\n  // Create post mutation\n  const createPostMutation = useMutation(trpc.createPost.mutationOptions({\n    onSuccess: () => {\n      // Invalidate and refetch posts after creating\n      queryClient.invalidateQueries(trpc.getPosts.queryKey());\n      setTitle('');\n      setContent('');\n    },\n  }));\n\n  // Delete post mutation\n  const deletePostMutation = useMutation(trpc.deletePost.mutationOptions({\n    onSuccess: () => {\n      // Invalidate and refetch posts after deleting\n      queryClient.invalidateQueries(trpc.getPosts.queryKey());\n    },\n  }));\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (title.trim() && content.trim()) {\n      createPostMutation.mutate({ title, content });\n    }\n  };\n\n  if (postsQuery.isLoading) {\n    return (\n      <div className=\"flex justify-center items-center py-8\">\n        <div className=\"text-lg\">Loading posts...</div>\n      </div>\n    );\n  }\n\n  if (postsQuery.error) {\n    return (\n      <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n        Error: {postsQuery.error.message}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-8\">\n      {/* Create Post Form */}\n      <div className=\"bg-white p-6 rounded-lg shadow\">\n        <h2 className=\"text-xl font-semibold mb-4\">Create New Post</h2>\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label htmlFor=\"title\" className=\"block text-sm font-medium mb-1\">\n              Title\n            </label>\n            <input\n              id=\"title\"\n              type=\"text\"\n              value={title}\n              onChange={(e) => setTitle(e.target.value)}\n              className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              placeholder=\"Enter post title...\"\n            />\n          </div>\n          <div>\n            <label htmlFor=\"content\" className=\"block text-sm font-medium mb-1\">\n              Content\n            </label>\n            <textarea\n              id=\"content\"\n              value={content}\n              onChange={(e) => setContent(e.target.value)}\n              className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              rows={4}\n              placeholder=\"Enter post content...\"\n            />\n          </div>\n          <button\n            type=\"submit\"\n            disabled={createPostMutation.isPending || !title.trim() || !content.trim()}\n            className=\"px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed\"\n          >\n            {createPostMutation.isPending ? 'Creating...' : 'Create Post'}\n          </button>\n        </form>\n      </div>\n\n      {/* Posts List */}\n      <div className=\"space-y-4\">\n        <h2 className=\"text-xl font-semibold\">Posts ({postsQuery.data?.length || 0})</h2>\n        {postsQuery.data?.length === 0 ? (\n          <div className=\"text-gray-500 text-center py-8\">\n            No posts yet. Create your first post above!\n          </div>\n        ) : (\n          postsQuery.data?.map((post) => (\n            <div key={post.id} className=\"bg-white p-6 rounded-lg shadow\">\n              <div className=\"flex justify-between items-start\">\n                <div className=\"flex-1\">\n                  <h3 className=\"text-lg font-semibold mb-2\">{post.title}</h3>\n                  <p className=\"text-gray-600\">{post.content}</p>\n                </div>\n                <button\n                  onClick={() => deletePostMutation.mutate(post.id)}\n                  disabled={deletePostMutation.isPending}\n                  className=\"ml-4 px-3 py-1 bg-red-500 text-white text-sm rounded hover:bg-red-600 disabled:bg-gray-300\"\n                >\n                  {deletePostMutation.isPending ? 'Deleting...' : 'Delete'}\n                </button>\n              </div>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n## 7. Run Your Application\n\nStart your development servers:\n\n<Tabs items={['Next.js', 'Separate Frontend/Backend']}>\n<Tab value=\"Next.js\">\nIf everything is in a Next.js app:\n\n```bash\nnpm run dev\n```\n\nYour app will be available at `http://localhost:3000`\n\n</Tab>\n\n<Tab value=\"Separate Frontend/Backend\">\nStart your backend server:\n\n```bash\n# Terminal 1 - Backend\nnpm run server\n# or\nnode server/server.ts\n```\n\nStart your frontend:\n\n```bash\n# Terminal 2 - Frontend\nnpm start\n# or\nnpm run dev\n```\n\n</Tab>\n</Tabs>\n\n## What You've Built\n\nCongratulations! You now have a working tRPC application with:\n\n‚úÖ **Type-safe API** - Full TypeScript coverage from server to client  \n‚úÖ **React Query Integration** - Automatic caching, background refetching, and error handling  \n‚úÖ **Real-time Updates** - Optimistic updates and cache invalidation  \n‚úÖ **Error Handling** - Graceful error states and validation  \n‚úÖ **Developer Experience** - Autocomplete, type checking, and refactoring support\n\n## Next Steps\n\nNow that you have a working tRPC setup, here are some great next steps:\n\n<Cards>\n  <Card\n    href=\"/docs/framework/concepts\"\n    title=\"Learn Core Concepts\"\n    icon={<IconBrain />}\n  >\n    Understand routers, procedures, context, middleware, and error handling\n  </Card>\n  <Card\n    href=\"/docs/framework/best-practices\"\n    title=\"Best Practices\"\n    icon={<IconListCheck />}\n  >\n    Patterns for organizing code, error handling, and scaling your application\n  </Card>\n  <Card\n    href=\"/docs/framework/nextjs\"\n    title=\"Next.js Integration\"\n    icon={<IconBrandNextjs />}\n  >\n    Advanced Next.js patterns with App Router and Server Components\n  </Card>\n  <Card\n    href=\"/docs/framework/react\"\n    title=\"Advanced React Query\"\n    icon={<IconBrandReact />}\n  >\n    Infinite queries, optimistic updates, and advanced caching strategies\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion id='cors-issues' title=\"CORS Issues\">\nIf you're getting CORS errors, make sure to:\n\n1. **Install CORS middleware** for Express/Standalone servers\n2. **Configure allowed origins** to include your frontend URL\n3. **Enable credentials** if you're using authentication\n\n```typescript\napp.use(cors({\n  origin: ['http://localhost:3000', 'http://localhost:3001'],\n  credentials: true,\n}));\n```\n\n</Accordion>\n\n<Accordion id='type-errors' title=\"TypeScript Type Errors\">\nIf you're seeing type errors:\n\n1. **Check TypeScript version** - tRPC requires TypeScript 5.7.2+\n2. **Enable strict mode** in `tsconfig.json`\n3. **Verify router type export** - Make sure you're exporting `AppRouter` type\n4. **Restart TypeScript server** in your IDE\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\n</Accordion>\n\n<Accordion id='network-errors' title=\"Network Connection Issues\">\nIf queries are failing:\n\n1. **Check server URL** in your tRPC client configuration\n2. **Verify server is running** on the correct port\n3. **Check network tab** in browser DevTools for actual error responses\n4. **Test endpoint directly** - Try accessing `/api/trpc/getPosts` in your browser\n   </Accordion>\n</Accordions>\n\n---\n\nYou're now ready to build amazing type-safe applications with tRPC! The combination of end-to-end type safety and React Query's powerful data fetching capabilities will dramatically improve your development experience.\n</rewritten_file>\n"}, {"info":{"path":"framework/routers.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/routers.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Routers","description":"Organize your tRPC API with powerful router composition and nesting","icon":"IconRoute","index":false},"content":"\nRouters are the organizational backbone of your tRPC API. They group related procedures together and enable powerful composition patterns for building scalable, maintainable APIs.\n\n## What are Routers?\n\nA **router** is a collection of procedures grouped together under a common namespace. Think of routers as the chapters in your API book - they organize related functionality and make your API intuitive to navigate.\n\n```typescript\n// Define a router with related procedures\nconst userRouter = t.router({\n  list: t.procedure.query(() => getUsers()),\n  byId: t.procedure.input(z.string()).query(({ input }) => getUserById(input)),\n  create: t.procedure.input(CreateUserSchema).mutation(({ input }) => createUser(input)),\n  update: t.procedure.input(UpdateUserSchema).mutation(({ input }) => updateUser(input)),\n  delete: t.procedure.input(z.string()).mutation(({ input }) => deleteUser(input)),\n});\n\n// Client usage: trpc.user.list.query()\n//              trpc.user.byId.query('123')\n//              trpc.user.create.mutate({...})\n```\n\n## Creating Routers\n\n### Basic Router\n\nStart with a simple router containing related procedures:\n\n```typescript title=\"server/routers/posts.ts\"\nimport { z } from 'zod';\nimport { t } from '../trpc';\nimport { TRPCError } from '@trpc/server';\n\nexport const postsRouter = t.router({\n  // List all posts\n  list: t.procedure\n    .input(z.object({\n      limit: z.number().min(1).max(100).default(10),\n      cursor: z.string().optional(),\n    }))\n    .query(async ({ input }) => {\n      const posts = await db.post.findMany({\n        take: input.limit + 1,\n        cursor: input.cursor ? { id: input.cursor } : undefined,\n        orderBy: { createdAt: 'desc' },\n        include: { author: true }\n      });\n\n      return {\n        posts: posts.slice(0, input.limit),\n        nextCursor: posts.length > input.limit ? posts[input.limit].id : undefined\n      };\n    }),\n\n  // Get single post\n  byId: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      const post = await db.post.findUnique({\n        where: { id: input },\n        include: { author: true, comments: true }\n      });\n\n      if (!post) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found'\n        });\n      }\n\n      return post;\n    }),\n\n  // Create new post\n  create: t.procedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n      tags: z.array(z.string()).default([])\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await db.post.create({\n        data: {\n          ...input,\n          authorId: ctx.user.id\n        }\n      });\n    }),\n});\n```\n\n### Domain-Specific Routers\n\nOrganize routers by business domain:\n\n```typescript title=\"server/routers/users.ts\"\nexport const usersRouter = t.router({\n  profile: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      return await db.user.findUnique({\n        where: { id: input },\n        include: { posts: true, followers: true }\n      });\n    }),\n\n  updateProfile: protectedProcedure\n    .input(z.object({\n      name: z.string().optional(),\n      bio: z.string().optional(),\n      avatar: z.string().url().optional()\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await db.user.update({\n        where: { id: ctx.user.id },\n        data: input\n      });\n    }),\n\n  follow: protectedProcedure\n    .input(z.string())\n    .mutation(async ({ input: targetUserId, ctx }) => {\n      return await db.follow.create({\n        data: {\n          followerId: ctx.user.id,\n          followingId: targetUserId\n        }\n      });\n    }),\n\n  unfollow: protectedProcedure\n    .input(z.string())\n    .mutation(async ({ input: targetUserId, ctx }) => {\n      return await db.follow.delete({\n        where: {\n          followerId_followingId: {\n            followerId: ctx.user.id,\n            followingId: targetUserId\n          }\n        }\n      });\n    }),\n});\n```\n\n## Router Composition\n\n### Nested Routers\n\nCreate hierarchical API structures with nested routers:\n\n```typescript title=\"server/routers/blog.ts\"\n// Content management router\nconst contentRouter = t.router({\n  posts: postsRouter,\n\n  comments: t.router({\n    byPost: t.procedure\n      .input(z.string())\n      .query(async ({ input }) => {\n        return await db.comment.findMany({\n          where: { postId: input },\n          include: { author: true },\n          orderBy: { createdAt: 'desc' }\n        });\n      }),\n\n    create: protectedProcedure\n      .input(z.object({\n        postId: z.string(),\n        content: z.string().min(1)\n      }))\n      .mutation(async ({ input, ctx }) => {\n        return await db.comment.create({\n          data: {\n            ...input,\n            authorId: ctx.user.id\n          }\n        });\n      }),\n\n    update: protectedProcedure\n      .input(z.object({\n        id: z.string(),\n        content: z.string().min(1)\n      }))\n      .mutation(async ({ input, ctx }) => {\n        // Check ownership\n        const comment = await db.comment.findUnique({\n          where: { id: input.id },\n          select: { authorId: true }\n        });\n\n        if (comment?.authorId !== ctx.user.id) {\n          throw new TRPCError({ code: 'FORBIDDEN' });\n        }\n\n        return await db.comment.update({\n          where: { id: input.id },\n          data: { content: input.content }\n        });\n      }),\n  }),\n\n  categories: t.router({\n    list: t.procedure\n      .query(async () => {\n        return await db.category.findMany({\n          include: { _count: { select: { posts: true } } }\n        });\n      }),\n\n    bySlug: t.procedure\n      .input(z.string())\n      .query(async ({ input }) => {\n        return await db.category.findUnique({\n          where: { slug: input },\n          include: { posts: true }\n        });\n      }),\n  }),\n});\n\n// Client usage:\n// trpc.content.posts.list.query()\n// trpc.content.comments.byPost.query('post-id')\n// trpc.content.categories.list.query()\n```\n\n### Router Merging\n\nCombine multiple routers into a single router:\n\n```typescript title=\"server/routers/_app.ts\"\nimport { t } from '../trpc';\nimport { authRouter } from './auth';\nimport { usersRouter } from './users';\nimport { postsRouter } from './posts';\nimport { adminRouter } from './admin';\n\nexport const appRouter = t.router({\n  // Direct router inclusion\n  auth: authRouter,\n  users: usersRouter,\n  posts: postsRouter,\n\n  // Nested organization\n  admin: adminRouter,\n\n  // Mixed approaches\n  content: t.router({\n    posts: postsRouter,\n    media: mediaRouter,\n  }),\n\n  // Direct procedures\n  health: t.procedure\n    .query(() => ({ status: 'ok', timestamp: new Date() })),\n\n  version: t.procedure\n    .query(() => ({ version: process.env.API_VERSION || '1.0.0' })),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n## Advanced Router Patterns\n\n### Conditional Routers\n\nInclude routers based on environment or features:\n\n```typescript title=\"server/routers/_app.ts\"\nconst baseRouter = t.router({\n  auth: authRouter,\n  users: usersRouter,\n  posts: postsRouter,\n});\n\nconst developmentRouter = t.router({\n  ...baseRouter,\n  // Development-only routes\n  dev: t.router({\n    seedDatabase: t.procedure\n      .mutation(async () => {\n        if (process.env.NODE_ENV !== 'development') {\n          throw new TRPCError({ code: 'FORBIDDEN' });\n        }\n        await seedDatabase();\n        return { success: true };\n      }),\n\n    resetDatabase: t.procedure\n      .mutation(async () => {\n        if (process.env.NODE_ENV !== 'development') {\n          throw new TRPCError({ code: 'FORBIDDEN' });\n        }\n        await resetDatabase();\n        return { success: true };\n      }),\n  }),\n});\n\nexport const appRouter = process.env.NODE_ENV === 'development'\n  ? developmentRouter\n  : baseRouter;\n```\n\n### Feature-Based Organization\n\nOrganize routers by features rather than entities:\n\n```typescript title=\"server/routers/features.ts\"\n// Authentication & Authorization\nconst authFeatureRouter = t.router({\n  login: publicProcedure.input(LoginSchema).mutation(login),\n  logout: protectedProcedure.mutation(logout),\n  register: publicProcedure.input(RegisterSchema).mutation(register),\n  resetPassword: publicProcedure.input(z.string().email()).mutation(resetPassword),\n  changePassword: protectedProcedure.input(ChangePasswordSchema).mutation(changePassword),\n});\n\n// Social Features\nconst socialFeatureRouter = t.router({\n  follow: protectedProcedure.input(z.string()).mutation(followUser),\n  unfollow: protectedProcedure.input(z.string()).mutation(unfollowUser),\n  getFollowers: t.procedure.input(z.string()).query(getFollowers),\n  getFollowing: t.procedure.input(z.string()).query(getFollowing),\n  searchUsers: t.procedure.input(z.string()).query(searchUsers),\n});\n\n// Content Management\nconst contentFeatureRouter = t.router({\n  createPost: protectedProcedure.input(CreatePostSchema).mutation(createPost),\n  editPost: protectedProcedure.input(EditPostSchema).mutation(editPost),\n  deletePost: protectedProcedure.input(z.string()).mutation(deletePost),\n  likePost: protectedProcedure.input(z.string()).mutation(likePost),\n  sharePost: protectedProcedure.input(z.string()).mutation(sharePost),\n});\n\nexport const appRouter = t.router({\n  auth: authFeatureRouter,\n  social: socialFeatureRouter,\n  content: contentFeatureRouter,\n});\n```\n\n### Router Middleware\n\nApply middleware to entire routers:\n\n```typescript title=\"server/routers/admin.ts\"\n// Admin-only router with middleware\nconst adminProcedure = t.procedure.use(requireAdminRole);\n\nexport const adminRouter = t.router({\n  users: t.router({\n    list: adminProcedure\n      .query(async () => {\n        return await db.user.findMany({\n          include: { _count: { select: { posts: true } } }\n        });\n      }),\n\n    ban: adminProcedure\n      .input(z.string())\n      .mutation(async ({ input }) => {\n        return await db.user.update({\n          where: { id: input },\n          data: { status: 'banned' }\n        });\n      }),\n\n    unban: adminProcedure\n      .input(z.string())\n      .mutation(async ({ input }) => {\n        return await db.user.update({\n          where: { id: input },\n          data: { status: 'active' }\n        });\n      }),\n  }),\n\n  posts: t.router({\n    flagged: adminProcedure\n      .query(async () => {\n        return await db.post.findMany({\n          where: { flagged: true },\n          include: { author: true, reports: true }\n        });\n      }),\n\n    moderate: adminProcedure\n      .input(z.object({\n        postId: z.string(),\n        action: z.enum(['approve', 'remove', 'flag'])\n      }))\n      .mutation(async ({ input }) => {\n        return await moderatePost(input.postId, input.action);\n      }),\n  }),\n\n  analytics: t.router({\n    overview: adminProcedure\n      .query(async () => {\n        return await getAnalyticsOverview();\n      }),\n\n    userGrowth: adminProcedure\n      .input(z.object({\n        startDate: z.date(),\n        endDate: z.date()\n      }))\n      .query(async ({ input }) => {\n        return await getUserGrowthData(input.startDate, input.endDate);\n      }),\n  }),\n});\n```\n\n## Router Composition Patterns\n\n### Modular Architecture\n\nBreak large applications into focused modules:\n\n```typescript title=\"server/modules/blog/router.ts\"\n// Blog module router\nexport const blogModuleRouter = t.router({\n  posts: t.router({\n    list: t.procedure.query(listPosts),\n    create: protectedProcedure.input(CreatePostSchema).mutation(createPost),\n    // ... other post procedures\n  }),\n\n  categories: t.router({\n    list: t.procedure.query(listCategories),\n    create: adminProcedure.input(CreateCategorySchema).mutation(createCategory),\n    // ... other category procedures\n  }),\n\n  tags: t.router({\n    list: t.procedure.query(listTags),\n    trending: t.procedure.query(getTrendingTags),\n    // ... other tag procedures\n  }),\n});\n```\n\n```typescript title=\"server/modules/ecommerce/router.ts\"\n// E-commerce module router\nexport const ecommerceModuleRouter = t.router({\n  products: t.router({\n    list: t.procedure.input(ProductFiltersSchema).query(listProducts),\n    byId: t.procedure.input(z.string()).query(getProduct),\n    create: adminProcedure.input(CreateProductSchema).mutation(createProduct),\n    // ... other product procedures\n  }),\n\n  cart: t.router({\n    get: protectedProcedure.query(getCart),\n    add: protectedProcedure.input(AddToCartSchema).mutation(addToCart),\n    remove: protectedProcedure.input(z.string()).mutation(removeFromCart),\n    // ... other cart procedures\n  }),\n\n  orders: t.router({\n    list: protectedProcedure.query(getUserOrders),\n    create: protectedProcedure.input(CreateOrderSchema).mutation(createOrder),\n    // ... other order procedures\n  }),\n});\n```\n\n```typescript title=\"server/routers/_app.ts\"\n// Main app router combining modules\nexport const appRouter = t.router({\n  // Core functionality\n  auth: authRouter,\n  users: usersRouter,\n\n  // Feature modules\n  blog: blogModuleRouter,\n  shop: ecommerceModuleRouter,\n\n  // Utility endpoints\n  health: t.procedure.query(() => ({ status: 'ok' })),\n  meta: t.router({\n    version: t.procedure.query(() => ({ version: '1.0.0' })),\n    features: t.procedure.query(() => getEnabledFeatures()),\n  }),\n});\n```\n\n### Shared Router Utilities\n\nCreate reusable router utilities:\n\n```typescript title=\"server/utils/crud-router.ts\"\n// Generic CRUD router factory\nexport function createCrudRouter<T extends { id: string }>(\n  entity: string,\n  schema: {\n    create: z.ZodSchema;\n    update: z.ZodSchema;\n    filter?: z.ZodSchema;\n  },\n  operations: {\n    list: (filters?: any) => Promise<T[]>;\n    byId: (id: string) => Promise<T | null>;\n    create: (data: any) => Promise<T>;\n    update: (id: string, data: any) => Promise<T>;\n    delete: (id: string) => Promise<void>;\n  }\n) {\n  return t.router({\n    list: t.procedure\n      .input(schema.filter || z.object({}))\n      .query(async ({ input }) => {\n        return await operations.list(input);\n      }),\n\n    byId: t.procedure\n      .input(z.string())\n      .query(async ({ input }) => {\n        const item = await operations.byId(input);\n        if (!item) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `${entity} not found`\n          });\n        }\n        return item;\n      }),\n\n    create: protectedProcedure\n      .input(schema.create)\n      .mutation(async ({ input }) => {\n        return await operations.create(input);\n      }),\n\n    update: protectedProcedure\n      .input(schema.update.extend({ id: z.string() }))\n      .mutation(async ({ input }) => {\n        const { id, ...data } = input;\n        return await operations.update(id, data);\n      }),\n\n    delete: protectedProcedure\n      .input(z.string())\n      .mutation(async ({ input }) => {\n        await operations.delete(input);\n        return { success: true };\n      }),\n  });\n}\n\n// Usage\nexport const productsRouter = createCrudRouter(\n  'Product',\n  {\n    create: CreateProductSchema,\n    update: UpdateProductSchema,\n    filter: ProductFiltersSchema,\n  },\n  {\n    list: listProducts,\n    byId: getProductById,\n    create: createProduct,\n    update: updateProduct,\n    delete: deleteProduct,\n  }\n);\n```\n\n## Client-Side Router Usage\n\n### Type-Safe Router Calls\n\n```tsx title=\"components/blog.tsx\"\nimport { useTRPC } from '../lib/trpc';\n\nexport function BlogComponent() {\n  const trpc = useTRPC();\n\n  // Nested router calls - fully typed\n  const postsQuery = useQuery(trpc.content.posts.list.queryOptions());\n  const categoriesQuery = useQuery(trpc.content.categories.list.queryOptions());\n\n  // Complex nested calls\n  const postCommentsQuery = useQuery(\n    trpc.content.comments.byPost.queryOptions('post-123')\n  );\n\n  // Mutations on nested routes\n  const createCommentMutation = useMutation(\n    trpc.content.comments.create.mutationOptions()\n  );\n\n  return (\n    <div>\n      {/* Component implementation */}\n    </div>\n  );\n}\n```\n\n### Dynamic Router Access\n\n```tsx title=\"hooks/use-admin.tsx\"\nimport { useTRPC } from '../lib/trpc';\n\nexport function useAdminActions() {\n  const trpc = useTRPC();\n\n  return {\n    // User management\n    getUsers: () => trpc.admin.users.list.query(),\n    banUser: (userId: string) => trpc.admin.users.ban.mutate(userId),\n    unbanUser: (userId: string) => trpc.admin.users.unban.mutate(userId),\n\n    // Content moderation\n    getFlaggedPosts: () => trpc.admin.posts.flagged.query(),\n    moderatePost: (postId: string, action: 'approve' | 'remove' | 'flag') =>\n      trpc.admin.posts.moderate.mutate({ postId, action }),\n\n    // Analytics\n    getOverview: () => trpc.admin.analytics.overview.query(),\n    getUserGrowth: (startDate: Date, endDate: Date) =>\n      trpc.admin.analytics.userGrowth.query({ startDate, endDate }),\n  };\n}\n```\n\n## Best Practices\n\n<Accordions>\n<Accordion id='organization' title=\"Router Organization\">\n\n- **Group by domain**: Organize routers around business domains (users, posts, orders)\n- **Consistent naming**: Use clear, consistent naming conventions across routers\n- **Logical nesting**: Create intuitive hierarchies that match your app structure\n- **Single responsibility**: Each router should have a focused purpose\n\n```typescript\n// Good: Domain-based organization\nexport const appRouter = t.router({\n  auth: authRouter,      // Authentication\n  users: usersRouter,    // User management\n  posts: postsRouter,    // Content management\n  admin: adminRouter,    // Administrative functions\n});\n```\n\n</Accordion>\n\n<Accordion id='composition' title=\"Router Composition\">\n\n- **Modular design**: Break large routers into smaller, focused modules\n- **Reusable patterns**: Create router factories for common patterns (CRUD operations)\n- **Middleware composition**: Apply middleware at the router level for common functionality\n- **Environment separation**: Use different routers for different environments\n\n```typescript\n// Good: Modular composition\nconst appRouter = t.router({\n  // Core features\n  ...coreRouter,\n\n  // Optional modules\n  ...(FEATURES.BLOG && { blog: blogRouter }),\n  ...(FEATURES.SHOP && { shop: shopRouter }),\n\n  // Environment-specific\n  ...(IS_DEV && { dev: devRouter }),\n});\n```\n\n</Accordion>\n\n<Accordion id='type-safety' title=\"Type Safety\">\n\n- **Export router types**: Always export your router type for client usage\n- **Consistent interfaces**: Use consistent patterns across similar routers\n- **Validation**: Apply input validation consistently across all procedures\n- **Error handling**: Implement consistent error handling patterns\n\n```typescript\n// Good: Type safety patterns\nexport const appRouter = t.router({\n  users: usersRouter,\n  posts: postsRouter,\n});\n\n// Export the type, not the implementation\nexport type AppRouter = typeof appRouter;\n```\n\n</Accordion>\n</Accordions>\n\n---\n\nRouters provide the organizational structure for your tRPC API. With proper composition and nesting, they enable you to build scalable, maintainable APIs that grow with your application.\n"}, {"info":{"path":"framework/tanstack-react-query.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/tanstack-react-query.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"TanStack React Query Integration","description":"Master tRPC with TanStack React Query for powerful data fetching","icon":"IconBrandReact","index":false},"content":"\nLearn how to use tRPC with TanStack React Query for the ultimate data fetching experience. This integration provides powerful caching, background synchronization, optimistic updates, and more.\n\n## Why TanStack React Query?\n\nThe `@trpc/tanstack-react-query` integration is the **recommended** way to use tRPC in React applications:\n\n<Cards>\n  <Card icon={<IconCache />} title=\"Intelligent Caching\">\n    Automatic caching with smart invalidation and background refetching\n  </Card>\n\n<Card icon={<IconRefresh />} title=\"Background Sync\">\n  Keep data fresh with automatic background updates and refetch strategies\n</Card>\n\n<Card icon={<IconZap />} title=\"Optimistic Updates\">\n  Update UI immediately while mutations are in flight, with automatic rollback\n  on errors\n</Card>\n\n  <Card icon={<IconStack />} title=\"Request Deduplication\">\n    Identical requests are automatically merged to reduce network traffic\n  </Card>\n</Cards>\n\n## Installation\n\nInstall the required packages:\n\n<Tabs groupId='package-manager' persist items={['npm', 'pnpm', 'yarn', 'bun']}>\n\n```bash tab=\"npm\"\nnpm install @trpc/tanstack-react-query @tanstack/react-query\n```\n\n```bash tab=\"pnpm\"\npnpm add @trpc/tanstack-react-query @tanstack/react-query\n```\n\n```bash tab=\"yarn\"\nyarn add @trpc/tanstack-react-query @tanstack/react-query\n```\n\n```bash tab=\"bun\"\nbun add @trpc/tanstack-react-query @tanstack/react-query\n```\n\n</Tabs>\n\n## Setup\n\n### 1. Create Query Client\n\nSet up a shared query client with optimal defaults:\n\n```typescript title=\"lib/query-client.ts\"\nimport { QueryClient } from '@tanstack/react-query';\n\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000, // 1 minute\n        gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)\n        retry: (failureCount, error) => {\n          // Don't retry on 4xx errors\n          if (error.data?.httpStatus >= 400 && error.data?.httpStatus < 500) {\n            return false;\n          }\n          return failureCount < 3;\n        },\n      },\n      mutations: {\n        retry: 1,\n      },\n    },\n  });\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined;\n\nexport function getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  } else {\n    // Browser: make a new query client if we don't already have one\n    if (!browserQueryClient) browserQueryClient = makeQueryClient();\n    return browserQueryClient;\n  }\n}\n```\n\n### 2. Create tRPC Context\n\nSet up the tRPC React context:\n\n```typescript title=\"lib/trpc-react.ts\"\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n\n// Create the tRPC React context\nexport const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();\n```\n\n### 3. Configure Provider\n\nWrap your app with the necessary providers:\n\n```tsx title=\"app/providers.tsx\"\n'use client';\n\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { getQueryClient } from './lib/query-client';\nimport { TRPCProvider } from './lib/trpc-react';\nimport type { AppRouter } from './server/router';\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  const queryClient = getQueryClient();\n\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: '/api/trpc',\n          // Optional: Add headers, credentials, etc.\n          headers() {\n            return {\n              // Add auth headers, etc.\n            };\n          },\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider client={trpcClient} queryClient={queryClient}>\n        {children}\n        <ReactQueryDevtools initialIsOpen={false} />\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n## Basic Usage\n\n### Queries\n\nUse `useQuery` with tRPC query options for type-safe data fetching:\n\n```tsx title=\"components/posts-list.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function PostsList() {\n  const trpc = useTRPC();\n\n  // Basic query\n  const postsQuery = useQuery(trpc.posts.list.queryOptions());\n\n  // Query with input\n  const userQuery = useQuery(trpc.users.byId.queryOptions('user_123'));\n\n  // Query with React Query options\n  const popularPostsQuery = useQuery(trpc.posts.popular.queryOptions(), {\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n\n  if (postsQuery.isLoading) return <div>Loading posts...</div>;\n  if (postsQuery.error) return <div>Error: {postsQuery.error.message}</div>;\n\n  return (\n    <div>\n      {postsQuery.data?.map((post) => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </article>\n      ))}\n    </div>\n  );\n}\n```\n\n### Mutations\n\nUse `useMutation` with tRPC mutation options:\n\n```tsx title=\"components/create-post.tsx\"\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useState } from 'react';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function CreatePost() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n\n  const createPostMutation = useMutation(trpc.posts.create.mutationOptions({\n    onSuccess: (newPost) => {\n      // Invalidate and refetch posts list\n      queryClient.invalidateQueries(trpc.posts.list.queryKey());\n\n      // Optionally add the new post to the cache immediately\n      queryClient.setQueryData(\n        trpc.posts.byId.queryKey(newPost.id),\n        newPost\n      );\n\n      // Reset form\n      setTitle('');\n      setContent('');\n    },\n    onError: (error) => {\n      console.error('Failed to create post:', error);\n    },\n  }));\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    createPostMutation.mutate({ title, content });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n        placeholder=\"Post title\"\n        required\n      />\n      <textarea\n        value={content}\n        onChange={(e) => setContent(e.target.value)}\n        placeholder=\"Post content\"\n        required\n      />\n      <button type=\"submit\" disabled={createPostMutation.isPending}>\n        {createPostMutation.isPending ? 'Creating...' : 'Create Post'}\n      </button>\n    </form>\n  );\n}\n```\n\n## Advanced Patterns\n\n### Infinite Queries\n\nPerfect for pagination and infinite scrolling:\n\n```tsx title=\"components/infinite-posts.tsx\"\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function InfinitePosts() {\n  const trpc = useTRPC();\n\n  const infinitePostsQuery = useInfiniteQuery(\n    trpc.posts.infinite.infiniteQueryOptions({\n      limit: 10,\n    }, {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n      getPreviousPageParam: (firstPage) => firstPage.prevCursor,\n    })\n  );\n\n  const loadMore = () => {\n    if (infinitePostsQuery.hasNextPage && !infinitePostsQuery.isFetchingNextPage) {\n      infinitePostsQuery.fetchNextPage();\n    }\n  };\n\n  return (\n    <div>\n      {infinitePostsQuery.data?.pages.map((page, pageIndex) => (\n        <div key={pageIndex}>\n          {page.posts.map((post) => (\n            <article key={post.id}>\n              <h3>{post.title}</h3>\n              <p>{post.excerpt}</p>\n            </article>\n          ))}\n        </div>\n      ))}\n\n      <button\n        onClick={loadMore}\n        disabled={!infinitePostsQuery.hasNextPage || infinitePostsQuery.isFetchingNextPage}\n      >\n        {infinitePostsQuery.isFetchingNextPage\n          ? 'Loading more...'\n          : infinitePostsQuery.hasNextPage\n          ? 'Load More'\n          : 'No more posts'}\n      </button>\n    </div>\n  );\n}\n```\n\n### Optimistic Updates\n\nUpdate the UI immediately while mutations are in flight:\n\n```tsx title=\"components/optimistic-updates.tsx\"\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function LikeButton({ postId }: { postId: string }) {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n\n  const likeMutation = useMutation(trpc.posts.like.mutationOptions({\n    onMutate: async (variables) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries(trpc.posts.byId.queryKey(postId));\n\n      // Snapshot the previous value\n      const previousPost = queryClient.getQueryData(trpc.posts.byId.queryKey(postId));\n\n      // Optimistically update to the new value\n      queryClient.setQueryData(trpc.posts.byId.queryKey(postId), (old) => {\n        if (!old) return old;\n        return {\n          ...old,\n          likes: old.likes + 1,\n          isLiked: true,\n        };\n      });\n\n      // Return context with snapshot\n      return { previousPost };\n    },\n    onError: (err, variables, context) => {\n      // Rollback to previous value on error\n      if (context?.previousPost) {\n        queryClient.setQueryData(\n          trpc.posts.byId.queryKey(postId),\n          context.previousPost\n        );\n      }\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries(trpc.posts.byId.queryKey(postId));\n    },\n  }));\n\n  return (\n    <button\n      onClick={() => likeMutation.mutate({ postId })}\n      disabled={likeMutation.isPending}\n    >\n      ‚ù§Ô∏è Like {likeMutation.isPending && '(saving...)'}\n    </button>\n  );\n}\n```\n\n### Dependent Queries\n\nChain queries that depend on each other:\n\n```tsx title=\"components/dependent-queries.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function UserWithPosts({ userId }: { userId: string }) {\n  const trpc = useTRPC();\n\n  // First query: get user\n  const userQuery = useQuery(trpc.users.byId.queryOptions(userId));\n\n  // Second query: get user's posts (depends on user existing)\n  const userPostsQuery = useQuery(\n    trpc.posts.byUserId.queryOptions(userId),\n    {\n      enabled: !!userQuery.data, // Only run if user exists\n    }\n  );\n\n  if (userQuery.isLoading) return <div>Loading user...</div>;\n  if (userQuery.error) return <div>User not found</div>;\n\n  return (\n    <div>\n      <h1>{userQuery.data.name}</h1>\n      <p>{userQuery.data.bio}</p>\n\n      {userPostsQuery.isLoading ? (\n        <div>Loading posts...</div>\n      ) : (\n        <div>\n          <h2>Posts by {userQuery.data.name}</h2>\n          {userPostsQuery.data?.map((post) => (\n            <article key={post.id}>\n              <h3>{post.title}</h3>\n            </article>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n### Background Synchronization\n\nKeep data fresh with intelligent refetching:\n\n```tsx title=\"components/live-data.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function LiveDashboard() {\n  const trpc = useTRPC();\n\n  // Refetch every 30 seconds when window is focused\n  const metricsQuery = useQuery(trpc.analytics.metrics.queryOptions(), {\n    refetchInterval: 30 * 1000,\n    refetchIntervalInBackground: false,\n    refetchOnWindowFocus: true,\n    staleTime: 20 * 1000, // Consider data stale after 20 seconds\n  });\n\n  // Real-time notifications (refetch on mount and window focus)\n  const notificationsQuery = useQuery(trpc.notifications.unread.queryOptions(), {\n    refetchOnMount: 'always',\n    refetchOnWindowFocus: 'always',\n    staleTime: 0, // Always considered stale\n  });\n\n  return (\n    <div>\n      <div>\n        <h2>Metrics</h2>\n        {metricsQuery.data && (\n          <div>\n            <p>Users: {metricsQuery.data.userCount}</p>\n            <p>Posts: {metricsQuery.data.postCount}</p>\n            <p>Last updated: {new Date(metricsQuery.dataUpdatedAt).toLocaleTimeString()}</p>\n          </div>\n        )}\n      </div>\n\n      <div>\n        <h2>Notifications</h2>\n        {notificationsQuery.data?.length > 0 && (\n          <div>You have {notificationsQuery.data.length} unread notifications</div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n## Error Handling\n\n### Global Error Handling\n\nSet up global error handling in your Query Client:\n\n```typescript title=\"lib/query-client.ts\"\nimport { QueryClient } from '@tanstack/react-query';\nimport { toast } from 'react-hot-toast';\n\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: (failureCount, error) => {\n          // Don't retry on client errors\n          if (error.data?.httpStatus >= 400 && error.data?.httpStatus < 500) {\n            return false;\n          }\n          return failureCount < 3;\n        },\n      },\n      mutations: {\n        onError: (error) => {\n          // Global error handling for mutations\n          if (error.data?.code === 'UNAUTHORIZED') {\n            // Redirect to login\n            window.location.href = '/login';\n          } else {\n            toast.error(error.message || 'Something went wrong');\n          }\n        },\n      },\n    },\n  });\n}\n```\n\n### Component-Level Error Handling\n\nHandle errors gracefully in components:\n\n```tsx title=\"components/error-handling.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function PostWithErrorHandling({ postId }: { postId: string }) {\n  const trpc = useTRPC();\n\n  const postQuery = useQuery(trpc.posts.byId.queryOptions(postId), {\n    throwOnError: false, // Don't throw to error boundary\n    retry: (failureCount, error) => {\n      // Custom retry logic\n      if (error.data?.code === 'NOT_FOUND') {\n        return false; // Don't retry on 404\n      }\n      return failureCount < 2;\n    },\n  });\n\n  if (postQuery.isLoading) {\n    return <div>Loading post...</div>;\n  }\n\n  if (postQuery.error) {\n    if (postQuery.error.data?.code === 'NOT_FOUND') {\n      return <div>Post not found</div>;\n    }\n    if (postQuery.error.data?.code === 'UNAUTHORIZED') {\n      return <div>You need to log in to view this post</div>;\n    }\n    return (\n      <div>\n        <p>Failed to load post: {postQuery.error.message}</p>\n        <button onClick={() => postQuery.refetch()}>\n          Try Again\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <article>\n      <h1>{postQuery.data.title}</h1>\n      <p>{postQuery.data.content}</p>\n    </article>\n  );\n}\n```\n\n## Performance Optimization\n\n### Query Key Management\n\nEfficiently manage cache invalidation:\n\n```typescript title=\"lib/query-keys.ts\"\nimport { useTRPC } from './trpc-react';\n\nexport function useInvalidateQueries() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n\n  return {\n    // Invalidate all posts\n    invalidateAllPosts: () => {\n      queryClient.invalidateQueries({\n        queryKey: trpc.posts.list.queryKey(),\n      });\n    },\n\n    // Invalidate specific post\n    invalidatePost: (postId: string) => {\n      queryClient.invalidateQueries({\n        queryKey: trpc.posts.byId.queryKey(postId),\n      });\n    },\n\n    // Invalidate posts by user\n    invalidateUserPosts: (userId: string) => {\n      queryClient.invalidateQueries({\n        queryKey: trpc.posts.byUserId.queryKey(userId),\n      });\n    },\n\n    // Invalidate all user-related data\n    invalidateUser: (userId: string) => {\n      queryClient.invalidateQueries({\n        predicate: (query) => {\n          // Invalidate any query that includes this user ID\n          return query.queryKey.includes(userId);\n        },\n      });\n    },\n  };\n}\n```\n\n### Selective Queries\n\nOnly fetch what you need:\n\n```tsx title=\"components/selective-queries.tsx\"\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../lib/trpc-react';\n\nexport function UserPreview({ userId }: { userId: string }) {\n  const trpc = useTRPC();\n\n  // Only fetch basic user info, not full profile\n  const userQuery = useQuery(trpc.users.preview.queryOptions(userId));\n\n  return (\n    <div>\n      <img src={userQuery.data?.avatar} alt={userQuery.data?.name} />\n      <span>{userQuery.data?.name}</span>\n    </div>\n  );\n}\n\nexport function UserFullProfile({ userId }: { userId: string }) {\n  const trpc = useTRPC();\n\n  // Fetch complete user profile\n  const userQuery = useQuery(trpc.users.fullProfile.queryOptions(userId));\n\n  return (\n    <div>\n      <h1>{userQuery.data?.name}</h1>\n      <p>{userQuery.data?.bio}</p>\n      <div>\n        <h2>Recent Activity</h2>\n        {userQuery.data?.recentActivity?.map((activity) => (\n          <div key={activity.id}>{activity.description}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n## Testing\n\n### Mock tRPC Calls\n\nTest components that use tRPC:\n\n```typescript title=\"__tests__/posts-list.test.tsx\"\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { render, screen } from '@testing-library/react';\nimport { createTRPCMsw } from 'msw-trpc';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { PostsList } from '../components/posts-list';\nimport type { AppRouter } from '../server/router';\n\nconst trpcMsw = createTRPCMsw<AppRouter>();\n\nconst server = setupServer(\n  trpcMsw.posts.list.query((req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.data([\n        { id: '1', title: 'Test Post', content: 'Test content' },\n      ])\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('renders posts list', async () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n\n  render(\n    <QueryClientProvider client={queryClient}>\n      <PostsList />\n    </QueryClientProvider>\n  );\n\n  expect(await screen.findByText('Test Post')).toBeInTheDocument();\n});\n```\n\n## Best Practices\n\n<Accordions>\n<Accordion id='query-keys' title=\"Query Key Management\">\n\n- Use tRPC's built-in `queryKey()` functions for consistency\n- Invalidate queries strategically to avoid unnecessary refetches\n- Use query predicates for complex invalidation patterns\n- Consider query key hierarchies for related data\n\n```typescript\n// Good: Use tRPC query keys\nqueryClient.invalidateQueries(trpc.posts.list.queryKey());\n\n// Good: Strategic invalidation\nqueryClient.invalidateQueries({\n  predicate: (query) => query.queryKey[0] === 'posts'\n});\n```\n\n</Accordion>\n\n<Accordion id='error-handling' title=\"Error Handling Strategy\">\n\n- Set up global error handling in your Query Client\n- Use specific error handling for expected error cases\n- Implement retry logic based on error types\n- Provide helpful error messages to users\n\n```typescript\n// Good: Error-specific handling\nif (error.data?.code === 'NOT_FOUND') {\n  return <NotFoundPage />;\n}\n```\n\n</Accordion>\n\n<Accordion id='performance' title=\"Performance Optimization\">\n\n- Use appropriate `staleTime` values for different data types\n- Implement proper loading states\n- Consider request deduplication for frequently accessed data\n- Use infinite queries for large datasets\n\n```typescript\n// Good: Appropriate stale times\nconst userQuery = useQuery(trpc.users.profile.queryOptions(), {\n  staleTime: 5 * 60 * 1000, // User data changes infrequently\n});\n\nconst notificationsQuery = useQuery(trpc.notifications.list.queryOptions(), {\n  staleTime: 0, // Notifications should always be fresh\n});\n```\n\n</Accordion>\n</Accordions>\n\n---\n\nThe TanStack React Query integration makes tRPC incredibly powerful for building modern React applications. With intelligent caching, background synchronization, and optimistic updates, you get a superior data fetching experience with full type safety.\n"}, {"info":{"path":"framework/videos-and-community-resources.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/videos-and-community-resources.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Videos & Community Resources","description":"Learn from the community with videos, tutorials, tools, and open-source projects","icon":"IconUsers","index":false},"content":"\nDiscover learning resources, tools, and community projects that showcase tRPC in action. From beginner tutorials to advanced patterns, the tRPC community has created incredible content to help you master type-safe APIs.\n\n## Official Resources\n\n### tRPC Team Content\n\n<Cards>\n  <Card\n    href=\"https://www.youtube.com/watch?v=UfUbBWIFdJs\"\n    title=\"tRPC in 100 Seconds\"\n    icon={<IconPlay />}\n  >\n    Quick overview of tRPC's core concepts and benefits by Fireship\n  </Card>\n\n  <Card href=\"https://trpc.io/blog\" title=\"Official Blog\" icon={<IconNews />}>\n    Latest updates, feature announcements, and technical deep dives from the\n    tRPC team\n  </Card>\n\n  <Card\n    href=\"https://github.com/trpc/trpc\"\n    title=\"GitHub Repository\"\n    icon={<IconBrandGithub />}\n  >\n    Source code, issues, discussions, and contribution guidelines\n  </Card>\n\n  <Card\n    href=\"https://trpc.io/discord\"\n    title=\"Discord Community\"\n    icon={<IconBrandDiscord />}\n  >\n    Join thousands of developers discussing tRPC, getting help, and sharing\n    projects\n  </Card>\n</Cards>\n\n## Video Tutorials\n\n### Beginner-Friendly Content\n\n<Accordions>\n<Accordion id='getting-started-videos' title=\"Getting Started Tutorials\">\n\n**\"Full Stack TypeScript with tRPC and Next.js\"** by Theo\n\n- Comprehensive introduction to tRPC with Next.js\n- Setting up authentication with NextAuth.js\n- Database integration with Prisma\n- Deployment strategies\n\n**\"tRPC Crash Course\"** by Lama Dev\n\n- Building a complete application from scratch\n- Understanding queries, mutations, and subscriptions\n- Client-side setup with React Query\n- Error handling and validation\n\n**\"Why I Use tRPC Instead of REST APIs\"** by Josh tried coding\n\n- Comparison with traditional REST APIs\n- Type safety benefits\n- Developer experience improvements\n- Real-world examples\n\n</Accordion>\n\n<Accordion id='intermediate-videos' title=\"Intermediate Topics\">\n\n**\"Advanced tRPC Patterns\"** by WebDevSimplified\n\n- Custom middleware implementation\n- Context and authentication\n- File uploads and handling\n- Performance optimization\n\n**\"tRPC with Next.js App Router\"** by Vercel\n\n- Server Components integration\n- Streaming and Suspense\n- Edge runtime deployment\n- Best practices for production\n\n**\"Building Real-time Apps with tRPC\"** by Coding Garden\n\n- WebSocket subscriptions\n- Server-Sent Events\n- Real-time collaboration features\n- Conflict resolution strategies\n\n</Accordion>\n\n<Accordion id='advanced-videos' title=\"Advanced Techniques\">\n\n**\"Microservices Architecture with tRPC\"** by Hussein Nasser\n\n- Service-to-service communication\n- Load balancing and scaling\n- Distributed systems patterns\n- Monitoring and observability\n\n**\"tRPC Performance Deep Dive\"** by Alex / Render\n\n- Request batching optimization\n- Caching strategies\n- Database query optimization\n- Bundle size analysis\n\n**\"Testing tRPC Applications\"** by Kent C. Dodds\n\n- Unit testing procedures\n- Integration testing patterns\n- End-to-end testing with Playwright\n- Mocking strategies\n\n</Accordion>\n</Accordions>\n\n### Live Streams & Workshops\n\n<Cards>\n  <Card\n    href=\"https://www.youtube.com/watch?v=live-stream-1\"\n    title=\"Building a Chat App with tRPC\"\n    icon={<IconVideo />}\n  >\n    3-hour live coding session building a real-time chat application with\n    WebSocket subscriptions\n  </Card>\n\n  <Card\n    href=\"https://www.youtube.com/watch?v=live-stream-2\"\n    title=\"tRPC + Next.js Workshop\"\n    icon={<IconSchool />}\n  >\n    Interactive workshop covering authentication, database design, and\n    deployment\n  </Card>\n\n  <Card\n    href=\"https://www.youtube.com/watch?v=live-stream-3\"\n    title=\"Migrating from REST to tRPC\"\n    icon={<IconRefresh />}\n  >\n    Step-by-step migration guide with real-world examples and best practices\n  </Card>\n\n  <Card\n    href=\"https://www.youtube.com/watch?v=live-stream-4\"\n    title=\"Advanced TypeScript with tRPC\"\n    icon={<IconCode />}\n  >\n    Deep dive into TypeScript patterns, generic procedures, and type inference\n  </Card>\n</Cards>\n\n## Community Projects\n\n### Open Source Showcases\n\n<Tabs items={['Production Apps', 'Developer Tools', 'Templates & Starters', 'Libraries']}>\n<Tab value=\"Production Apps\">\n\n**Cal.com** - Open-source Calendly alternative\n\n- Complex scheduling logic with tRPC\n- Multi-tenant architecture\n- Integration with external APIs\n- [GitHub](https://github.com/calcom/cal.com)\n\n**Documenso** - Open-source DocuSign alternative\n\n- Document signing workflows\n- Real-time collaboration\n- PDF processing and generation\n- [GitHub](https://github.com/documenso/documenso)\n\n**Maybe Finance** - Personal finance management\n\n- Financial data aggregation\n- Real-time updates and notifications\n- Complex data relationships\n- [GitHub](https://github.com/maybe-finance/maybe)\n\n**Papermark** - Open-source document sharing\n\n- Document analytics and tracking\n- Fine-grained permissions\n- Real-time viewer presence\n- [GitHub](https://github.com/mfts/papermark)\n\n</Tab>\n\n<Tab value=\"Developer Tools\">\n\n**tRPC Playground** - Interactive API explorer\n\n- Real-time procedure testing\n- Type-safe API documentation\n- Schema visualization\n- [Website](https://trpc-playground.dev)\n\n**tRPC Panel** - Admin panel generator\n\n- Auto-generated admin interfaces\n- CRUD operations for all procedures\n- Real-time data updates\n- [GitHub](https://github.com/iway1/trpc-panel)\n\n**tRPC DevTools** - Browser extension\n\n- Request/response inspection\n- Performance monitoring\n- Cache visualization\n- [Chrome Store](https://chrome.google.com/webstore)\n\n**tRPC Transformer** - Code transformation tool\n\n- Convert REST APIs to tRPC\n- Migration assistance\n- Type generation\n- [GitHub](https://github.com/trpc-transformer)\n\n</Tab>\n\n<Tab value=\"Templates & Starters\">\n\n**Create T3 App** - The T3 Stack\n\n- Next.js + tRPC + Prisma + Tailwind\n- Authentication with NextAuth.js\n- Production-ready configuration\n- [create.t3.gg](https://create.t3.gg)\n\n**tRPC + Expo Starter**\n\n- React Native mobile app template\n- Cross-platform type safety\n- Push notifications integration\n- [GitHub](https://github.com/trpc-expo-starter)\n\n**tRPC Serverless Template**\n\n- AWS Lambda deployment\n- CloudFormation infrastructure\n- CI/CD pipeline included\n- [GitHub](https://github.com/trpc-serverless)\n\n**Full-Stack tRPC Monorepo**\n\n- Turborepo configuration\n- Shared packages and types\n- Multiple deployment targets\n- [GitHub](https://github.com/trpc-monorepo)\n\n</Tab>\n\n<Tab value=\"Libraries\">\n\n**tRPC-OpenAPI** - OpenAPI integration\n\n- Generate OpenAPI specs from tRPC routers\n- REST API compatibility layer\n- Automatic documentation\n- [GitHub](https://github.com/jlalmes/trpc-openapi)\n\n**tRPC-SWR** - SWR integration\n\n- Alternative to React Query\n- Custom hooks for SWR\n- Type-safe data fetching\n- [GitHub](https://github.com/trpc-swr)\n\n**tRPC-Middleware-Collections** - Reusable middleware\n\n- Rate limiting, logging, caching\n- Authentication helpers\n- Validation utilities\n- [GitHub](https://github.com/trpc-middleware)\n\n**tRPC-Zod-Prisma** - Schema integration\n\n- Auto-generate Zod schemas from Prisma\n- Type-safe database operations\n- Validation helpers\n- [GitHub](https://github.com/trpc-zod-prisma)\n\n</Tab>\n</Tabs>\n\n## Community Content\n\n### Blog Posts & Articles\n\n**Technical Deep Dives**\n\n- [Building Production-Ready tRPC APIs](https://example.com/trpc-production) by Sarah Chen\n- [tRPC Performance Optimization Guide](https://example.com/trpc-performance) by Mike Johnson\n- [Advanced TypeScript Patterns in tRPC](https://example.com/trpc-typescript) by Alex Rodriguez\n- [Scaling tRPC: From Startup to Enterprise](https://example.com/trpc-scaling) by Jennifer Kim\n\n**Integration Guides**\n\n- [tRPC + Supabase: Type-Safe Backend](https://example.com/trpc-supabase) by David Park\n- [Using tRPC with Expo and React Native](https://example.com/trpc-expo) by Maria Garcia\n- [tRPC Deployment on Railway](https://example.com/trpc-railway) by Tom Wilson\n- [Serverless tRPC with Vercel Functions](https://example.com/trpc-vercel) by Lisa Chang\n\n**Case Studies**\n\n- [How Acme Corp Migrated 50+ APIs to tRPC](https://example.com/acme-migration) by Engineering Team\n- [Building a Multi-Tenant SaaS with tRPC](https://example.com/saas-trpc) by Startup Founder\n- [tRPC in a Microservices Architecture](https://example.com/microservices-trpc) by Platform Team\n\n### Podcasts & Interviews\n\n<Cards>\n  <Card\n    href=\"#\"\n    title=\"The Future of APIs with Alex Johansson\"\n    icon={<IconMicrophone />}\n  >\n    tRPC creator discusses type safety, developer experience, and the future of\n    API development\n  </Card>\n\n  <Card\n    href=\"#\"\n    title=\"Building Type-Safe Full-Stack Apps\"\n    icon={<IconHeadphones />}\n  >\n    Panel discussion with tRPC team members and community maintainers\n  </Card>\n\n  <Card\n    href=\"#\"\n    title=\"Developer Stories: Success with tRPC\"\n    icon={<IconUser />}\n  >\n    Real developers share their experiences migrating to and scaling with tRPC\n  </Card>\n</Cards>\n\n## Tools & Extensions\n\n### Development Tools\n\n<Accordions>\n<Accordion id='vscode-extensions' title=\"VS Code Extensions\">\n\n**tRPC Snippets** - Code snippets for faster development\n\n- Router and procedure templates\n- Common patterns and middleware\n- Type-safe client setup\n\n**tRPC IntelliSense** - Enhanced TypeScript support\n\n- Better autocomplete for tRPC APIs\n- Inline documentation\n- Error highlighting\n\n**tRPC Schema Validator** - Real-time validation\n\n- Zod schema validation\n- Input/output type checking\n- Performance suggestions\n\n</Accordion>\n\n<Accordion id='cli-tools' title=\"CLI Tools\">\n\n**tRPC CLI** - Command-line utilities\n\n- Generate boilerplate code\n- Schema validation\n- Migration helpers\n\n**tRPC CodeGen** - Code generation\n\n- Client SDK generation\n- Type definition exports\n- Documentation generation\n\n**tRPC Deploy** - Deployment assistance\n\n- Platform-specific configurations\n- Infrastructure as code\n- Environment management\n\n</Accordion>\n\n<Accordion id='testing-tools' title=\"Testing Tools\">\n\n**tRPC Test Utils** - Testing helpers\n\n- Mock server creation\n- Procedure testing utilities\n- Type-safe test assertions\n\n**tRPC E2E** - End-to-end testing\n\n- Browser automation\n- API integration tests\n- Performance benchmarking\n\n</Accordion>\n</Accordions>\n\n### Monitoring & Analytics\n\n<Cards>\n  <Card href=\"#\" title=\"tRPC Analytics\" icon={<IconChartLine />}>\n    Track API usage, performance metrics, and error rates with detailed\n    dashboards\n  </Card>\n\n  <Card href=\"#\" title=\"tRPC APM\" icon={<IconActivity />}>\n    Application performance monitoring specifically designed for tRPC\n    applications\n  </Card>\n\n  <Card href=\"#\" title=\"Error Tracking\" icon={<IconAlert />}>\n    Real-time error monitoring with tRPC-specific context and stack traces\n  </Card>\n</Cards>\n\n## Learning Paths\n\n### For Beginners\n\n1. **Start with Basics**\n   - Watch \"tRPC in 100 Seconds\"\n   - Follow the [Quickstart Guide](/docs/framework/quickstart)\n   - Build your first API\n\n2. **Understand Core Concepts**\n   - Read [Core Concepts](/docs/framework/concepts)\n   - Practice with simple CRUD operations\n   - Learn about type safety benefits\n\n3. **Build Real Projects**\n   - Follow tutorial series\n   - Clone and modify example repositories\n   - Join Discord for help and feedback\n\n### For Intermediate Developers\n\n1. **Advanced Patterns**\n   - Learn middleware and context\n   - Implement authentication\n   - Practice error handling\n\n2. **Integration Skills**\n   - Connect to databases\n   - Set up React Query\n   - Deploy to production\n\n3. **Community Contribution**\n   - Answer questions in Discord\n   - Create tutorials or blog posts\n   - Contribute to open-source projects\n\n### For Advanced Users\n\n1. **Architecture Design**\n   - Design scalable APIs\n   - Implement microservices patterns\n   - Optimize performance\n\n2. **Tool Creation**\n   - Build development tools\n   - Create libraries and extensions\n   - Share with the community\n\n3. **Thought Leadership**\n   - Write technical articles\n   - Speak at conferences\n   - Mentor other developers\n\n## Contributing to the Community\n\n### How to Get Involved\n\n**Share Your Projects**\n\n- Post in Discord showcases\n- Write case studies\n- Create video tutorials\n\n**Help Others Learn**\n\n- Answer questions in Discord\n- Review pull requests\n- Create educational content\n\n**Build Tools**\n\n- Develop VS Code extensions\n- Create CLI utilities\n- Build testing frameworks\n\n**Spread the Word**\n\n- Write blog posts\n- Give conference talks\n- Share on social media\n\n### Community Guidelines\n\n**Be Helpful and Respectful**\n\n- Welcome newcomers warmly\n- Provide constructive feedback\n- Share knowledge generously\n\n**Follow Best Practices**\n\n- Write clean, documented code\n- Follow TypeScript conventions\n- Test your contributions\n\n**Stay Engaged**\n\n- Participate in discussions\n- Attend community events\n- Provide feedback on new features\n\n---\n\nThe tRPC community is growing rapidly and always welcomes new contributors. Whether you're sharing a project, helping others learn, or building tools, your participation makes the ecosystem stronger for everyone.\n"}, {"info":{"path":"client/index.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/client/index.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"tRPC Client","description":"Integrate tRPC with your frontend applications","icon":"IconDeviceDesktop","index":false},"content":"\ntRPC Client provides fully typesafe API calls with automatic TypeScript inference, excellent DX, and seamless integration with popular frontend frameworks.\n\n## What is tRPC Client?\n\ntRPC Client is the frontend portion of tRPC that handles:\n\n- **Type-Safe API Calls**: Automatic TypeScript inference for all API interactions\n- **Framework Integration**: First-class support for React, Next.js, and other frameworks\n- **Caching & State Management**: Built-in integration with TanStack Query for optimal UX\n- **Error Handling**: Structured error handling with proper TypeScript types\n- **Real-time Features**: Support for subscriptions and WebSocket connections\n\n## Core Features\n\n<Cards>\n  <Card\n    icon={<IconShield className=\"text-blue-500\" />}\n    title=\"End-to-End Type Safety\"\n  >\n    Get full TypeScript autocompletion and type checking from server to client.\n  </Card>\n\n<Card icon={<IconRefresh className=\"text-green-500\" />} title=\"Smart Caching\">\n  Built-in integration with TanStack Query for caching, background updates, and\n  optimistic updates.\n</Card>\n\n<Card\n  icon={<IconPuzzle className=\"text-purple-500\" />}\n  title=\"Framework Agnostic\"\n>\n  Use with React, Next.js, or any JavaScript framework with our flexible client\n  adapters.\n</Card>\n\n  <Card icon={<IconBolt className=\"text-orange-500\" />} title=\"Exceptional DX\">\n    Full autocomplete, go-to-definition, and refactoring that works across your\n    entire stack.\n  </Card>\n</Cards>\n\n## Client Integrations\n\n### React with TanStack Query (Recommended)\n\nThe most powerful way to use tRPC in React applications:\n\n```typescript title=\"utils/trpc.ts\"\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n```typescript title=\"app/layout.tsx\"\n'use client';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { trpc } from '../utils/trpc';\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: '/api/trpc',\n        }),\n      ],\n    })\n  );\n\n  return (\n    <html>\n      <body>\n        <trpc.Provider client={trpcClient} queryClient={queryClient}>\n          <QueryClientProvider client={queryClient}>\n            {children}\n          </QueryClientProvider>\n        </trpc.Provider>\n      </body>\n    </html>\n  );\n}\n```\n\n### Usage in Components\n\n<Tabs items={['Queries', 'Mutations', 'Optimistic Updates']}>\n  <Tab value=\"Queries\">\n    ```typescript title=\"components/UserProfile.tsx\"\n    export function UserProfile({ userId }: { userId: string }) {\n      const userQuery = useQuery(\n        trpc.users.getById.queryOptions(userId)\n      );\n      \n      if (userQuery.isLoading) return <div>Loading...</div>;\n      if (userQuery.error) return <div>Error: {userQuery.error.message}</div>;\n      \n      return (\n        <div>\n          <h1>{userQuery.data.name}</h1>\n          <p>{userQuery.data.email}</p>\n        </div>\n      );\n    }\n    ```\n  </Tab>\n  \n  <Tab value=\"Mutations\">\n    ```typescript title=\"components/CreateUser.tsx\"\n    export function CreateUser() {\n      const utils = trpc.useUtils();\n      \n      const createUserMutation = useMutation(\n        trpc.users.create.mutationOptions({\n          onSuccess: () => {\n            // Invalidate and refetch users list\n            utils.users.list.invalidate();\n          },\n        })\n      );\n      \n      return (\n        <form onSubmit={(e) => {\n          e.preventDefault();\n          const formData = new FormData(e.currentTarget);\n          createUserMutation.mutate({\n            name: formData.get('name') as string,\n            email: formData.get('email') as string,\n          });\n        }}>\n          <input name=\"name\" placeholder=\"Name\" required />\n          <input name=\"email\" type=\"email\" placeholder=\"Email\" required />\n          <button type=\"submit\" disabled={createUserMutation.isPending}>\n            {createUserMutation.isPending ? 'Creating...' : 'Create User'}\n          </button>\n        </form>\n      );\n    }\n    ```\n  </Tab>\n  \n  <Tab value=\"Optimistic Updates\">\n    ```typescript title=\"components/TodoList.tsx\"\n    export function TodoList() {\n      const utils = trpc.useUtils();\n      \n      const toggleTodoMutation = useMutation(\n        trpc.todos.toggle.mutationOptions({\n          onMutate: async ({ id }) => {\n            // Cancel outgoing refetches\n            await utils.todos.list.cancel();\n            \n            // Snapshot the previous value\n            const previousTodos = utils.todos.list.getData();\n            \n            // Optimistically update\n            utils.todos.list.setData(undefined, (old) =>\n              old?.map(todo => \n                todo.id === id \n                  ? { ...todo, completed: !todo.completed }\n                  : todo\n              )\n            );\n            \n            return { previousTodos };\n          },\n          onError: (err, variables, context) => {\n            // Rollback on error\n            utils.todos.list.setData(undefined, context?.previousTodos);\n          },\n          onSettled: () => {\n            // Always refetch after error or success\n            utils.todos.list.invalidate();\n          },\n        })\n      );\n      \n      // ... component logic\n    }\n    ```\n  </Tab>\n</Tabs>\n\n## Client Architecture\n\n```mermaid\ngraph TB\n    A[React Component] --> B[tRPC Hook]\n    B --> C[TanStack Query]\n    C --> D[tRPC Client]\n    D --> E[HTTP Link]\n    E --> F[Server API]\n\n    C --> G[Cache]\n    C --> H[Background Sync]\n    C --> I[Optimistic Updates]\n\n    style C fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style I fill:#fff3e0\n```\n\n## Framework Integrations\n\n<Accordion type=\"multiple\">\n  <AccordionItem value=\"nextjs\">\n    <AccordionTrigger>Next.js Integration</AccordionTrigger>\n    <AccordionContent>\n      Full-stack integration with Next.js including SSR, SSG, and API routes.\n      \n      ```typescript\n      // pages/api/trpc/[trpc].ts\n      import { createNextApiHandler } from '@trpc/server/adapters/next';\n      import { appRouter } from '~/server/router';\n      \n      export default createNextApiHandler({\n        router: appRouter,\n        createContext,\n      });\n      ```\n    </AccordionContent>\n  </AccordionItem>\n  \n  <AccordionItem value=\"react\">\n    <AccordionTrigger>React Integration</AccordionTrigger>\n    <AccordionContent>\n      Use tRPC with any React application using our React Query integration.\n      \n      ```typescript\n      import { createTRPCReact } from '@trpc/react-query';\n      \n      export const trpc = createTRPCReact<AppRouter>();\n      ```\n    </AccordionContent>\n  </AccordionItem>\n  \n  <AccordionItem value=\"vanilla\">\n    <AccordionTrigger>Vanilla Client</AccordionTrigger>\n    <AccordionContent>\n      Use tRPC without any framework dependencies for maximum flexibility.\n      \n      ```typescript\n      import { createTRPCClient, httpBatchLink } from '@trpc/client';\n      \n      const client = createTRPCClient<AppRouter>({\n        links: [httpBatchLink({ url: '/api/trpc' })],\n      });\n      \n      const result = await client.users.getById.query('123');\n      ```\n    </AccordionContent>\n  </AccordionItem>\n</Accordion>\n\n## Advanced Features\n\n### Infinite Queries\n\nPerfect for pagination and infinite scrolling:\n\n```typescript\nconst postsQuery = useInfiniteQuery(\n  trpc.posts.infiniteList.infiniteQueryOptions({\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n  })\n);\n```\n\n### Subscriptions\n\nReal-time data with WebSockets or Server-Sent Events:\n\n```typescript\nconst subscription = trpc.messages.onAdd.useSubscription(\n  { channelId: 'general' },\n  {\n    onData: (message) => {\n      console.log('New message:', message);\n    },\n  }\n);\n```\n\n### Custom Links\n\nCustomize how requests are sent to your server:\n\n```typescript\nconst client = trpc.createClient({\n  links: [\n    loggerLink(),\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: wsLink({ client: wsClient }),\n      false: httpBatchLink({ url: '/api/trpc' }),\n    }),\n  ],\n});\n```\n\n## Error Handling\n\ntRPC provides structured error handling with full TypeScript support:\n\n```typescript\nconst userQuery = useQuery(trpc.users.getById.queryOptions(userId));\n\nif (userQuery.error) {\n  // error is fully typed based on your server's error format\n  switch (userQuery.error.data?.code) {\n    case 'NOT_FOUND':\n      return <div>User not found</div>;\n    case 'UNAUTHORIZED':\n      return <div>Please log in</div>;\n    default:\n      return <div>Something went wrong</div>;\n  }\n}\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"React Integration\" href=\"/docs/client/tanstack-react-query\">\n    Get started with tRPC and TanStack Query in React\n  </Card>\n\n<Card title=\"Next.js Setup\" href=\"/docs/client/nextjs\">\n  Full-stack tRPC with Next.js SSR and API routes\n</Card>\n\n<Card title=\"Configuration\" href=\"/docs/client/links\">\n  Customize your client with links and middleware\n</Card>\n\n  <Card title=\"Error Handling\" href=\"/docs/client/error-handling\">\n    Handle errors gracefully with proper TypeScript types\n  </Card>\n</Cards>\n\n<Callout title=\"New to tRPC?\">\n  Start with our [Framework overview](/docs/framework) to understand the core\n  concepts, then dive into server-side implementation before setting up your\n  client.\n</Callout>\n"}, {"info":{"path":"client/installation.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/client/installation.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Client Installation","description":"Install and set up tRPC client for your frontend","icon":"IconDownload","index":false},"content":"\nThis guide covers installing and setting up tRPC on the client side to connect your frontend to your tRPC server.\n\n## Quick Install\n\n<Steps>\n  <Step title=\"Install tRPC Client\">\n    Install the core client package and TanStack Query integration:\n    \n    <Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n      <Tab value=\"npm\">\n        ```bash\n        npm install @trpc/client @trpc/react-query @tanstack/react-query\n        ```\n      </Tab>\n      <Tab value=\"pnpm\">\n        ```bash\n        pnpm add @trpc/client @trpc/react-query @tanstack/react-query\n        ```\n      </Tab>\n      <Tab value=\"yarn\">\n        ```bash\n        yarn add @trpc/client @trpc/react-query @tanstack/react-query\n        ```\n      </Tab>\n      <Tab value=\"bun\">\n        ```bash\n        bun add @trpc/client @trpc/react-query @tanstack/react-query\n        ```\n      </Tab>\n    </Tabs>\n  </Step>\n\n<Step title=\"Install React (if needed)\">\n  If you're using React or Next.js, ensure you have React installed:\n  <Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n    <Tab value=\"npm\">\n      ```bash npm install react react-dom @types/react @types/react-dom ```\n    </Tab>\n    <Tab value=\"pnpm\">\n      ```bash pnpm add react react-dom @types/react @types/react-dom ```\n    </Tab>\n    <Tab value=\"yarn\">\n      ```bash yarn add react react-dom @types/react @types/react-dom ```\n    </Tab>\n    <Tab value=\"bun\">\n      ```bash bun add react react-dom @types/react @types/react-dom ```\n    </Tab>\n  </Tabs>\n</Step>\n\n  <Step title=\"Framework-specific packages (optional)\">\n    Install additional packages based on your framework:\n    \n    <Tabs items={['Next.js', 'Vite/CRA', 'Vanilla JS']}>\n      <Tab value=\"Next.js\">\n        ```bash\n        # Next.js integration (optional for enhanced features)\n        npm install @trpc/next\n        ```\n      </Tab>\n      <Tab value=\"Vite/CRA\">\n        ```bash\n        # No additional packages needed for standard React setups\n        ```\n      </Tab>\n      <Tab value=\"Vanilla JS\">\n        ```bash\n        # Use vanilla client without React dependencies\n        npm install @trpc/client\n        ```\n      </Tab>\n    </Tabs>\n  </Step>\n</Steps>\n\n## Framework-Specific Setup\n\n<Tabs items={['React with TanStack Query', 'Next.js App Router', 'Next.js Pages Router', 'Vanilla JavaScript']}>\n  <Tab value=\"React with TanStack Query\">\n    ```typescript title=\"utils/trpc.ts\"\n    import { createTRPCReact } from '@trpc/react-query';\n    import type { AppRouter } from '../server/router'; // Import your server router type\n\n    export const trpc = createTRPCReact<AppRouter>();\n    ```\n\n    ```typescript title=\"App.tsx\"\n    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n    import { httpBatchLink } from '@trpc/client';\n    import { useState } from 'react';\n    import { trpc } from './utils/trpc';\n\n    export default function App() {\n      const [queryClient] = useState(() => new QueryClient());\n      const [trpcClient] = useState(() =>\n        trpc.createClient({\n          links: [\n            httpBatchLink({\n              url: 'http://localhost:3000/api/trpc',\n            }),\n          ],\n        })\n      );\n\n      return (\n        <trpc.Provider client={trpcClient} queryClient={queryClient}>\n          <QueryClientProvider client={queryClient}>\n            <YourApp />\n          </QueryClientProvider>\n        </trpc.Provider>\n      );\n    }\n    ```\n\n  </Tab>\n\n  <Tab value=\"Next.js App Router\">\n    ```typescript title=\"utils/trpc.ts\"\n    import { createTRPCReact } from '@trpc/react-query';\n    import type { AppRouter } from '../server/router';\n\n    export const trpc = createTRPCReact<AppRouter>();\n    ```\n\n    ```typescript title=\"app/providers.tsx\"\n    'use client';\n    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n    import { httpBatchLink } from '@trpc/client';\n    import { useState } from 'react';\n    import { trpc } from '../utils/trpc';\n\n    export function TRPCProvider({ children }: { children: React.ReactNode }) {\n      const [queryClient] = useState(() => new QueryClient());\n      const [trpcClient] = useState(() =>\n        trpc.createClient({\n          links: [\n            httpBatchLink({\n              url: '/api/trpc',\n            }),\n          ],\n        })\n      );\n\n      return (\n        <trpc.Provider client={trpcClient} queryClient={queryClient}>\n          <QueryClientProvider client={queryClient}>\n            {children}\n          </QueryClientProvider>\n        </trpc.Provider>\n      );\n    }\n    ```\n\n    ```typescript title=\"app/layout.tsx\"\n    import { TRPCProvider } from './providers';\n\n    export default function RootLayout({\n      children,\n    }: {\n      children: React.ReactNode;\n    }) {\n      return (\n        <html>\n          <body>\n            <TRPCProvider>{children}</TRPCProvider>\n          </body>\n        </html>\n      );\n    }\n    ```\n\n  </Tab>\n\n  <Tab value=\"Next.js Pages Router\">\n    ```typescript title=\"utils/trpc.ts\"\n    import { createTRPCNext } from '@trpc/next';\n    import { httpBatchLink } from '@trpc/client';\n    import type { AppRouter } from '../server/router';\n\n    export const trpc = createTRPCNext<AppRouter>({\n      config() {\n        return {\n          links: [\n            httpBatchLink({\n              url: '/api/trpc',\n            }),\n          ],\n        };\n      },\n      ssr: false, // Set to true for SSR\n    });\n    ```\n\n    ```typescript title=\"pages/_app.tsx\"\n    import type { AppType } from 'next/app';\n    import { trpc } from '../utils/trpc';\n\n    const MyApp: AppType = ({ Component, pageProps }) => {\n      return <Component {...pageProps} />;\n    };\n\n    export default trpc.withTRPC(MyApp);\n    ```\n\n  </Tab>\n\n  <Tab value=\"Vanilla JavaScript\">\n    ```typescript title=\"client.ts\"\n    import { createTRPCClient, httpBatchLink } from '@trpc/client';\n    import type { AppRouter } from '../server/router';\n\n    const client = createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/api/trpc',\n        }),\n      ],\n    });\n\n    // Use the client\n    async function fetchUser(id: string) {\n      const user = await client.user.getById.query(id);\n      return user;\n    }\n\n    async function createUser(data: { name: string; email: string }) {\n      const user = await client.user.create.mutate(data);\n      return user;\n    }\n    ```\n\n  </Tab>\n</Tabs>\n\n## Usage Examples\n\nOnce installed, you can use tRPC in your components:\n\n<Tabs items={['Queries', 'Mutations', 'Infinite Queries']}>\n  <Tab value=\"Queries\">\n    ```typescript title=\"components/UserProfile.tsx\"\n    import { useQuery } from '@tanstack/react-query';\n    import { trpc } from '../utils/trpc';\n\n    export function UserProfile({ userId }: { userId: string }) {\n      const userQuery = useQuery(\n        trpc.user.getById.queryOptions(userId)\n      );\n\n      if (userQuery.isLoading) return <div>Loading...</div>;\n      if (userQuery.error) return <div>Error: {userQuery.error.message}</div>;\n\n      return (\n        <div>\n          <h1>{userQuery.data.name}</h1>\n          <p>{userQuery.data.email}</p>\n        </div>\n      );\n    }\n    ```\n\n  </Tab>\n\n  <Tab value=\"Mutations\">\n    ```typescript title=\"components/CreateUser.tsx\"\n    import { useMutation } from '@tanstack/react-query';\n    import { trpc } from '../utils/trpc';\n\n    export function CreateUser() {\n      const utils = trpc.useUtils();\n\n      const createUserMutation = useMutation(\n        trpc.user.create.mutationOptions({\n          onSuccess: () => {\n            utils.user.list.invalidate();\n          },\n        })\n      );\n\n      const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n        e.preventDefault();\n        const formData = new FormData(e.currentTarget);\n\n        createUserMutation.mutate({\n          name: formData.get('name') as string,\n          email: formData.get('email') as string,\n        });\n      };\n\n      return (\n        <form onSubmit={handleSubmit}>\n          <input name=\"name\" placeholder=\"Name\" required />\n          <input name=\"email\" type=\"email\" placeholder=\"Email\" required />\n          <button type=\"submit\" disabled={createUserMutation.isPending}>\n            {createUserMutation.isPending ? 'Creating...' : 'Create User'}\n          </button>\n        </form>\n      );\n    }\n    ```\n\n  </Tab>\n\n  <Tab value=\"Infinite Queries\">\n    ```typescript title=\"components/PostList.tsx\"\n    import { useInfiniteQuery } from '@tanstack/react-query';\n    import { trpc } from '../utils/trpc';\n\n    export function PostList() {\n      const postsQuery = useInfiniteQuery(\n        trpc.post.infiniteList.infiniteQueryOptions({\n          getNextPageParam: (lastPage) => lastPage.nextCursor,\n        })\n      );\n\n      return (\n        <div>\n          {postsQuery.data?.pages.map((page) =>\n            page.posts.map((post) => (\n              <article key={post.id}>\n                <h2>{post.title}</h2>\n                <p>{post.content}</p>\n              </article>\n            ))\n          )}\n\n          {postsQuery.hasNextPage && (\n            <button\n              onClick={() => postsQuery.fetchNextPage()}\n              disabled={postsQuery.isFetchingNextPage}\n            >\n              {postsQuery.isFetchingNextPage ? 'Loading...' : 'Load More'}\n            </button>\n          )}\n        </div>\n      );\n    }\n    ```\n\n  </Tab>\n</Tabs>\n\n## Common Package Combinations\n\n### React Applications\n\n```bash\nnpm install @trpc/client @trpc/react-query @tanstack/react-query\n```\n\n### Next.js Applications\n\n```bash\nnpm install @trpc/client @trpc/react-query @tanstack/react-query @trpc/next\n```\n\n### Vanilla JavaScript\n\n```bash\nnpm install @trpc/client\n```\n\n### With Real-time Features\n\n```bash\nnpm install @trpc/client @trpc/react-query @tanstack/react-query ws\n```\n\n## TypeScript Requirements\n\nEnsure your `tsconfig.json` includes:\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"jsx\": \"react-jsx\" // for React projects\n  }\n}\n```\n\n## Next Steps\n\n<Cards>\n  <Card\n    title=\"TanStack Query Integration\"\n    href=\"/docs/client/tanstack-react-query\"\n  >\n    Learn how to use tRPC with TanStack Query for optimal React integration\n  </Card>\n\n<Card title=\"Client Setup Guide\" href=\"/docs/client/setup\">\n  Complete setup guide for different frameworks and scenarios\n</Card>\n\n<Card title=\"React Hooks\" href=\"/docs/client/react-hooks\">\n  Explore all available React hooks for queries, mutations, and utilities\n</Card>\n\n  <Card title=\"Error Handling\" href=\"/docs/client/error-handling\">\n    Handle errors gracefully with proper TypeScript types\n  </Card>\n</Cards>\n\n<Callout title=\"Need server setup?\">\n  Before setting up the client, make sure you have a tRPC server running. Check\n  out [tRPC Server](/docs/server) for setup instructions.\n</Callout>\n"}, {"info":{"path":"server/authorization.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/authorization.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Authorization","description":"Implement authentication and role-based access control in tRPC","icon":"IconLock","index":false},"content":"\nAuthorization ensures that users can only access resources and perform actions they're permitted to. tRPC provides flexible patterns for implementing authentication and authorization through context and middleware.\n\n<Callout title=\"Authorization Concepts\">\n  - **Authentication**: Verifying who the user is (login) - **Authorization**:\n  Determining what the user can do (permissions) - **Context**: Share user data\n  across procedures - **Middleware**: Enforce access controls consistently\n</Callout>\n\n## Basic Authentication\n\n### Creating Context from Headers\n\nExtract user information from request headers in your context:\n\n```typescript title=\"src/context.ts\"\nimport { TRPCError } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { verifyJWT } from './auth-utils';\n\nexport async function createContext({ req, res }: CreateNextContextOptions) {\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      try {\n        const token = req.headers.authorization.split(' ')[1];\n        const user = await verifyJWT(token);\n        return user;\n      } catch (error) {\n        console.warn('Invalid token:', error.message);\n        return null;\n      }\n    }\n    return null;\n  }\n\n  const user = await getUserFromHeader();\n\n  return {\n    req,\n    res,\n    user,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n### Session-Based Authentication\n\nFor session-based auth (cookies):\n\n```typescript title=\"src/session-context.ts\"\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from './auth-config';\n\nexport async function createContext({ req, res }: CreateNextContextOptions) {\n  // Get session from next-auth\n  const session = await getServerSession(req, res, authOptions);\n\n  return {\n    req,\n    res,\n    session,\n    user: session?.user || null,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n## Authorization Patterns\n\n### Option 1: Authorize in Resolvers\n\nCheck authorization directly in procedure handlers:\n\n```typescript title=\"src/resolver-auth.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  // Public endpoint\n  hello: publicProcedure\n    .input(z.string().nullish())\n    .query(({ input, ctx }) => {\n      return `Hello ${input ?? ctx.user?.name ?? 'World'}`;\n    }),\n\n  // Protected endpoint\n  getSecret: publicProcedure.query(({ ctx }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return { secret: 'This is a protected secret!' };\n  }),\n});\n```\n\n### Option 2: Authorize with Middleware (Recommended)\n\nCreate reusable middleware for authorization:\n\n```typescript title=\"src/auth-middleware.ts\"\nimport { TRPCError } from '@trpc/server';\n\n// Protected procedure - requires authentication\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.user, // User is now guaranteed to be non-null\n    },\n  });\n});\n\n// Admin procedure\nexport const adminProcedure = protectedProcedure.use(({ ctx, next }) => {\n  if (ctx.user.role !== 'admin') {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Admin access required'\n    });\n  }\n\n  return next();\n});\n```\n\n## Role-Based Access Control (RBAC)\n\n### Flexible Role Middleware\n\n```typescript title=\"src/rbac.ts\"\n// Role middleware factory\nexport const requireRole = (requiredRole: string) => {\n  return t.middleware(({ ctx, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    if (ctx.user.role !== requiredRole) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `${requiredRole} role required`,\n      });\n    }\n\n    return next();\n  });\n};\n\n// Create role-specific procedures\nexport const userProcedure = t.procedure.use(requireRole('user'));\nexport const adminProcedure = t.procedure.use(requireRole('admin'));\n```\n\n### Resource-Based Authorization\n\n```typescript title=\"src/resource-auth.ts\"\n// Post ownership middleware\nconst requirePostOwnership = t.middleware(async ({ ctx, input, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  const postId = (input as any)?.postId;\n  if (!postId) {\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Post ID required',\n    });\n  }\n\n  const post = await getPost(postId);\n  if (!post) {\n    throw new TRPCError({ code: 'NOT_FOUND' });\n  }\n\n  // Check ownership or admin role\n  if (post.authorId !== ctx.user.id && ctx.user.role !== 'admin') {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'You can only modify your own posts',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      post, // Add post to context\n    },\n  });\n});\n\n// Organization membership middleware\nconst requireOrganizationMember = t.middleware(async ({ ctx, input, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  const organizationId = (input as any)?.organizationId;\n  const membership = await getOrganizationMembership(ctx.user.id, organizationId);\n\n  if (!membership) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Not a member of this organization',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      organization: membership.organization,\n      membershipRole: membership.role,\n    },\n  });\n});\n\n// Usage\nexport const postOwnerProcedure = protectedProcedure.use(requirePostOwnership);\nexport const organizationMemberProcedure = protectedProcedure.use(requireOrganizationMember);\n```\n\n## Advanced Authorization Patterns\n\n### Attribute-Based Access Control (ABAC)\n\n```typescript title=\"src/abac.ts\"\ninterface AuthorizationContext {\n  user: User;\n  resource?: any;\n  action: string;\n  environment: {\n    time: Date;\n    ip: string;\n    userAgent: string;\n  };\n}\n\ntype Policy = (context: AuthorizationContext) => boolean;\n\n// Define policies\nconst policies: Record<string, Policy> = {\n  'posts:read': ({ user, resource }) => {\n    // Anyone can read published posts\n    if (resource?.published) return true;\n    // Authors can read their own drafts\n    if (resource?.authorId === user.id) return true;\n    // Admins can read everything\n    if (user.role === 'admin') return true;\n    return false;\n  },\n\n  'posts:edit': ({ user, resource }) => {\n    // Only authors or admins can edit\n    return resource?.authorId === user.id || user.role === 'admin';\n  },\n\n  'users:delete': ({ user, resource, environment }) => {\n    // Only admins can delete users\n    if (user.role !== 'admin') return false;\n    // Can't delete yourself\n    if (resource?.id === user.id) return false;\n    // Can't delete during business hours (example)\n    const hour = environment.time.getHours();\n    if (hour >= 9 && hour <= 17) return false;\n    return true;\n  },\n};\n\n// Authorization middleware\nconst authorize = (action: string) => {\n  return t.middleware(async ({ ctx, input, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    const policy = policies[action];\n    if (!policy) {\n      throw new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: `No policy defined for action: ${action}`,\n      });\n    }\n\n    // Get resource if ID is provided\n    let resource = null;\n    const resourceId = (input as any)?.id || (input as any)?.postId || (input as any)?.userId;\n    if (resourceId) {\n      resource = await getResource(action.split(':')[0], resourceId);\n    }\n\n    const authContext: AuthorizationContext = {\n      user: ctx.user,\n      resource,\n      action,\n      environment: {\n        time: new Date(),\n        ip: ctx.req.ip || 'unknown',\n        userAgent: ctx.req.headers['user-agent'] || 'unknown',\n      },\n    };\n\n    if (!policy(authContext)) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `Not authorized to ${action}`,\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        resource,\n      },\n    });\n  });\n};\n\n// Usage\nexport const readPostProcedure = protectedProcedure.use(authorize('posts:read'));\nexport const editPostProcedure = protectedProcedure.use(authorize('posts:edit'));\nexport const deleteUserProcedure = protectedProcedure.use(authorize('users:delete'));\n```\n\n### Organization-Based Authorization\n\n```typescript title=\"src/organization-auth.ts\"\n// Multi-tenant authorization\nconst withOrganizationAccess = (requiredRole?: string) => {\n  return t.middleware(async ({ ctx, input, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    const organizationId = (input as any)?.organizationId;\n    if (!organizationId) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: 'Organization ID required',\n      });\n    }\n\n    // Check user's role in the organization\n    const membership = await db.organizationMember.findFirst({\n      where: {\n        userId: ctx.user.id,\n        organizationId,\n      },\n      include: {\n        organization: true,\n      },\n    });\n\n    if (!membership) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: 'Not a member of this organization',\n      });\n    }\n\n    // Check role requirement\n    if (requiredRole && membership.role !== requiredRole && membership.role !== 'owner') {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `${requiredRole} role required in this organization`,\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        organization: membership.organization,\n        organizationRole: membership.role,\n      },\n    });\n  });\n};\n\n// Create organization-specific procedures\nexport const orgMemberProcedure = protectedProcedure.use(withOrganizationAccess());\nexport const orgAdminProcedure = protectedProcedure.use(withOrganizationAccess('admin'));\nexport const orgOwnerProcedure = protectedProcedure.use(withOrganizationAccess('owner'));\n\n// Usage in router\nexport const organizationRouter = t.router({\n  // Any member can view organization\n  getInfo: orgMemberProcedure\n    .input(z.object({ organizationId: z.string() }))\n    .query(({ ctx }) => {\n      return ctx.organization;\n    }),\n\n  // Only admins can update settings\n  updateSettings: orgAdminProcedure\n    .input(z.object({\n      organizationId: z.string(),\n      settings: z.object({\n        name: z.string().optional(),\n        description: z.string().optional(),\n      }),\n    }))\n    .mutation(({ input, ctx }) => {\n      return updateOrganizationSettings(input.organizationId, input.settings);\n    }),\n\n  // Only owners can delete organization\n  delete: orgOwnerProcedure\n    .input(z.object({ organizationId: z.string() }))\n    .mutation(({ input }) => {\n      return deleteOrganization(input.organizationId);\n    }),\n});\n```\n\n## Authentication Strategies\n\n### JWT Authentication\n\n```typescript title=\"src/jwt-auth.ts\"\nimport jwt from 'jsonwebtoken';\n\n// JWT middleware\nexport const jwtAuth = t.middleware(async ({ ctx, next }) => {\n  const authHeader = ctx.req.headers.authorization;\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Missing or invalid authorization header',\n    });\n  }\n\n  const token = authHeader.substring(7); // Remove 'Bearer ' prefix\n\n  try {\n    const payload = jwt.verify(token, process.env.JWT_SECRET!) as {\n      userId: string;\n      role: string;\n      permissions: string[];\n    };\n\n    // Optionally fetch fresh user data\n    const user = await getUserById(payload.userId);\n    if (!user) {\n      throw new TRPCError({\n        code: 'UNAUTHORIZED',\n        message: 'User not found',\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user,\n        token: payload,\n      },\n    });\n  } catch (error) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Invalid or expired token',\n      cause: error,\n    });\n  }\n});\n```\n\n### API Key Authentication\n\n```typescript title=\"src/api-key-auth.ts\"\n// API key middleware\nexport const apiKeyAuth = t.middleware(async ({ ctx, next }) => {\n  const apiKey = ctx.req.headers['x-api-key'] || ctx.req.query.apiKey;\n\n  if (!apiKey) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'API key required',\n    });\n  }\n\n  const keyRecord = await db.apiKey.findUnique({\n    where: { key: apiKey as string },\n    include: { user: true },\n  });\n\n  if (!keyRecord || !keyRecord.active) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Invalid API key',\n    });\n  }\n\n  // Check rate limits\n  await checkApiKeyRateLimit(keyRecord.id);\n\n  // Log usage\n  await logApiKeyUsage(keyRecord.id, ctx.req.url);\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: keyRecord.user,\n      apiKey: keyRecord,\n    },\n  });\n});\n```\n\n### Session-Based Auth with Refresh\n\n```typescript title=\"src/session-auth.ts\"\n// Session middleware with refresh\nexport const sessionAuth = t.middleware(async ({ ctx, next }) => {\n  const sessionId = ctx.req.headers['x-session-id'] || ctx.req.cookies?.sessionId;\n\n  if (!sessionId) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Session required',\n    });\n  }\n\n  const session = await getSession(sessionId);\n\n  if (!session || session.expiresAt < new Date()) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Session expired',\n    });\n  }\n\n  // Refresh session if close to expiry\n  if (session.expiresAt.getTime() - Date.now() < 15 * 60 * 1000) { // 15 minutes\n    await refreshSession(sessionId);\n  }\n\n  const user = await getUserById(session.userId);\n  if (!user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'User not found',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user,\n      session,\n    },\n  });\n});\n```\n\n## Testing Authorization\n\n```typescript title=\"src/auth.test.ts\"\nimport { describe, it, expect } from 'vitest';\nimport { createCallerFactory } from '@trpc/server';\nimport { appRouter } from './router';\n\nconst createCaller = createCallerFactory(appRouter);\n\ndescribe('Authorization', () => {\n  describe('Public endpoints', () => {\n    it('should allow anonymous access', async () => {\n      const caller = createCaller({ user: null });\n\n      const result = await caller.hello();\n      expect(result).toBeDefined();\n    });\n  });\n\n  describe('Protected endpoints', () => {\n    it('should reject unauthenticated requests', async () => {\n      const caller = createCaller({ user: null });\n\n      await expect(caller.protected.getProfile()).rejects.toThrow('UNAUTHORIZED');\n    });\n\n    it('should allow authenticated requests', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', role: 'user' },\n      });\n\n      const result = await caller.protected.getProfile();\n      expect(result).toBeDefined();\n    });\n  });\n\n  describe('Role-based access', () => {\n    it('should allow admin access', async () => {\n      const caller = createCaller({\n        user: { id: 'admin1', role: 'admin' },\n      });\n\n      const result = await caller.admin.getSystemStats();\n      expect(result).toBeDefined();\n    });\n\n    it('should reject non-admin access', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', role: 'user' },\n      });\n\n      await expect(caller.admin.getSystemStats()).rejects.toThrow('FORBIDDEN');\n    });\n  });\n\n  describe('Resource ownership', () => {\n    it('should allow access to own resources', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', role: 'user' },\n      });\n\n      // Mock the post to be owned by user1\n      const result = await caller.posts.update({\n        postId: 'post-owned-by-user1',\n        title: 'Updated title',\n      });\n\n      expect(result).toBeDefined();\n    });\n\n    it('should reject access to others resources', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', role: 'user' },\n      });\n\n      await expect(\n        caller.posts.update({\n          postId: 'post-owned-by-user2',\n          title: 'Updated title',\n        })\n      ).rejects.toThrow('FORBIDDEN');\n    });\n  });\n});\n```\n\n## Best Practices\n\n<Accordions>\n  <Accordion title=\"Security\">\n    - **Use HTTPS**: Always use HTTPS in production\n    - **Validate tokens**: Check token expiry and signatures\n    - **Principle of least privilege**: Grant minimal necessary permissions\n    - **Audit trails**: Log authentication and authorization events\n    \n    ```typescript\n    // Secure token validation\n    const validateToken = async (token: string) => {\n      try {\n        const payload = jwt.verify(token, process.env.JWT_SECRET!);\n        \n        // Check token blacklist\n        const isBlacklisted = await isTokenBlacklisted(token);\n        if (isBlacklisted) {\n          throw new Error('Token revoked');\n        }\n        \n        return payload;\n      } catch (error) {\n        throw new TRPCError({\n          code: 'UNAUTHORIZED',\n          message: 'Invalid token',\n        });\n      }\n    };\n    ```\n  </Accordion>\n\n  <Accordion title=\"Performance\">\n    - **Cache user data**: Avoid repeated database queries\n    - **Use middleware efficiently**: Check auth early\n    - **Optimize role checks**: Use indexed database fields\n    - **Consider token lifetime**: Balance security and performance\n    \n    ```typescript\n    // Cache user data in middleware\n    const cachedAuth = t.middleware(async ({ ctx, next }) => {\n      if (ctx.user) {\n        // User already loaded in context\n        return next();\n      }\n      \n      const token = getTokenFromRequest(ctx.req);\n      const user = await getUserFromCache(token) || await getUserFromDB(token);\n      \n      return next({ ctx: { ...ctx, user } });\n    });\n    ```\n  </Accordion>\n\n  <Accordion title=\"Error Handling\">\n    - **Don't leak information**: Avoid exposing sensitive data in errors\n    - **Use consistent error codes**: Standardize error responses\n    - **Log security events**: Track failed authentication attempts\n    - **Rate limit auth attempts**: Prevent brute force attacks\n    \n    ```typescript\n    // Safe error handling\n    const safeAuth = t.middleware(async ({ ctx, next }) => {\n      try {\n        const user = await authenticateUser(ctx.req);\n        return next({ ctx: { ...ctx, user } });\n      } catch (error) {\n        // Log the real error\n        console.error('Auth error:', error);\n        \n        // Return generic error to client\n        throw new TRPCError({\n          code: 'UNAUTHORIZED',\n          message: 'Authentication failed',\n        });\n      }\n    });\n    ```\n  </Accordion>\n</Accordions>\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Middleware\" href=\"/docs/server/middlewares\">\n    Learn more about creating reusable middleware\n  </Card>\n  <Card title=\"Context\" href=\"/docs/server/context\">\n    Understand how to structure your context\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Handle authentication and authorization errors\n  </Card>\n  <Card title=\"Server-Side Calls\" href=\"/docs/server/server-side-calls\">\n    Test your authorization logic\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/caching.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/caching.mdx"},"lastModified":null,"data":{"title":"Response Caching","description":"Optimize performance with intelligent response caching strategies","icon":"IconClock","index":false},"content":"\nResponse caching is crucial for building high-performance tRPC applications. By implementing smart caching strategies, you can significantly reduce server load and improve response times for your users.\n\n<Callout type=\"warn\">\n  Always be careful with caching, especially when handling personal information.\n  Since batching is enabled by default, make sure concurrent calls don't leak\n  personal data through cache headers.\n</Callout>\n\n## Getting Started\n\nThe examples below use [Vercel's edge caching](https://vercel.com/docs/edge-network/caching) to serve data as fast as possible. The concepts apply to other CDN providers as well.\n\n## API Response Caching\n\nSince all tRPC queries are standard HTTP `GET` requests, you can use normal HTTP headers to cache responses, reduce server load, and scale your API effortlessly.\n\n### Using `responseMeta` to Cache Responses\n\nPerfect for serverless deployments that support `stale-while-revalidate` cache headers:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const t = initTRPC.context<Context>().create();\n\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // Simulate slow query\n\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n\n// Export API handler with caching\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n\n    // Check if all routes are public (contain 'public' in path)\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    // Check that no procedures errored\n    const allOk = errors.length === 0;\n    // Check we're doing a query request\n    const isQuery = type === 'query';\n\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      // Cache for 1 day + revalidate once every second\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: new Headers([\n          [\n            'cache-control',\n            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n          ],\n        ]),\n      };\n    }\n    return {};\n  },\n});\n```\n\n## Client-Side Caching\n\nEnable SSR caching for your entire application:\n\n```tsx title=\"lib/trpc.ts\"\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    if (typeof window !== 'undefined') {\n      // Client-side\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    // Server-side\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      links: [\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n\n    if (clientErrors.length) {\n      // Propagate HTTP first error from API calls\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n\n    // Cache request for 1 day + revalidate once every second\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        ],\n      ]),\n    };\n  },\n});\n```\n\n## Advanced Caching Strategies\n\n### Conditional Caching\n\nCache only specific routes or conditions:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type, data } = opts;\n\n    // Only cache specific routes\n    const cachableRoutes = ['posts.list', 'users.public', 'content.static'];\n    const isCachable = paths?.some(path =>\n      cachableRoutes.some(route => path.includes(route))\n    );\n\n    // Don't cache if there are errors or it's not a query\n    if (!isCachable || errors.length > 0 || type !== 'query') {\n      return {};\n    }\n\n    // Don't cache if user is authenticated (personal data)\n    if (ctx?.user) {\n      return {};\n    }\n\n    const ONE_HOUR = 60 * 60;\n    return {\n      headers: new Headers([\n        ['cache-control', `public, s-maxage=${ONE_HOUR}, max-age=${ONE_HOUR}`],\n      ]),\n    };\n  },\n});\n```\n\n### Dynamic Cache Duration\n\nSet different cache durations based on data type:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nfunction getCacheDuration(path: string): number {\n  // Static content - cache for 1 day\n  if (path.includes('static') || path.includes('content')) {\n    return 60 * 60 * 24;\n  }\n\n  // User posts - cache for 1 hour\n  if (path.includes('posts')) {\n    return 60 * 60;\n  }\n\n  // User data - cache for 5 minutes\n  if (path.includes('users')) {\n    return 5 * 60;\n  }\n\n  // Default - cache for 1 minute\n  return 60;\n}\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { paths, errors, type } = opts;\n\n    if (errors.length > 0 || type !== 'query' || !paths?.length) {\n      return {};\n    }\n\n    const maxAge = Math.min(...paths.map(getCacheDuration));\n\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `public, s-maxage=${maxAge}, max-age=${maxAge}, stale-while-revalidate=${maxAge * 2}`,\n        ],\n      ]),\n    };\n  },\n});\n```\n\n### Advanced Conditional Caching\n\nImplement sophisticated caching logic based on data characteristics:\n\n**1. Setup Conditional Cache**\n\n```typescript title=\"src/lib/cache.ts\"\ninterface CacheConfig {\n  duration: number;\n  condition: (data: any) => boolean;\n  key: (input: any) => string;\n}\n\nconst conditionalCache: CacheConfig[] = [\n  {\n    duration: 3600, // 1 hour for static data\n    condition: (data) => data.type === 'static',\n    key: (input) => `static:${JSON.stringify(input)}`,\n  },\n  {\n    duration: 300, // 5 minutes for user data\n    condition: (data) => data.type === 'user',\n    key: (input) => `user:${input.userId}:${input.action}`,\n  },\n  {\n    duration: 60, // 1 minute for realtime data\n    condition: (data) => data.type === 'realtime',\n    key: (input) => `realtime:${Date.now()}`,\n  },\n];\n```\n\n**2. Implement Smart Caching Middleware**\n\n```typescript title=\"src/middleware/smart-cache.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { cache } from './cache';\n\nexport const smartCacheMiddleware = t.middleware(async ({ next, input }) => {\n  const result = await next();\n\n  if (!result.ok) return result;\n\n  // Find matching cache config\n  const config = conditionalCache.find(c => c.condition(result.data));\n\n  if (config) {\n    const cacheKey = config.key(input);\n    await cache.set(cacheKey, result.data, config.duration);\n  }\n\n  return result;\n});\n```\n\n**3. Use in Procedures**\n\n```typescript title=\"src/routers/smart-cache.ts\"\nexport const smartCacheRouter = t.router({\n  getContent: t.procedure\n    .use(smartCacheMiddleware)\n    .input(z.object({\n      contentId: z.string(),\n      type: z.enum(['static', 'user', 'realtime']),\n    }))\n    .query(async ({ input }) => {\n      // Data will be cached based on type\n      return {\n        id: input.contentId,\n        type: input.type,\n        content: await fetchContent(input.contentId),\n        timestamp: new Date(),\n      };\n    }),\n});\n```\n\n## Best Practices\n\n### Use splitLink for Mixed Caching\n\nSeparate public and private requests using `splitLink`:\n\n```ts title=\"lib/trpc.ts\"\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  splitLink\n} from '@trpc/client';\n\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // Route public queries to cached endpoint\n        return op.path.includes('public') || op.path.includes('static');\n      },\n      true: httpBatchLink({\n        url: '/api/trpc/public', // Cached endpoint\n      }),\n      false: httpBatchLink({\n        url: '/api/trpc/private', // Non-cached endpoint\n      }),\n    }),\n  ],\n});\n```\n\n### Implement Cache Invalidation\n\nUse cache tags for precise invalidation:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { paths, errors, type } = opts;\n\n    if (errors.length > 0 || type !== 'query') {\n      return {};\n    }\n\n    const tags = paths?.map(path => {\n      // Generate cache tags based on route\n      if (path.includes('posts')) return 'posts';\n      if (path.includes('users')) return 'users';\n      return 'general';\n    });\n\n    return {\n      headers: new Headers([\n        ['cache-control', 'public, s-maxage=3600, max-age=3600'],\n        ['cache-tag', tags?.join(',') || ''],\n      ]),\n    };\n  },\n});\n```\n\n### Monitor Cache Performance\n\nAdd cache hit/miss logging:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, type } = opts;\n\n    // Log cache decisions\n    if (type === 'query') {\n      const cacheDecision = shouldCache(opts) ? 'HIT' : 'MISS';\n      console.log(`Cache ${cacheDecision}: ${paths?.join(', ')}`);\n    }\n\n    return getCacheHeaders(opts);\n  },\n});\n```\n\n### Handle Authentication\n\nNever cache authenticated requests:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, req } = opts;\n\n    // Never cache if there's an auth header or cookie\n    const hasAuth = req?.headers.authorization ||\n                   req?.headers.cookie?.includes('auth');\n\n    if (hasAuth || ctx?.user) {\n      return {\n        headers: new Headers([\n          ['cache-control', 'private, no-cache, must-revalidate'],\n        ]),\n      };\n    }\n\n    return getPublicCacheHeaders(opts);\n  },\n});\n```\n\n## Cache Headers Reference\n\n### Common Cache-Control Values\n\n<TypeTable\n  type={{\n    public: {\n      description: 'Response can be cached by any cache',\n      type: 'Cache Directive',\n    },\n    private: {\n      description: 'Response is intended for single user only',\n      type: 'Cache Directive',\n    },\n    'no-cache': {\n      description: 'Must revalidate with server before using cached version',\n      type: 'Cache Directive',\n    },\n    'no-store': {\n      description: 'Response should not be cached anywhere',\n      type: 'Cache Directive',\n    },\n    'max-age': {\n      description: 'Maximum age in seconds for browser cache',\n      type: 'number',\n    },\n    's-maxage': {\n      description: 'Maximum age in seconds for shared caches (CDN)',\n      type: 'number',\n    },\n    'stale-while-revalidate': {\n      description:\n        'Serve stale content while fetching fresh content in background',\n      type: 'number',\n    },\n  }}\n/>\n\n### Example Cache Strategies\n\n```ts\n// Short-term caching for dynamic content\n'public, max-age=60, s-maxage=60'\n\n// Long-term caching with background refresh\n'public, max-age=3600, s-maxage=3600, stale-while-revalidate=86400'\n\n// No caching for sensitive data\n'private, no-cache, no-store, must-revalidate'\n\n// CDN-only caching (browser always revalidates)\n'public, max-age=0, s-maxage=3600'\n```\n\n## Framework-Specific Examples\n\n### Next.js App Router\n\n```ts title=\"app/api/trpc/[trpc]/route.ts\"\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '~/server/api/root';\n\nconst handler = (req: Request) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({}),\n    responseMeta(opts) {\n      // Next.js App Router caching\n      return {\n        headers: new Headers([\n          ['cache-control', 'public, max-age=3600'],\n        ]),\n      };\n    },\n  });\n\nexport { handler as GET, handler as POST };\n```\n\n### Vercel Edge Runtime\n\n```ts title=\"api/trpc/[trpc].ts\"\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\n\nexport const config = {\n  runtime: 'edge',\n};\n\nexport default async function handler(req: Request) {\n  return fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({}),\n    responseMeta(opts) {\n      const { paths, type } = opts;\n\n      // Edge-optimized caching\n      if (type === 'query' && paths?.every(p => p.includes('public'))) {\n        return {\n          headers: new Headers([\n            ['cache-control', 'public, s-maxage=86400, max-age=3600'],\n            ['cdn-cache-control', 'public, s-maxage=31536000'],\n          ]),\n        };\n      }\n\n      return {};\n    },\n  });\n}\n```\n\n<Callout type=\"info\">\n  Remember that caching is a powerful optimization tool, but it requires careful\n  consideration of your application's data sensitivity and update patterns.\n</Callout>\n\n<Callout type=\"warn\">\n  Always be careful with caching, especially when handling personal information.\n  Since batching is enabled by default, make sure concurrent calls don't leak\n  personal data through cache headers.\n</Callout>\n\n## Getting Started\n\nThe examples below use [Vercel's edge caching](https://vercel.com/docs/edge-network/caching) to serve data as fast as possible. The concepts apply to other CDN providers as well.\n\n## API Response Caching\n\nSince all tRPC queries are standard HTTP `GET` requests, you can use normal HTTP headers to cache responses, reduce server load, and scale your API effortlessly.\n\n### Using `responseMeta` to Cache Responses\n\nPerfect for serverless deployments that support `stale-while-revalidate` cache headers:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const t = initTRPC.context<Context>().create();\n\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // Simulate slow query\n\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n\n// Export API handler with caching\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n\n    // Check if all routes are public (contain 'public' in path)\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    // Check that no procedures errored\n    const allOk = errors.length === 0;\n    // Check we're doing a query request\n    const isQuery = type === 'query';\n\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      // Cache for 1 day + revalidate once every second\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: new Headers([\n          [\n            'cache-control',\n            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n          ],\n        ]),\n      };\n    }\n    return {};\n  },\n});\n```\n\n## Client-Side Caching\n\nEnable SSR caching for your entire application:\n\n```tsx title=\"lib/trpc.ts\"\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    if (typeof window !== 'undefined') {\n      // Client-side\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    // Server-side\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      links: [\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n\n    if (clientErrors.length) {\n      // Propagate HTTP first error from API calls\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n\n    // Cache request for 1 day + revalidate once every second\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        ],\n      ]),\n    };\n  },\n});\n```\n\n## Advanced Caching Strategies\n\n### Conditional Caching\n\nCache only specific routes or conditions:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type, data } = opts;\n\n    // Only cache specific routes\n    const cachableRoutes = ['posts.list', 'users.public', 'content.static'];\n    const isCachable = paths?.some(path =>\n      cachableRoutes.some(route => path.includes(route))\n    );\n\n    // Don't cache if there are errors or it's not a query\n    if (!isCachable || errors.length > 0 || type !== 'query') {\n      return {};\n    }\n\n    // Don't cache if user is authenticated (personal data)\n    if (ctx?.user) {\n      return {};\n    }\n\n    const ONE_HOUR = 60 * 60;\n    return {\n      headers: new Headers([\n        ['cache-control', `public, s-maxage=${ONE_HOUR}, max-age=${ONE_HOUR}`],\n      ]),\n    };\n  },\n});\n```\n\n### Dynamic Cache Duration\n\nSet different cache durations based on data type:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nfunction getCacheDuration(path: string): number {\n  // Static content - cache for 1 day\n  if (path.includes('static') || path.includes('content')) {\n    return 60 * 60 * 24;\n  }\n\n  // User posts - cache for 1 hour\n  if (path.includes('posts')) {\n    return 60 * 60;\n  }\n\n  // User data - cache for 5 minutes\n  if (path.includes('users')) {\n    return 5 * 60;\n  }\n\n  // Default - cache for 1 minute\n  return 60;\n}\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { paths, errors, type } = opts;\n\n    if (errors.length > 0 || type !== 'query' || !paths?.length) {\n      return {};\n    }\n\n    const maxAge = Math.min(...paths.map(getCacheDuration));\n\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `public, s-maxage=${maxAge}, max-age=${maxAge}, stale-while-revalidate=${maxAge * 2}`,\n        ],\n      ]),\n    };\n  },\n});\n```\n\n### Advanced Conditional Caching\n\nImplement sophisticated caching logic based on data characteristics:\n\n**1. Setup Conditional Cache**\n\n```typescript title=\"src/lib/cache.ts\"\ninterface CacheConfig {\n  duration: number;\n  condition: (data: any) => boolean;\n  key: (input: any) => string;\n}\n\nconst conditionalCache: CacheConfig[] = [\n  {\n    duration: 3600, // 1 hour for static data\n    condition: (data) => data.type === 'static',\n    key: (input) => `static:${JSON.stringify(input)}`,\n  },\n  {\n    duration: 300, // 5 minutes for user data\n    condition: (data) => data.type === 'user',\n    key: (input) => `user:${input.userId}:${input.action}`,\n  },\n  {\n    duration: 60, // 1 minute for realtime data\n    condition: (data) => data.type === 'realtime',\n    key: (input) => `realtime:${Date.now()}`,\n  },\n];\n```\n\n**2. Implement Smart Caching Middleware**\n\n```typescript title=\"src/middleware/smart-cache.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { cache } from './cache';\n\nexport const smartCacheMiddleware = t.middleware(async ({ next, input }) => {\n  const result = await next();\n\n  if (!result.ok) return result;\n\n  // Find matching cache config\n  const config = conditionalCache.find(c => c.condition(result.data));\n\n  if (config) {\n    const cacheKey = config.key(input);\n    await cache.set(cacheKey, result.data, config.duration);\n  }\n\n  return result;\n});\n```\n\n**3. Use in Procedures**\n\n```typescript title=\"src/routers/smart-cache.ts\"\nexport const smartCacheRouter = t.router({\n  getContent: t.procedure\n    .use(smartCacheMiddleware)\n    .input(z.object({\n      contentId: z.string(),\n      type: z.enum(['static', 'user', 'realtime']),\n    }))\n    .query(async ({ input }) => {\n      // Data will be cached based on type\n      return {\n        id: input.contentId,\n        type: input.type,\n        content: await fetchContent(input.contentId),\n        timestamp: new Date(),\n      };\n    }),\n});\n```\n\n## Best Practices\n\n<Steps>\n\n### Use splitLink for Mixed Caching\n\nSeparate public and private requests using `splitLink`:\n\n```ts title=\"lib/trpc.ts\"\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  splitLink\n} from '@trpc/client';\n\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // Route public queries to cached endpoint\n        return op.path.includes('public') || op.path.includes('static');\n      },\n      true: httpBatchLink({\n        url: '/api/trpc/public', // Cached endpoint\n      }),\n      false: httpBatchLink({\n        url: '/api/trpc/private', // Non-cached endpoint\n      }),\n    }),\n  ],\n});\n```\n\n### Implement Cache Invalidation\n\nUse cache tags for precise invalidation:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { paths, errors, type } = opts;\n\n    if (errors.length > 0 || type !== 'query') {\n      return {};\n    }\n\n    const tags = paths?.map(path => {\n      // Generate cache tags based on route\n      if (path.includes('posts')) return 'posts';\n      if (path.includes('users')) return 'users';\n      return 'general';\n    });\n\n    return {\n      headers: new Headers([\n        ['cache-control', 'public, s-maxage=3600, max-age=3600'],\n        ['cache-tag', tags?.join(',') || ''],\n      ]),\n    };\n  },\n});\n```\n\n### Monitor Cache Performance\n\nAdd cache hit/miss logging:\n\n```ts title=\"server/api/trpc/[trpc].ts\"\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, type } = opts;\n\n    // Log cache decisions\n    if (type === 'query') {\n      const cacheDecision = shouldCache(opts) ? 'HIT' : 'MISS';\n      console.log(`Cache ${cacheDecision}: ${paths?.join(', ')}`);\n    }\n\n    return getCacheHeaders(opts);\n  },\n});\n```\n"}, {"info":{"path":"server/context.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/context.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Context","description":"Share request-scoped data across all tRPC procedures","icon":"IconSettings","index":false},"content":"\nContext holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections, authentication information, and request metadata. Setting up context is done in two steps: defining the type during initialization and creating the runtime context for each request.\n\n<Callout title=\"Request-Scoped Data\">\n  Context is created for each request, allowing you to include request-specific\n  data like user sessions, request headers, and database connections.\n</Callout>\n\n## Basic Context Setup\n\n### 1. Define Context Type\n\nWhen initializing tRPC, use `.context<TContext>()` to define your context type:\n\n```typescript title=\"server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getServerSession } from 'next-auth';\n\n// Define the context creation function\nexport const createContext = async (opts: CreateNextContextOptions) => {\n  const session = await getServerSession(opts.req, opts.res, authOptions);\n\n  return {\n    session,\n    req: opts.req,\n    res: opts.res,\n  };\n};\n\n// Infer the context type\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n\n// Initialize tRPC with context type\nconst t = initTRPC.context<Context>().create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Use Context in Procedures\n\nAccess context data in your procedures:\n\n```typescript title=\"server/router.ts\"\nexport const appRouter = router({\n  getProfile: publicProcedure.query(({ ctx }) => {\n    // Access session from context\n    if (!ctx.session?.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return {\n      user: ctx.session.user,\n      requestUrl: ctx.req.url,\n    };\n  }),\n\n  updateProfile: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(({ input, ctx }) => {\n      // Use context data in mutations\n      console.log(`User ${ctx.session?.user?.id} updating profile`);\n\n      return updateUserProfile(ctx.session.user.id, input);\n    }),\n});\n```\n\n## Context Creation Patterns\n\n### Database Integration\n\nInclude database connections in context:\n\n```typescript title=\"server/context.ts\"\nimport { PrismaClient } from '@prisma/client';\nimport type { CreateExpressContextOptions } from '@trpc/server/adapters/express';\n\n// Create Prisma client (ideally as a singleton)\nconst prisma = new PrismaClient();\n\nexport const createContext = ({ req, res }: CreateExpressContextOptions) => {\n  return {\n    req,\n    res,\n    prisma, // Available in all procedures\n  };\n};\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n### Authentication Context\n\nAdd user authentication to context:\n\n```typescript title=\"server/auth-context.ts\"\nimport jwt from 'jsonwebtoken';\nimport type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';\n\ninterface User {\n  id: string;\n  email: string;\n  role: 'user' | 'admin';\n}\n\nexport const createContext = async ({ req }: CreateHTTPContextOptions) => {\n  // Extract token from Authorization header\n  const token = req.headers.authorization?.replace('Bearer ', '');\n\n  let user: User | null = null;\n\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n      user = await getUserById(decoded.userId);\n    } catch (error) {\n      // Invalid token - user remains null\n      console.log('Invalid token:', error.message);\n    }\n  }\n\n  return {\n    req,\n    user,\n    isAuthenticated: !!user,\n  };\n};\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n### Request Metadata\n\nInclude useful request information:\n\n```typescript title=\"server/metadata-context.ts\"\nexport const createContext = ({ req, res }: CreateExpressContextOptions) => {\n  return {\n    req,\n    res,\n    // Request metadata\n    userAgent: req.headers['user-agent'],\n    ip: req.ip || req.connection.remoteAddress,\n    origin: req.headers.origin,\n\n    // Timing\n    requestStartTime: Date.now(),\n\n    // Custom headers\n    traceId: req.headers['x-trace-id'] || generateTraceId(),\n  };\n};\n```\n\n## Advanced Context Patterns\n\n### Inner and Outer Context\n\nSplit context into inner (always available) and outer (request-dependent) parts:\n\n```typescript title=\"server/inner-outer-context.ts\"\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getServerSession, type Session } from 'next-auth';\n\n// Inner context - always available (useful for testing and SSR helpers)\ninterface CreateInnerContextOptions {\n  session: Session | null;\n}\n\nexport async function createContextInner(opts: CreateInnerContextOptions) {\n  return {\n    session: opts.session,\n    prisma, // Database connection\n    // Add other services that don't depend on the request\n  };\n}\n\n// Outer context - request-dependent\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = await getServerSession(opts.req, opts.res, authOptions);\n\n  const contextInner = await createContextInner({ session });\n\n  return {\n    ...contextInner,\n    req: opts.req,\n    res: opts.res,\n    // Request-specific data\n  };\n}\n\n// Always infer from inner context for consistency\nexport type Context = Awaited<ReturnType<typeof createContextInner>>;\n```\n\n### Environment-Based Context\n\nCreate different contexts for different environments:\n\n```typescript title=\"server/env-context.ts\"\nconst isDev = process.env.NODE_ENV === 'development';\nconst isProd = process.env.NODE_ENV === 'production';\n\nexport const createContext = ({ req, res }: CreateExpressContextOptions) => {\n  const baseContext = {\n    req,\n    res,\n    prisma,\n  };\n\n  if (isDev) {\n    return {\n      ...baseContext,\n      // Development-only context\n      debug: true,\n      mockUser: process.env.MOCK_USER_ID ?\n        { id: process.env.MOCK_USER_ID, role: 'admin' } : null,\n    };\n  }\n\n  if (isProd) {\n    return {\n      ...baseContext,\n      // Production-only context\n      analytics: analyticsClient,\n      monitoring: monitoringClient,\n    };\n  }\n\n  return baseContext;\n};\n```\n\n### Multi-Tenant Context\n\nHandle multi-tenant applications:\n\n```typescript title=\"server/tenant-context.ts\"\nexport const createContext = async ({ req, res }: CreateExpressContextOptions) => {\n  // Extract tenant from subdomain or header\n  const host = req.headers.host || '';\n  const subdomain = host.split('.')[0];\n\n  // Or from custom header\n  const tenantId = req.headers['x-tenant-id'] || subdomain;\n\n  // Load tenant configuration\n  const tenant = await getTenantConfig(tenantId);\n\n  if (!tenant) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: 'Tenant not found',\n    });\n  }\n\n  // Create tenant-specific database connection\n  const tenantDb = createTenantDatabase(tenant.databaseUrl);\n\n  return {\n    req,\n    res,\n    tenant,\n    db: tenantDb,\n    tenantId,\n  };\n};\n```\n\n## Context with Different Adapters\n\n### Next.js App Router\n\n```typescript title=\"app/api/trpc/[trpc]/context.ts\"\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\n\nexport async function createContext(opts: CreateNextContextOptions) {\n  return {\n    req: opts.req,\n    res: opts.res,\n    // Next.js specific\n    cookies: opts.req.cookies,\n    headers: opts.req.headers,\n  };\n}\n```\n\n### Cloudflare Workers\n\n```typescript title=\"worker/context.ts\"\nimport type { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch';\n\ninterface Env {\n  KV_NAMESPACE: KVNamespace;\n  DATABASE_URL: string;\n}\n\nexport function createContext(\n  { req, resHeaders }: FetchCreateContextFnOptions,\n  env: Env\n) {\n  return {\n    req,\n    resHeaders,\n    env,\n    kv: env.KV_NAMESPACE,\n    // Worker-specific context\n  };\n}\n```\n\n### AWS Lambda\n\n```typescript title=\"lambda/context.ts\"\nimport type {\n  CreateAWSLambdaContextOptions\n} from '@trpc/server/adapters/aws-lambda';\nimport type { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nexport const createContext = ({\n  event,\n  context\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => {\n  return {\n    event,\n    context,\n    // Lambda-specific data\n    requestId: event.requestContext.requestId,\n    userAgent: event.headers['user-agent'],\n    sourceIp: event.requestContext.http.sourceIp,\n  };\n};\n```\n\n## Context in Middleware\n\nUse context to create reusable middleware:\n\n```typescript title=\"server/middleware.ts\"\n// Authentication middleware using context\nexport const requireAuth = t.middleware(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.user, // Now guaranteed to be non-null\n    },\n  });\n});\n\n// Role-based middleware\nexport const requireRole = (role: string) =>\n  t.middleware(({ ctx, next }) => {\n    if (!ctx.user || ctx.user.role !== role) {\n      throw new TRPCError({ code: 'FORBIDDEN' });\n    }\n\n    return next();\n  });\n\n// Logging middleware using context\nexport const withLogging = t.middleware(({ ctx, path, type, next }) => {\n  const start = Date.now();\n\n  console.log(`${type.toUpperCase()} ${path} - User: ${ctx.user?.id || 'anonymous'}`);\n\n  return next().then((result) => {\n    const duration = Date.now() - start;\n    console.log(`Completed in ${duration}ms`);\n    return result;\n  });\n});\n```\n\n## Context Extensions\n\nExtend context in middleware for specific use cases:\n\n```typescript title=\"server/context-extensions.ts\"\n// Organization context middleware\nexport const withOrganization = t.middleware(async ({ ctx, input, next }) => {\n  const organizationId = (input as any)?.organizationId;\n\n  if (!organizationId) {\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Organization ID required',\n    });\n  }\n\n  const organization = await ctx.prisma.organization.findUnique({\n    where: { id: organizationId },\n  });\n\n  if (!organization) {\n    throw new TRPCError({ code: 'NOT_FOUND' });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      organization, // Add organization to context\n    },\n  });\n});\n\n// Rate limiting context\nexport const withRateLimit = (limit: number, windowMs: number) =>\n  t.middleware(async ({ ctx, next }) => {\n    const identifier = ctx.user?.id || ctx.ip || 'anonymous';\n\n    const isAllowed = await rateLimiter.check(identifier, limit, windowMs);\n\n    if (!isAllowed) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Rate limit exceeded',\n      });\n    }\n\n    return next();\n  });\n```\n\n## Testing with Context\n\nCreate mock contexts for testing:\n\n```typescript title=\"server/test-context.ts\"\nimport { createCallerFactory } from '@trpc/server';\nimport type { Context } from './context';\n\n// Create mock context for testing\nexport const createMockContext = (overrides: Partial<Context> = {}): Context => {\n  return {\n    req: {} as any,\n    res: {} as any,\n    prisma: mockPrisma,\n    user: null,\n    ...overrides,\n  };\n};\n\n// Test with authenticated user\nconst mockAuthContext = createMockContext({\n  user: { id: 'user1', email: 'test@example.com', role: 'user' },\n});\n\nconst createCaller = createCallerFactory(appRouter);\nconst caller = createCaller(mockAuthContext);\n\n// Use in tests\ndescribe('User Router', () => {\n  it('should get user profile', async () => {\n    const profile = await caller.user.getProfile();\n    expect(profile.user.id).toBe('user1');\n  });\n});\n```\n\n## Context Best Practices\n\n<Accordions>\n  <Accordion title=\"Performance Considerations\">\n    - Avoid expensive operations in context creation\n    - Reuse database connections across requests\n    - Cache frequently accessed data\n    - Use connection pooling for databases\n    \n    ```typescript\n    // Good: Reuse connection\n    const prisma = new PrismaClient();\n    \n    export const createContext = () => ({\n      prisma, // Reused across requests\n    });\n    \n    // Bad: New connection per request\n    export const createContext = () => ({\n      prisma: new PrismaClient(), // Creates new connection each time\n    });\n    ```\n  </Accordion>\n  \n  <Accordion title=\"Security\">\n    - Validate authentication tokens in context\n    - Don't expose sensitive data unnecessarily  \n    - Use least privilege principle\n    - Sanitize user inputs early\n    \n    ```typescript\n    export const createContext = async ({ req }) => {\n      const user = await validateAuthToken(req.headers.authorization);\n      \n      return {\n        // Only expose what's needed\n        user: user ? { \n          id: user.id, \n          role: user.role \n        } : null,\n        // Don't expose: passwords, tokens, etc.\n      };\n    };\n    ```\n  </Accordion>\n  \n  <Accordion title=\"Type Safety\">\n    - Always type your context properly\n    - Use inner/outer context pattern for complex apps\n    - Make authentication status clear in types\n    - Use discriminated unions for different user types\n    \n    ```typescript\n    type Context = {\n      prisma: PrismaClient;\n    } & (\n      | { user: User; isAuthenticated: true }\n      | { user: null; isAuthenticated: false }\n    );\n    ```\n  </Accordion>\n</Accordions>\n\n## Error Handling in Context\n\nHandle errors gracefully during context creation:\n\n```typescript title=\"server/error-context.ts\"\nexport const createContext = async ({ req, res }: CreateExpressContextOptions) => {\n  try {\n    // Attempt to get user session\n    const session = await getSession({ req });\n\n    return {\n      req,\n      res,\n      session,\n      user: session?.user || null,\n    };\n  } catch (error) {\n    // Log error but don't fail - return anonymous context\n    console.error('Failed to create authenticated context:', error);\n\n    return {\n      req,\n      res,\n      session: null,\n      user: null,\n    };\n  }\n};\n```\n\n## Context with Batch Requests\n\nHandle batched requests properly:\n\n```typescript title=\"server/batch-context.ts\"\nexport const createContext = ({ req, res }: CreateExpressContextOptions) => {\n  return {\n    req,\n    res,\n    // Batch-aware context\n    isBatch: Array.isArray(req.body),\n    batchSize: Array.isArray(req.body) ? req.body.length : 1,\n  };\n};\n\n// Limit batch size in context\nexport const createContextWithBatchLimit = ({ req, res, info }: CreateHTTPContextOptions) => {\n  const MAX_BATCH_SIZE = 10;\n\n  if (info.calls.length > MAX_BATCH_SIZE) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: `Batch size limit of ${MAX_BATCH_SIZE} exceeded`,\n    });\n  }\n\n  return {\n    req,\n    res,\n    batchSize: info.calls.length,\n  };\n};\n```\n\n## Next Steps\n\n<Cards>\n  <Card href=\"/docs/server/middlewares\" title=\"Middleware\">\n    Learn how to create reusable middleware with context\n  </Card>\n  <Card href=\"/docs/server/procedures\" title=\"Procedures\">\n    See how to use context in your procedures\n  </Card>\n  <Card href=\"/docs/server/error-handling\" title=\"Error Handling\">\n    Handle errors that occur during context creation\n  </Card>\n  <Card href=\"/docs/server/authorization\" title=\"Authorization\">\n    Implement authentication and authorization with context\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/data-transformers.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/data-transformers.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Data Transformers","description":"Serialize complex JavaScript types across the client-server boundary","icon":"IconArrowsRightLeft","index":false},"content":"\nData transformers in tRPC allow you to serialize complex JavaScript types like `Date`, `Map`, `Set`, `BigInt`, and others across the client-server boundary. Without transformers, only JSON-serializable data can be sent.\n\n<Callout type=\"info\">\n  All transformers must be configured on both client and server to work\n  properly. The same transformer instance should be used in both places.\n</Callout>\n\n## Overview\n\ntRPC supports these data transformers:\n\n- **SuperJSON** - Most popular, handles many JS types out of the box\n- **Devalue** - Smaller, faster, handles circular references\n- **Custom** - Build your own for specific needs\n\n## SuperJSON (Recommended)\n\nSuperJSON is the most popular choice as it handles many JavaScript types out of the box:\n\n### Installation and Setup\n\n**1. Install SuperJSON**\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n\n```bash tab=\"npm\"\nnpm install superjson\n```\n\n```bash tab=\"pnpm\"\npnpm add superjson\n```\n\n```bash tab=\"yarn\"\nyarn add superjson\n```\n\n```bash tab=\"bun\"\nbun add superjson\n```\n\n</Tabs>\n\n**2. Add to Server**\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\n\nconst t = initTRPC.create({\n  transformer: superjson,\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n**3. Add to Client**\n\n```typescript title=\"src/client.ts\"\nimport { createTRPCClient } from '@trpc/client';\nimport { httpBatchLink } from '@trpc/client';\nimport superjson from 'superjson';\nimport type { AppRouter } from './server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n      transformer: superjson,\n    }),\n  ],\n});\n```\n\n### Usage with Rich Types\n\nOnce configured, you can use rich JavaScript types seamlessly:\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  // Using Date objects\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string(),\n      publishDate: z.date(),\n    }))\n    .mutation(({ input }) => {\n      return {\n        id: '1',\n        title: input.title,\n        publishDate: input.publishDate, // Date object\n        createdAt: new Date(),          // Date object\n      };\n    }),\n\n  // Using Map and Set\n  getUserStats: publicProcedure\n    .query(() => {\n      return {\n        visitsByDay: new Map([\n          ['2024-01-01', 100],\n          ['2024-01-02', 150],\n        ]),\n        uniqueVisitors: new Set(['user1', 'user2', 'user3']),\n        lastUpdated: new Date(),\n      };\n    }),\n\n  // Using BigInt\n  getFinancialData: publicProcedure\n    .query(() => {\n      return {\n        totalRevenue: BigInt('9007199254740991000'),\n        transactionCount: 1000n,\n        lastCalculated: new Date(),\n      };\n    }),\n});\n```\n\nClient usage remains type-safe:\n\n```typescript title=\"client.ts\"\n// All types are automatically preserved\nconst post = await client.createPost.mutate({\n  title: 'My Post',\n  publishDate: new Date('2024-12-25'), // Date object\n});\n\nconsole.log(post.createdAt instanceof Date); // true\n\nconst stats = await client.getUserStats.query();\nconsole.log(stats.visitsByDay instanceof Map);    // true\nconsole.log(stats.uniqueVisitors instanceof Set); // true\nconsole.log(typeof stats.totalRevenue);           // bigint\n```\n\n## Advanced Transformers\n\n### Custom Transformers\n\nCreate custom transformers for specific needs:\n\n```typescript title=\"src/custom-transformer.ts\"\nimport type { DataTransformer } from '@trpc/server';\n\n// Custom transformer for performance optimization\nexport const customTransformer: DataTransformer = {\n  serialize: (value) => {\n    // Custom serialization logic\n    if (value instanceof Date) {\n      return { __type: 'Date', value: value.toISOString() };\n    }\n    if (value instanceof Map) {\n      return { __type: 'Map', value: Array.from(value.entries()) };\n    }\n    return value;\n  },\n\n  deserialize: (value) => {\n    // Custom deserialization logic\n    if (value && typeof value === 'object' && '__type' in value) {\n      switch (value.__type) {\n        case 'Date':\n          return new Date(value.value);\n        case 'Map':\n          return new Map(value.value);\n      }\n    }\n    return value;\n  },\n};\n```\n\n### Devalue Transformer\n\nFor smaller payloads and better performance:\n\n**1. Install Devalue**\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n\n```bash tab=\"npm\"\nnpm install devalue\n```\n\n```bash tab=\"pnpm\"\npnpm add devalue\n```\n\n```bash tab=\"yarn\"\nyarn add devalue\n```\n\n```bash tab=\"bun\"\nbun add devalue\n```\n\n</Tabs>\n\n**2. Create Transformer**\n\n```typescript title=\"src/devalue-transformer.ts\"\nimport { parse, stringify } from 'devalue';\nimport type { DataTransformer } from '@trpc/server';\n\nexport const devalueTransformer: DataTransformer = {\n  serialize: (value) => stringify(value),\n  deserialize: (value) => parse(value),\n};\n```\n\n**3. Use in tRPC**\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { devalueTransformer } from './devalue-transformer';\n\nconst t = initTRPC.create({\n  transformer: devalueTransformer,\n});\n```\n\n## Input vs Output Transformers\n\nUse different transformers for input and output when needed:\n\n```typescript title=\"src/directional-transformers.ts\"\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\nimport { parse, stringify } from 'devalue';\n\nconst t = initTRPC.create({\n  transformer: {\n    // Use devalue for inputs (smaller, faster)\n    input: {\n      serialize: stringify,\n      deserialize: parse,\n    },\n    // Use superjson for outputs (more feature-rich)\n    output: superjson,\n  },\n});\n```\n\n## Supported Types\n\n<Tabs items={['Primitives', 'Built-ins', 'Complex Types']}>\n\n```typescript tab=\"Primitives\"\n// Basic JavaScript primitives work without transformers\nconst router = t.router({\n  example: t.procedure.query(() => ({\n    string: 'hello',\n    number: 42,\n    boolean: true,\n    null: null,\n    undefined: undefined,\n    array: [1, 2, 3],\n    object: { key: 'value' },\n  })),\n});\n```\n\n```typescript tab=\"Built-ins\"\n// Built-in JavaScript objects require transformers\nconst router = t.router({\n  richTypes: t.procedure.query(() => ({\n    date: new Date(),\n    regexp: /hello/gi,\n    map: new Map([['key', 'value']]),\n    set: new Set([1, 2, 3]),\n    bigint: BigInt('123456789'),\n    error: new Error('Something went wrong'),\n  })),\n});\n```\n\n```typescript tab=\"Complex Types\"\n// Complex nested structures and circular references\nclass User {\n  constructor(public name: string, public friends: User[] = []) {}\n}\n\nconst router = t.router({\n  complexData: t.procedure.query(() => {\n    const user1 = new User('Alice');\n    const user2 = new User('Bob');\n\n    // Circular reference\n    user1.friends.push(user2);\n    user2.friends.push(user1);\n\n    return {\n      users: [user1, user2],\n      metadata: {\n        createdAt: new Date(),\n        tags: new Set(['social', 'networking']),\n        stats: new Map([\n          ['totalUsers', 2],\n          ['connections', 2],\n        ]),\n      },\n    };\n  }),\n});\n```\n\n</Tabs>\n\n## Alternative Transformers\n\n### Popular Third-Party Options\n\n<Tabs items={['Yup', 'Valibot', 'ArkType', 'Effect']}>\n\n```typescript tab=\"Yup\"\n// Using Yup for validation and transformation\nimport * as yup from 'yup';\n\nconst transformSchema = yup.object({\n  serialize: yup.mixed().required(),\n  deserialize: yup.mixed().required(),\n});\n\nconst yupTransformer = {\n  serialize: (value: unknown) => {\n    return JSON.stringify(value);\n  },\n  deserialize: (value: string) => {\n    return JSON.parse(value);\n  },\n};\n```\n\n```typescript tab=\"Valibot\"\n// Using Valibot for schema validation\nimport * as v from 'valibot';\n\nconst TransformSchema = v.object({\n  serialize: v.function(),\n  deserialize: v.function(),\n});\n\nconst valibotTransformer = {\n  serialize: (value: unknown) => {\n    return v.parse(v.string(), JSON.stringify(value));\n  },\n  deserialize: (value: string) => {\n    return JSON.parse(value);\n  },\n};\n```\n\n```typescript tab=\"ArkType\"\n// Using ArkType for runtime validation\nimport { type } from 'arktype';\n\nconst TransformType = type({\n  serialize: 'Function',\n  deserialize: 'Function',\n});\n\nconst arkTransformer = {\n  serialize: (value: unknown) => {\n    return JSON.stringify(value);\n  },\n  deserialize: (value: string) => {\n    return JSON.parse(value);\n  },\n};\n```\n\n```typescript tab=\"Effect\"\n// Using Effect for functional programming approach\nimport { Effect, pipe } from 'effect';\n\nconst effectTransformer = {\n  serialize: (value: unknown) => {\n    return pipe(\n      Effect.try(() => JSON.stringify(value)),\n      Effect.getOrElse(() => '{}')\n    );\n  },\n  deserialize: (value: string) => {\n    return pipe(\n      Effect.try(() => JSON.parse(value)),\n      Effect.getOrElse(() => ({}))\n    );\n  },\n};\n```\n\n</Tabs>\n\n## Performance Considerations\n\n### Benchmark Results\n\nDifferent transformers have different performance characteristics:\n\n| Transformer | Serialize | Deserialize | Bundle Size | Features          |\n| ----------- | --------- | ----------- | ----------- | ----------------- |\n| None (JSON) | 100%      | 100%        | 0KB         | Basic types only  |\n| SuperJSON   | 85%       | 90%         | 25KB        | Most JS types     |\n| Devalue     | 95%       | 95%         | 8KB         | Smaller, faster   |\n| Custom      | Varies    | Varies      | Varies      | Tailored to needs |\n\n### Optimization Tips\n\n**1. Use Conditional Transformation**\n\nOnly transform when necessary:\n\n```typescript\nconst conditionalTransformer = {\n  serialize: (value: unknown) => {\n    // Only transform if needed\n    if (needsTransformation(value)) {\n      return superjson.serialize(value);\n    }\n    return value;\n  },\n  deserialize: (value: unknown) => {\n    if (isTransformed(value)) {\n      return superjson.deserialize(value);\n    }\n    return value;\n  },\n};\n```\n\n**2. Lazy Loading**\n\nLoad transformers only when needed:\n\n```typescript\nconst lazyTransformer = {\n  serialize: async (value: unknown) => {\n    const { default: superjson } = await import('superjson');\n    return superjson.serialize(value);\n  },\n  deserialize: async (value: unknown) => {\n    const { default: superjson } = await import('superjson');\n    return superjson.deserialize(value);\n  },\n};\n```\n\n**3. Caching**\n\nCache transformation results for repeated data:\n\n```typescript\nconst cache = new Map();\n\nconst cachedTransformer = {\n  serialize: (value: unknown) => {\n    const key = JSON.stringify(value);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = superjson.serialize(value);\n    cache.set(key, result);\n    return result;\n  },\n  deserialize: (value: unknown) => {\n    // Similar caching logic for deserialization\n    return superjson.deserialize(value);\n  },\n};\n```\n\n## Best Practices\n\n### Development vs Production\n\nUse different strategies for different environments:\n\n```typescript title=\"src/transformer.ts\"\nimport superjson from 'superjson';\nimport { devalueTransformer } from './devalue-transformer';\n\nexport const transformer = process.env.NODE_ENV === 'production'\n  ? devalueTransformer // Smaller bundle, better performance\n  : superjson;         // Better DX, more features\n```\n\n### Type Safety\n\nEnsure type safety across transformations:\n\n```typescript\nimport type { DataTransformer } from '@trpc/server';\n\n// Type-safe transformer interface\ninterface TypedTransformer<T> extends DataTransformer {\n  serialize(object: T): string;\n  deserialize(object: string): T;\n}\n\nconst dateTransformer: TypedTransformer<Date> = {\n  serialize: (date: Date) => date.toISOString(),\n  deserialize: (str: string) => new Date(str),\n};\n```\n\n### Error Handling\n\nHandle transformation errors gracefully:\n\n```typescript\nconst safeTransformer = {\n  serialize: (value: unknown) => {\n    try {\n      return superjson.serialize(value);\n    } catch (error) {\n      console.error('Serialization failed:', error);\n      return JSON.stringify(value); // Fallback\n    }\n  },\n  deserialize: (value: unknown) => {\n    try {\n      return superjson.deserialize(value);\n    } catch (error) {\n      console.error('Deserialization failed:', error);\n      return value; // Return as-is\n    }\n  },\n};\n```\n\n## Common Issues\n\n### Circular References\n\nHandle circular references properly:\n\n```typescript\n// This will cause issues without proper transformer\nconst circular = { name: 'test' };\ncircular.self = circular;\n\n// Use devalue or custom transformer for circular refs\nconst devalueTransformer = {\n  serialize: stringify, // Handles circular refs\n  deserialize: parse,\n};\n```\n\n### Large Objects\n\nOptimize for large data sets:\n\n```typescript\nconst optimizedTransformer = {\n  serialize: (value: unknown) => {\n    // Stream large objects\n    if (isLargeObject(value)) {\n      return streamSerialize(value);\n    }\n    return superjson.serialize(value);\n  },\n  deserialize: (value: unknown) => {\n    if (isStreamedData(value)) {\n      return streamDeserialize(value);\n    }\n    return superjson.deserialize(value);\n  },\n};\n```\n\n<Callout type=\"info\">\n  Choose the transformer that best fits your needs. SuperJSON for most use\n  cases, Devalue for performance-critical applications, or custom transformers\n  for specific requirements.\n</Callout>\n"}, {"info":{"path":"server/error-formatting.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/error-formatting.mdx"},"lastModified":null,"data":{"title":"Error Formatting","description":"Customize how errors are formatted and sent to the client","icon":"IconAlertTriangle","index":false},"content":"\nThe error formatting in your router will be inferred all the way to your client (&&nbsp;React&nbsp;components), giving you end-to-end type safety for error handling.\n\n## Usage Example\n\n### Adding Custom Formatting\n\nYou can customize how errors are formatted by adding an `errorFormatter` to your tRPC initialization:\n\n```ts title=\"server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\n```\n\n### Usage in React\n\nWith custom error formatting, you get full type inference on the client:\n\n```tsx title=\"components/MyComponent.tsx\"\nexport function MyComponent() {\n  const mutation = trpc.addPost.useMutation();\n\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred and fully typed\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\n```\n\n## Error Formatter Properties\n\nThe `errorFormatter` function receives an object with all the information about the error:\n\n<TypeTable\n  type={{\n    error: {\n      description: 'The TRPCError that was thrown',\n      type: 'TRPCError',\n    },\n    type: {\n      description: 'The type of procedure that threw the error',\n      type: 'ProcedureType | \"unknown\"',\n    },\n    path: {\n      description: 'Path to the procedure that threw the error',\n      type: 'string | undefined',\n    },\n    input: {\n      description: 'The input that was passed to the procedure',\n      type: 'unknown',\n    },\n    ctx: {\n      description: 'The context for the request',\n      type: 'TContext | undefined',\n    },\n    shape: {\n      description: 'The default error shape',\n      type: 'DefaultErrorShape',\n    },\n  }}\n/>\n\n## Default Error Shape\n\nSince tRPC v8.x, we comply with [JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification:\n\n```ts\ntype DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\n\ninterface DefaultErrorShape {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n  data: DefaultErrorData;\n}\n```\n\n<Callout type=\"info\">\n  The stack trace is only included in development environments for security\n  reasons.\n</Callout>\n\n## Advanced Error Formatting\n\n### Multiple Error Types\n\nYou can handle different error types in your formatter:\n\n```ts title=\"server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n\n    let formattedError = {\n      ...shape,\n      data: {\n        ...shape.data,\n      },\n    };\n\n    // Handle Zod validation errors\n    if (error.code === 'BAD_REQUEST' && error.cause instanceof ZodError) {\n      formattedError.data.zodError = error.cause.flatten();\n    }\n\n    // Handle custom application errors\n    if (error.cause instanceof CustomApplicationError) {\n      formattedError.data.customError = {\n        type: error.cause.type,\n        details: error.cause.details,\n      };\n    }\n\n    return formattedError;\n  },\n});\n```\n\n### Advanced Context-Aware Formatting\n\nCreate sophisticated error formatting based on request context:\n\n**1. Define Context-Aware Formatter**\n\n```typescript title=\"src/lib/error-formatter.ts\"\nimport { TRPCError } from '@trpc/server';\nimport type { DefaultErrorShape } from '@trpc/server';\n\ninterface ErrorContext {\n  userId?: string;\n  userRole?: string;\n  requestId: string;\n  clientVersion?: string;\n}\n\nexport const contextAwareFormatter = ({\n  error,\n  type,\n  path,\n  input,\n  ctx\n}: {\n  error: TRPCError;\n  type: 'query' | 'mutation' | 'subscription' | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: ErrorContext;\n}): DefaultErrorShape => {\n  const isProduction = process.env.NODE_ENV === 'production';\n  const isDeveloper = ctx.userRole === 'developer';\n\n  // Base error shape\n  const baseError = {\n    message: error.message,\n    code: error.code as any,\n    data: {\n      code: error.code,\n      httpStatus: getHTTPStatusCodeFromError(error),\n      path,\n      requestId: ctx.requestId,\n    },\n  };\n\n  // Add debug info for developers or non-production\n  if (!isProduction || isDeveloper) {\n    baseError.data = {\n      ...baseError.data,\n      stack: error.stack,\n      input: JSON.stringify(input),\n      cause: error.cause,\n    };\n  }\n\n  // Customize by user role\n  if (ctx.userRole === 'admin') {\n    baseError.data.adminDetails = {\n      userId: ctx.userId,\n      timestamp: new Date().toISOString(),\n      serverVersion: process.env.VERSION,\n    };\n  }\n\n  return baseError;\n};\n```\n\n**2. Create Role-Based Error Handler**\n\n```typescript title=\"src/middleware/error-handler.ts\"\nexport const roleBasedErrorHandler = t.middleware(async ({ ctx, next }) => {\n  try {\n    return await next();\n  } catch (error) {\n    // Log errors with context\n    logger.error('tRPC Error', {\n      userId: ctx.user?.id,\n      role: ctx.user?.role,\n      error: error.message,\n      requestId: ctx.requestId,\n    });\n\n    // Re-throw for error formatter\n    throw error;\n  }\n});\n```\n\n**3. Apply to Router**\n\n```typescript title=\"src/trpc.ts\"\nconst t = initTRPC.context<Context>().create({\n  errorFormatter: contextAwareFormatter,\n});\n\nexport const protectedProcedure = t.procedure\n  .use(authMiddleware)\n  .use(roleBasedErrorHandler);\n```\n\n## Best Practices\n\n1. Keep Error Messages User-Friendly\n\nDon't expose internal system details in production error messages:\n\n```ts\n// ‚ùå Don't do this\nthrow new TRPCError({\n  code: 'INTERNAL_SERVER_ERROR',\n  message: `Database connection failed: ${dbError.message}`,\n});\n\n// ‚úÖ Do this instead\nthrow new TRPCError({\n  code: 'INTERNAL_SERVER_ERROR',\n  message: 'Unable to process request. Please try again later.',\n  cause: dbError, // Only exposed in development\n});\n```\n\n2. Use Consistent Error Codes\n\nMap your application errors to appropriate HTTP status codes:\n\n```ts\nconst errorCodeMap = {\n  VALIDATION_ERROR: 'BAD_REQUEST',\n  NOT_AUTHENTICATED: 'UNAUTHORIZED',\n  ACCESS_DENIED: 'FORBIDDEN',\n  RESOURCE_NOT_FOUND: 'NOT_FOUND',\n} as const;\n```\n\n3. Log Errors for Debugging\n\nAlways log errors on the server side for debugging:\n\n```ts\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { error, path, input } = opts;\n\n    // Log all errors for debugging\n    console.error(`tRPC Error at ${path}:`, {\n      error: error.message,\n      code: error.code,\n      input,\n      stack: error.stack,\n    });\n\n    return opts.shape;\n  },\n});\n```\n\n## Common Patterns\n\n### Validation Error Formatting\n\nPerfect for form validation with Zod:\n\n```ts\n// This formatter makes Zod errors easy to handle in forms\nerrorFormatter(opts) {\n  const { shape, error } = opts;\n  if (error.code === 'BAD_REQUEST' && error.cause instanceof ZodError) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError: error.cause.flatten(),\n        fieldErrors: error.cause.formErrors,\n      },\n    };\n  }\n  return shape;\n}\n```\n\n### Internationalization Support\n\nAdd error message translations:\n\n```ts\nerrorFormatter(opts) {\n  const { shape, error, ctx } = opts;\n  const locale = ctx?.locale || 'en';\n\n  return {\n    ...shape,\n    message: translateError(error.message, locale),\n    data: {\n      ...shape.data,\n      locale,\n    },\n  };\n}\n```\n\n</rewritten_file>\n"}, {"info":{"path":"server/error-handling.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/error-handling.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Error Handling","description":"Handle errors gracefully with proper HTTP status codes and structured responses","icon":"IconAlertTriangle","index":false},"content":"\nProper error handling is crucial for building robust APIs. tRPC provides structured error handling with appropriate HTTP status codes, error messages, and type safety.\n\n<Callout title=\"Error Handling Benefits\">\n  - **Structured Responses**: Consistent error format across your API - **HTTP\n  Status Codes**: Proper status codes for different error types - **Type\n  Safety**: Errors are typed and can be handled properly on the client -\n  **Debugging Info**: Stack traces and error context in development\n</Callout>\n\n## tRPC Error Codes\n\ntRPC defines standardized error codes that map to HTTP status codes:\n\n<Tabs items={['Client Errors', 'Server Errors', 'All Codes']}>\n  <Tab value=\"Client Errors\">\n    | Code | HTTP Status | Description |\n    |------|-------------|-------------|\n    | `BAD_REQUEST` | 400 | Invalid request data or parameters |\n    | `UNAUTHORIZED` | 401 | Authentication required |\n    | `PAYMENT_REQUIRED` | 402 | Payment required for this resource |\n    | `FORBIDDEN` | 403 | User lacks permission for this action |\n    | `NOT_FOUND` | 404 | Resource or endpoint not found |\n    | `METHOD_NOT_SUPPORTED` | 405 | HTTP method not allowed |\n    | `TIMEOUT` | 408 | Request timeout |\n    | `CONFLICT` | 409 | Resource conflict (e.g., duplicate data) |\n    | `PRECONDITION_FAILED` | 412 | Precondition not met |\n    | `PAYLOAD_TOO_LARGE` | 413 | Request payload too large |\n    | `UNSUPPORTED_MEDIA_TYPE` | 415 | Unsupported content type |\n    | `UNPROCESSABLE_CONTENT` | 422 | Validation errors |\n    | `TOO_MANY_REQUESTS` | 429 | Rate limit exceeded |\n    | `CLIENT_CLOSED_REQUEST` | 499 | Client closed connection |\n  </Tab>\n\n<Tab value=\"Server Errors\">\n  | Code | HTTP Status | Description | |------|-------------|-------------| |\n  `INTERNAL_SERVER_ERROR` | 500 | Unexpected server error | | `NOT_IMPLEMENTED`\n  | 501 | Feature not implemented | | `BAD_GATEWAY` | 502 | Bad response from\n  upstream server | | `SERVICE_UNAVAILABLE` | 503 | Service temporarily\n  unavailable | | `GATEWAY_TIMEOUT` | 504 | Upstream server timeout |\n</Tab>\n\n  <Tab value=\"All Codes\">\n    ```typescript\n    // Complete list of tRPC error codes\n    type TRPCErrorCode = \n      | 'BAD_REQUEST'\n      | 'UNAUTHORIZED' \n      | 'PAYMENT_REQUIRED'\n      | 'FORBIDDEN'\n      | 'NOT_FOUND'\n      | 'METHOD_NOT_SUPPORTED'\n      | 'TIMEOUT'\n      | 'CONFLICT'\n      | 'PRECONDITION_FAILED'\n      | 'PAYLOAD_TOO_LARGE'\n      | 'UNSUPPORTED_MEDIA_TYPE'\n      | 'UNPROCESSABLE_CONTENT'\n      | 'TOO_MANY_REQUESTS'\n      | 'CLIENT_CLOSED_REQUEST'\n      | 'INTERNAL_SERVER_ERROR'\n      | 'NOT_IMPLEMENTED'\n      | 'BAD_GATEWAY'\n      | 'SERVICE_UNAVAILABLE'\n      | 'GATEWAY_TIMEOUT';\n    ```\n  </Tab>\n</Tabs>\n\n## Throwing Errors\n\n### Basic Error Throwing\n\n```typescript title=\"src/error-examples.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .query(async ({ input }) => {\n      const user = await db.user.findUnique({\n        where: { id: input.id },\n      });\n\n      if (!user) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: `User with ID ${input.id} not found`,\n        });\n      }\n\n      return user;\n    }),\n\n  createUser: publicProcedure\n    .input(z.object({\n      email: z.string().email(),\n      name: z.string(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        return await db.user.create({ data: input });\n      } catch (error) {\n        if (error.code === 'P2002') { // Unique constraint violation\n          throw new TRPCError({\n            code: 'CONFLICT',\n            message: 'A user with this email already exists',\n            cause: error,\n          });\n        }\n\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Failed to create user',\n          cause: error,\n        });\n      }\n    }),\n\n  deletePost: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .mutation(async ({ input, ctx }) => {\n      if (!ctx.user) {\n        throw new TRPCError({\n          code: 'UNAUTHORIZED',\n          message: 'You must be logged in to delete posts',\n        });\n      }\n\n      const post = await db.post.findUnique({\n        where: { id: input.id },\n      });\n\n      if (!post) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found',\n        });\n      }\n\n      if (post.authorId !== ctx.user.id && ctx.user.role !== 'admin') {\n        throw new TRPCError({\n          code: 'FORBIDDEN',\n          message: 'You can only delete your own posts',\n        });\n      }\n\n      await db.post.delete({ where: { id: input.id } });\n      return { success: true };\n    }),\n});\n```\n\n### Error with Additional Context\n\n```typescript title=\"src/detailed-errors.ts\"\n// Include additional error context\nexport const paymentRouter = router({\n  processPayment: publicProcedure\n    .input(z.object({\n      amount: z.number().positive(),\n      currency: z.string(),\n      paymentMethodId: z.string(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      try {\n        const result = await stripe.paymentIntents.create({\n          amount: input.amount,\n          currency: input.currency,\n          payment_method: input.paymentMethodId,\n          confirm: true,\n        });\n\n        return result;\n      } catch (error) {\n        if (error.type === 'StripeCardError') {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: 'Payment failed: ' + error.message,\n            cause: error,\n          });\n        }\n\n        if (error.type === 'StripeRateLimitError') {\n          throw new TRPCError({\n            code: 'TOO_MANY_REQUESTS',\n            message: 'Too many requests to payment processor',\n            cause: error,\n          });\n        }\n\n        if (error.type === 'StripeConnectionError') {\n          throw new TRPCError({\n            code: 'SERVICE_UNAVAILABLE',\n            message: 'Payment service temporarily unavailable',\n            cause: error,\n          });\n        }\n\n        // Unknown Stripe error\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Payment processing failed',\n          cause: error,\n        });\n      }\n    }),\n});\n```\n\n## Global Error Handling\n\n### Using onError Handler\n\n```typescript title=\"src/server.ts\"\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { appRouter } from './router';\nimport { createContext } from './context';\n\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext,\n  onError: ({ error, type, path, input, ctx, req }) => {\n    // Log all errors for debugging\n    console.error(`‚ùå tRPC Error on ${type} ${path}:`, {\n      error: error.message,\n      code: error.code,\n      input,\n      stack: error.stack,\n    });\n\n    // Report critical errors to monitoring service\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\n      // Send to Sentry, DataDog, etc.\n      errorReporting.captureException(error, {\n        tags: {\n          trpcPath: path,\n          trpcType: type,\n        },\n        user: ctx?.user ? { id: ctx.user.id } : undefined,\n        extra: {\n          input,\n          path,\n          type,\n        },\n      });\n    }\n\n    // Log security events\n    if (error.code === 'UNAUTHORIZED' || error.code === 'FORBIDDEN') {\n      securityLog.warn('Access denied', {\n        ip: req.ip,\n        userAgent: req.headers['user-agent'],\n        path,\n        userId: ctx?.user?.id,\n      });\n    }\n  },\n});\n```\n\n### Centralized Error Processing\n\n```typescript title=\"src/error-utils.ts\"\nimport { TRPCError } from '@trpc/server';\n\n// Error factory functions\nexport const createNotFoundError = (resource: string, id: string) => {\n  return new TRPCError({\n    code: 'NOT_FOUND',\n    message: `${resource} with ID \"${id}\" not found`,\n  });\n};\n\nexport const createValidationError = (message: string, field?: string) => {\n  return new TRPCError({\n    code: 'BAD_REQUEST',\n    message: field ? `${field}: ${message}` : message,\n  });\n};\n\nexport const createAuthError = (message: string = 'Authentication required') => {\n  return new TRPCError({\n    code: 'UNAUTHORIZED',\n    message,\n  });\n};\n\nexport const createPermissionError = (action: string, resource?: string) => {\n  const message = resource\n    ? `You don't have permission to ${action} ${resource}`\n    : `You don't have permission to ${action}`;\n\n  return new TRPCError({\n    code: 'FORBIDDEN',\n    message,\n  });\n};\n\n// Database error handler\nexport const handleDatabaseError = (error: any, operation: string) => {\n  console.error(`Database error during ${operation}:`, error);\n\n  // Prisma-specific error handling\n  if (error.code === 'P2002') {\n    const field = error.meta?.target?.[0] || 'field';\n    throw new TRPCError({\n      code: 'CONFLICT',\n      message: `${field} already exists`,\n      cause: error,\n    });\n  }\n\n  if (error.code === 'P2025') {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: 'Record not found',\n      cause: error,\n    });\n  }\n\n  // Generic database error\n  throw new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    message: `Database operation failed: ${operation}`,\n    cause: error,\n  });\n};\n\n// Usage in procedures\nexport const userRouter = router({\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .query(async ({ input }) => {\n      try {\n        const user = await db.user.findUnique({\n          where: { id: input.id },\n        });\n\n        if (!user) {\n          throw createNotFoundError('User', input.id);\n        }\n\n        return user;\n      } catch (error) {\n        if (error instanceof TRPCError) {\n          throw error;\n        }\n        handleDatabaseError(error, 'get user');\n      }\n    }),\n});\n```\n\n## Error Response Format\n\n### Standard Error Response\n\n```json title=\"error-response.json\"\n{\n  \"error\": {\n    \"json\": {\n      \"message\": \"User with ID \\\"invalid-id\\\" not found\",\n      \"code\": -32603,\n      \"data\": {\n        \"code\": \"NOT_FOUND\",\n        \"httpStatus\": 404,\n        \"stack\": \"Error: User with ID \\\"invalid-id\\\" not found\\n    at ...\",\n        \"path\": \"user.getById\"\n      }\n    }\n  }\n}\n```\n\n### Validation Error Response\n\n```json title=\"validation-error.json\"\n{\n  \"error\": {\n    \"json\": {\n      \"message\": \"Validation failed\",\n      \"code\": -32600,\n      \"data\": {\n        \"code\": \"BAD_REQUEST\",\n        \"httpStatus\": 400,\n        \"path\": \"user.create\",\n        \"zodError\": {\n          \"fieldErrors\": {\n            \"email\": [\"Invalid email format\"],\n            \"name\": [\"Name must be at least 2 characters\"]\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## Error Middleware\n\n### Error Catching Middleware\n\n```typescript title=\"src/error-middleware.ts\"\n// Catch and transform errors in middleware\nconst errorCatchingMiddleware = t.middleware(async ({ next, path, type }) => {\n  try {\n    return await next();\n  } catch (error) {\n    // Transform known error types\n    if (error instanceof ValidationError) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: error.message,\n        cause: error,\n      });\n    }\n\n    if (error instanceof DatabaseConnectionError) {\n      throw new TRPCError({\n        code: 'SERVICE_UNAVAILABLE',\n        message: 'Database temporarily unavailable',\n        cause: error,\n      });\n    }\n\n    if (error instanceof RateLimitError) {\n      throw new TRPCError({\n        code: 'TOO_MANY_REQUESTS',\n        message: 'Rate limit exceeded',\n        cause: error,\n      });\n    }\n\n    // Log unknown errors\n    console.error(`Unknown error in ${type} ${path}:`, error);\n\n    // Re-throw tRPC errors as-is\n    if (error instanceof TRPCError) {\n      throw error;\n    }\n\n    // Wrap unknown errors\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred',\n      cause: error,\n    });\n  }\n});\n\nexport const safeProcedure = t.procedure.use(errorCatchingMiddleware);\n```\n\n### Retry Middleware\n\n```typescript title=\"src/retry-middleware.ts\"\n// Retry failed operations\nconst retryMiddleware = (maxRetries: number = 3) => {\n  return t.middleware(async ({ next, path }) => {\n    let lastError: Error;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await next();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry client errors\n        if (error instanceof TRPCError && [\n          'BAD_REQUEST',\n          'UNAUTHORIZED',\n          'FORBIDDEN',\n          'NOT_FOUND',\n          'CONFLICT',\n        ].includes(error.code)) {\n          throw error;\n        }\n\n        // Don't retry on last attempt\n        if (attempt === maxRetries) {\n          break;\n        }\n\n        // Exponential backoff\n        const delay = Math.pow(2, attempt) * 100;\n        await new Promise(resolve => setTimeout(resolve, delay));\n\n        console.log(`Retrying ${path} (attempt ${attempt + 1}/${maxRetries})`);\n      }\n    }\n\n    throw lastError!;\n  });\n};\n\nexport const resilientProcedure = t.procedure.use(retryMiddleware(3));\n```\n\n## Custom Error Classes\n\n```typescript title=\"src/custom-errors.ts\"\n// Create custom error classes for your domain\nexport class UserNotFoundError extends Error {\n  constructor(userId: string) {\n    super(`User with ID \"${userId}\" not found`);\n    this.name = 'UserNotFoundError';\n  }\n}\n\nexport class InsufficientFundsError extends Error {\n  constructor(available: number, required: number) {\n    super(`Insufficient funds: available ${available}, required ${required}`);\n    this.name = 'InsufficientFundsError';\n  }\n}\n\nexport class BusinessHoursError extends Error {\n  constructor() {\n    super('This operation is only available during business hours');\n    this.name = 'BusinessHoursError';\n  }\n}\n\n// Transform custom errors to tRPC errors\nconst transformError = (error: Error): TRPCError => {\n  if (error instanceof UserNotFoundError) {\n    return new TRPCError({\n      code: 'NOT_FOUND',\n      message: error.message,\n      cause: error,\n    });\n  }\n\n  if (error instanceof InsufficientFundsError) {\n    return new TRPCError({\n      code: 'BAD_REQUEST',\n      message: error.message,\n      cause: error,\n    });\n  }\n\n  if (error instanceof BusinessHoursError) {\n    return new TRPCError({\n      code: 'SERVICE_UNAVAILABLE',\n      message: error.message,\n      cause: error,\n    });\n  }\n\n  return new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    message: 'An unexpected error occurred',\n    cause: error,\n  });\n};\n\n// Usage in procedures\nexport const walletRouter = router({\n  transfer: publicProcedure\n    .input(z.object({\n      fromUserId: z.string(),\n      toUserId: z.string(),\n      amount: z.number().positive(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        // Business logic that throws custom errors\n        const result = await transferFunds(\n          input.fromUserId,\n          input.toUserId,\n          input.amount\n        );\n        return result;\n      } catch (error) {\n        throw transformError(error as Error);\n      }\n    }),\n});\n```\n\n## Testing Error Handling\n\n```typescript title=\"src/error-handling.test.ts\"\nimport { describe, it, expect } from 'vitest';\nimport { createCallerFactory } from '@trpc/server';\nimport { TRPCError } from '@trpc/server';\nimport { appRouter } from './router';\n\nconst createCaller = createCallerFactory(appRouter);\n\ndescribe('Error Handling', () => {\n  describe('Authentication Errors', () => {\n    it('should throw UNAUTHORIZED for missing auth', async () => {\n      const caller = createCaller({ user: null });\n\n      await expect(\n        caller.protected.getProfile()\n      ).rejects.toThrow(TRPCError);\n\n      await expect(\n        caller.protected.getProfile()\n      ).rejects.toHaveProperty('code', 'UNAUTHORIZED');\n    });\n  });\n\n  describe('Authorization Errors', () => {\n    it('should throw FORBIDDEN for insufficient permissions', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', role: 'user' },\n      });\n\n      await expect(\n        caller.admin.deleteUser({ id: 'user2' })\n      ).rejects.toThrow(TRPCError);\n\n      await expect(\n        caller.admin.deleteUser({ id: 'user2' })\n      ).rejects.toHaveProperty('code', 'FORBIDDEN');\n    });\n  });\n\n  describe('Validation Errors', () => {\n    it('should throw BAD_REQUEST for invalid input', async () => {\n      const caller = createCaller({});\n\n      await expect(\n        caller.user.create({\n          email: 'invalid-email',\n          name: '', // Too short\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Not Found Errors', () => {\n    it('should throw NOT_FOUND for missing resources', async () => {\n      const caller = createCaller({});\n\n      await expect(\n        caller.user.getById({ id: 'nonexistent' })\n      ).rejects.toHaveProperty('code', 'NOT_FOUND');\n    });\n  });\n\n  describe('Business Logic Errors', () => {\n    it('should handle insufficient funds', async () => {\n      const caller = createCaller({\n        user: { id: 'user1', balance: 10 },\n      });\n\n      await expect(\n        caller.wallet.transfer({\n          toUserId: 'user2',\n          amount: 100, // More than balance\n        })\n      ).rejects.toHaveProperty('code', 'BAD_REQUEST');\n    });\n  });\n});\n```\n\n## Error Utilities\n\n```typescript title=\"src/error-utils.ts\"\nimport { TRPCError } from '@trpc/server';\n\n// Extract HTTP status code from tRPC error\nexport function getHTTPStatusCodeFromError(error: TRPCError): number {\n  const httpStatusCodes: Record<string, number> = {\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504,\n  };\n\n  return httpStatusCodes[error.code] || 500;\n}\n\n// Check if error is a specific tRPC error\nexport function isTRPCError(error: unknown): error is TRPCError {\n  return error instanceof TRPCError;\n}\n\nexport function isTRPCErrorWithCode(\n  error: unknown,\n  code: TRPCError['code']\n): error is TRPCError {\n  return isTRPCError(error) && error.code === code;\n}\n\n// Usage in API routes\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const result = await caller.someOperation();\n    res.status(200).json(result);\n  } catch (error) {\n    if (isTRPCError(error)) {\n      const statusCode = getHTTPStatusCodeFromError(error);\n      res.status(statusCode).json({ error: error.message });\n    } else {\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n}\n```\n\n## Best Practices\n\n<Accordions>\n  <Accordion title=\"Error Messages\">\n    - **Be specific**: Provide clear, actionable error messages\n    - **Don't leak secrets**: Avoid exposing sensitive information\n    - **Include context**: Help users understand what went wrong\n    - **Suggest solutions**: Guide users on how to fix the issue\n    \n    ```typescript\n    // Good error messages\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Email must be a valid email address. Received: \"invalid@\"',\n    });\n    \n    // Bad error messages\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Invalid input',\n    });\n    ```\n  </Accordion>\n\n  <Accordion title=\"Error Codes\">\n    - **Use appropriate codes**: Choose the most specific error code\n    - **Be consistent**: Use the same codes for similar errors\n    - **Document error codes**: Help API consumers understand errors\n    - **Map to HTTP status**: Ensure proper HTTP response codes\n    \n    ```typescript\n    // Appropriate error codes\n    if (!user) throw new TRPCError({ code: 'NOT_FOUND' });\n    if (!authorized) throw new TRPCError({ code: 'FORBIDDEN' });\n    if (validation.failed) throw new TRPCError({ code: 'BAD_REQUEST' });\n    ```\n  </Accordion>\n\n  <Accordion title=\"Security\">\n    - **Log security events**: Track authentication failures\n    - **Rate limit error responses**: Prevent abuse\n    - **Sanitize error data**: Don't expose internal details\n    - **Monitor error patterns**: Detect attacks or issues\n    \n    ```typescript\n    // Secure error handling\n    const handleAuthError = (error: Error, ctx: Context) => {\n      // Log security event\n      securityLogger.warn('Authentication failed', {\n        ip: ctx.req.ip,\n        userAgent: ctx.req.headers['user-agent'],\n        timestamp: new Date(),\n      });\n      \n      // Return generic error to client\n      throw new TRPCError({\n        code: 'UNAUTHORIZED',\n        message: 'Authentication failed',\n        // Don't include error details\n      });\n    };\n    ```\n  </Accordion>\n\n  <Accordion title=\"Debugging\">\n    - **Include stack traces**: Only in development\n    - **Log error context**: Include request details\n    - **Use error IDs**: Help track specific errors\n    - **Monitor error rates**: Set up alerts for high error rates\n    \n    ```typescript\n    // Debugging-friendly error handling\n    const debugError = (error: Error, context: any) => {\n      const errorId = generateErrorId();\n      \n      logger.error('Operation failed', {\n        errorId,\n        message: error.message,\n        stack: error.stack,\n        context,\n        timestamp: new Date(),\n      });\n      \n      throw new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: `Operation failed (Error ID: ${errorId})`,\n        cause: process.env.NODE_ENV === 'development' ? error : undefined,\n      });\n    };\n    ```\n  </Accordion>\n</Accordions>\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Error Formatting\" href=\"/docs/server/error-formatting\">\n    Customize how errors are formatted and returned to clients\n  </Card>\n  <Card title=\"Middleware\" href=\"/docs/server/middlewares\">\n    Learn how to handle errors in middleware\n  </Card>\n  <Card title=\"Authorization\" href=\"/docs/server/authorization\">\n    Implement proper authentication and authorization\n  </Card>\n  <Card title=\"Server-Side Calls\" href=\"/docs/server/server-side-calls\">\n    Test your error handling with server-side callers\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/file-uploads.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/file-uploads.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"File Uploads","description":"Handle file uploads efficiently with tRPC procedures","icon":"IconUpload","index":false},"content":"\ntRPC supports various file upload patterns, from simple base64 encoding to advanced streaming uploads. Choose the approach that best fits your application's needs and constraints.\n\n<Callout type=\"warn\">\n  File uploads can consume significant server resources. Always implement proper\n  validation, size limits, and security measures.\n</Callout>\n\n## Upload Strategies\n\n<Tabs items={['Base64 (Simple)', 'FormData (Recommended)', 'Streaming (Advanced)']}>\n\n```mdx tab=\"Base64 (Simple)\"\n**Best for:** Small files, simple implementations\n\n**Pros:**\n\n- Easy to implement\n- Works with standard JSON\n- No special handling needed\n\n**Cons:**\n\n- ~33% size overhead\n- Memory intensive\n- Size limitations\n```\n\n```mdx tab=\"FormData (Recommended)\"\n**Best for:** Most applications\n\n**Pros:**\n\n- Efficient for binary data\n- Built-in browser support\n- Progress tracking\n- Multiple files\n\n**Cons:**\n\n- Requires custom handling\n- More complex setup\n```\n\n```mdx tab=\"Streaming (Advanced)\"\n**Best for:** Large files, high performance\n\n**Pros:**\n\n- Memory efficient\n- Real-time processing\n- Minimal server footprint\n\n**Cons:**\n\n- Complex implementation\n- Requires streaming setup\n```\n\n</Tabs>\n\n## Base64 Upload (Simple)\n\n### Server Implementation\n\nPerfect for small files like profile pictures:\n\n```ts title=\"server/routers/uploads.ts\"\nimport { z } from 'zod';\nimport { TRPCError } from '@trpc/server';\nimport { writeFile } from 'fs/promises';\nimport { join } from 'path';\n\nconst MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n\nexport const uploadsRouter = t.router({\n  uploadAvatar: t.procedure\n    .input(z.object({\n      name: z.string(),\n      type: z.string(),\n      data: z.string(), // base64 encoded\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Validate file type\n      const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];\n      if (!allowedTypes.includes(input.type)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'Invalid file type',\n        });\n      }\n\n      // Decode and validate size\n      const buffer = Buffer.from(input.data, 'base64');\n      if (buffer.length > MAX_FILE_SIZE) {\n        throw new TRPCError({\n          code: 'PAYLOAD_TOO_LARGE',\n          message: 'File too large',\n        });\n      }\n\n      // Generate unique filename\n      const filename = `${Date.now()}-${Math.random().toString(36)}.${input.type.split('/')[1]}`;\n      const filepath = join(process.cwd(), 'uploads', filename);\n\n      // Save file\n      await writeFile(filepath, buffer);\n\n      // Update user profile\n      await ctx.db.user.update({\n        where: { id: ctx.user.id },\n        data: { avatar: `/uploads/${filename}` },\n      });\n\n      return {\n        url: `/uploads/${filename}`,\n        size: buffer.length,\n      };\n    }),\n});\n```\n\n### Client Usage\n\n```tsx title=\"components/AvatarUpload.tsx\"\nimport { trpc } from '../lib/trpc';\n\nexport function AvatarUpload() {\n  const uploadMutation = trpc.uploads.uploadAvatar.useMutation();\n\n  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    // Validate file size on client\n    if (file.size > 5 * 1024 * 1024) {\n      alert('File too large. Maximum size is 5MB.');\n      return;\n    }\n\n    // Convert to base64\n    const base64 = await new Promise<string>((resolve) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.readAsDataURL(file);\n    });\n\n    // Remove data URL prefix\n    const data = base64.split(',')[1];\n\n    try {\n      const result = await uploadMutation.mutateAsync({\n        name: file.name,\n        type: file.type,\n        data,\n      });\n\n      console.log('Upload successful:', result);\n    } catch (error) {\n      console.error('Upload failed:', error);\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={handleFileSelect}\n        disabled={uploadMutation.isLoading}\n      />\n      {uploadMutation.isLoading && <p>Uploading...</p>}\n    </div>\n  );\n}\n```\n\n## FormData Upload (Recommended)\n\n### Custom Upload Endpoint\n\nCreate a dedicated upload endpoint alongside tRPC:\n\n```ts title=\"pages/api/upload.ts\"\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport formidable from 'formidable';\nimport { createHash } from 'crypto';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const form = formidable({\n      maxFileSize: 50 * 1024 * 1024, // 50MB\n      maxFiles: 5,\n      allowEmptyFiles: false,\n    });\n\n    const [fields, files] = await form.parse(req);\n    const uploadedFiles = [];\n\n    for (const [fieldName, fileArray] of Object.entries(files)) {\n      for (const file of fileArray || []) {\n        // Generate secure filename\n        const hash = createHash('sha256')\n          .update(`${file.originalFilename}-${Date.now()}`)\n          .digest('hex')\n          .substring(0, 16);\n\n        const ext = file.originalFilename?.split('.').pop() || '';\n        const filename = `${hash}.${ext}`;\n        const uploadPath = join(process.cwd(), 'public', 'uploads', filename);\n\n        // Move file to permanent location\n        await fs.rename(file.filepath, uploadPath);\n\n        uploadedFiles.push({\n          fieldName,\n          filename: file.originalFilename,\n          url: `/uploads/${filename}`,\n          size: file.size,\n          type: file.mimetype,\n        });\n      }\n    }\n\n    res.status(200).json({ files: uploadedFiles });\n  } catch (error) {\n    console.error('Upload error:', error);\n    res.status(500).json({ error: 'Upload failed' });\n  }\n}\n```\n\n### Client with Progress Tracking\n\n```tsx title=\"components/FileUpload.tsx\"\nimport { useState } from 'react';\n\ninterface UploadProgress {\n  loaded: number;\n  total: number;\n  percentage: number;\n}\n\nexport function FileUpload() {\n  const [progress, setProgress] = useState<UploadProgress | null>(null);\n  const [uploadedFiles, setUploadedFiles] = useState<any[]>([]);\n\n  const uploadFiles = async (files: FileList) => {\n    const formData = new FormData();\n\n    Array.from(files).forEach((file, index) => {\n      formData.append(`file-${index}`, file);\n    });\n\n    try {\n      const response = await fetch('/api/upload', {\n        method: 'POST',\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error('Upload failed');\n      }\n\n      const result = await response.json();\n      setUploadedFiles(result.files);\n      setProgress(null);\n    } catch (error) {\n      console.error('Upload error:', error);\n      setProgress(null);\n    }\n  };\n\n  const uploadWithProgress = async (files: FileList) => {\n    const formData = new FormData();\n    Array.from(files).forEach((file, index) => {\n      formData.append(`file-${index}`, file);\n    });\n\n    const xhr = new XMLHttpRequest();\n\n    xhr.upload.onprogress = (event) => {\n      if (event.lengthComputable) {\n        setProgress({\n          loaded: event.loaded,\n          total: event.total,\n          percentage: Math.round((event.loaded / event.total) * 100),\n        });\n      }\n    };\n\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        const result = JSON.parse(xhr.responseText);\n        setUploadedFiles(result.files);\n        setProgress(null);\n      }\n    };\n\n    xhr.open('POST', '/api/upload');\n    xhr.send(formData);\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <input\n        type=\"file\"\n        multiple\n        onChange={(e) => {\n          if (e.target.files?.length) {\n            uploadWithProgress(e.target.files);\n          }\n        }}\n      />\n\n      {progress && (\n        <div className=\"space-y-2\">\n          <div className=\"bg-gray-200 rounded-full h-2\">\n            <div\n              className=\"bg-blue-600 h-2 rounded-full transition-all\"\n              style={{ width: `${progress.percentage}%` }}\n            />\n          </div>\n          <p className=\"text-sm text-gray-600\">\n            {progress.percentage}% ({progress.loaded} / {progress.total} bytes)\n          </p>\n        </div>\n      )}\n\n      {uploadedFiles.length > 0 && (\n        <div className=\"space-y-2\">\n          <h3 className=\"font-semibold\">Uploaded Files:</h3>\n          {uploadedFiles.map((file, index) => (\n            <div key={index} className=\"flex items-center space-x-2\">\n              <span>{file.filename}</span>\n              <span className=\"text-sm text-gray-500\">({file.size} bytes)</span>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Streaming Upload (Advanced)\n\n### Server Streaming Handler\n\nFor handling large files efficiently:\n\n```ts title=\"pages/api/stream-upload.ts\"\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createWriteStream } from 'fs';\nimport { pipeline } from 'stream/promises';\nimport { join } from 'path';\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  const filename = req.headers['x-filename'] as string;\n  const contentLength = parseInt(req.headers['content-length'] || '0');\n\n  if (!filename) {\n    return res.status(400).json({ error: 'Filename required' });\n  }\n\n  // Validate file size\n  if (contentLength > 100 * 1024 * 1024) { // 100MB\n    return res.status(413).json({ error: 'File too large' });\n  }\n\n  try {\n    const uploadPath = join(process.cwd(), 'uploads', filename);\n    const writeStream = createWriteStream(uploadPath);\n\n    // Stream the request body directly to file\n    await pipeline(req, writeStream);\n\n    res.status(200).json({\n      message: 'Upload successful',\n      filename,\n      size: contentLength,\n    });\n  } catch (error) {\n    console.error('Streaming upload error:', error);\n    res.status(500).json({ error: 'Upload failed' });\n  }\n}\n```\n\n### Client Streaming Upload\n\n```tsx title=\"components/StreamingUpload.tsx\"\nexport function StreamingUpload() {\n  const [uploading, setUploading] = useState(false);\n\n  const streamUpload = async (file: File) => {\n    setUploading(true);\n\n    try {\n      const response = await fetch('/api/stream-upload', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Filename': file.name,\n        },\n        body: file, // Stream the file directly\n      });\n\n      if (!response.ok) {\n        throw new Error('Upload failed');\n      }\n\n      const result = await response.json();\n      console.log('Upload successful:', result);\n    } catch (error) {\n      console.error('Upload error:', error);\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"file\"\n        onChange={(e) => {\n          const file = e.target.files?.[0];\n          if (file) streamUpload(file);\n        }}\n        disabled={uploading}\n      />\n      {uploading && <p>Streaming upload in progress...</p>}\n    </div>\n  );\n}\n```\n\n## Cloud Storage Integration\n\n### AWS S3 Upload\n\n```ts title=\"server/routers/s3-uploads.ts\"\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\n\nconst s3 = new S3Client({\n  region: process.env.AWS_REGION!,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,\n  },\n});\n\nexport const s3Router = t.router({\n  getSignedUploadUrl: t.procedure\n    .input(z.object({\n      filename: z.string(),\n      contentType: z.string(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      const key = `uploads/${ctx.user.id}/${Date.now()}-${input.filename}`;\n\n      const command = new PutObjectCommand({\n        Bucket: process.env.S3_BUCKET_NAME!,\n        Key: key,\n        ContentType: input.contentType,\n      });\n\n      const signedUrl = await getSignedUrl(s3, command, {\n        expiresIn: 3600, // 1 hour\n      });\n\n      return {\n        signedUrl,\n        key,\n        bucket: process.env.S3_BUCKET_NAME!,\n      };\n    }),\n\n  confirmUpload: t.procedure\n    .input(z.object({\n      key: z.string(),\n      size: z.number(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Store file metadata in database\n      const file = await ctx.db.file.create({\n        data: {\n          key: input.key,\n          size: input.size,\n          userId: ctx.user.id,\n          url: `https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${input.key}`,\n        },\n      });\n\n      return file;\n    }),\n});\n```\n\n### Client S3 Upload\n\n```tsx title=\"components/S3Upload.tsx\"\nimport { trpc } from '../lib/trpc';\n\nexport function S3Upload() {\n  const getSignedUrl = trpc.s3.getSignedUploadUrl.useMutation();\n  const confirmUpload = trpc.s3.confirmUpload.useMutation();\n\n  const uploadToS3 = async (file: File) => {\n    try {\n      // Get signed URL\n      const { signedUrl, key } = await getSignedUrl.mutateAsync({\n        filename: file.name,\n        contentType: file.type,\n      });\n\n      // Upload directly to S3\n      const uploadResponse = await fetch(signedUrl, {\n        method: 'PUT',\n        body: file,\n        headers: {\n          'Content-Type': file.type,\n        },\n      });\n\n      if (!uploadResponse.ok) {\n        throw new Error('S3 upload failed');\n      }\n\n      // Confirm upload in our database\n      const result = await confirmUpload.mutateAsync({\n        key,\n        size: file.size,\n      });\n\n      console.log('Upload complete:', result);\n    } catch (error) {\n      console.error('Upload failed:', error);\n    }\n  };\n\n  return (\n    <input\n      type=\"file\"\n      onChange={(e) => {\n        const file = e.target.files?.[0];\n        if (file) uploadToS3(file);\n      }}\n    />\n  );\n}\n```\n\n## Security Best Practices\n\n### Validate File Types\n\nAlways validate file types on both client and server:\n\n```ts\nconst ALLOWED_TYPES = [\n  'image/jpeg',\n  'image/png',\n  'image/webp',\n  'application/pdf',\n] as const;\n\nconst validateFileType = (file: { type: string; name: string }) => {\n  // Check MIME type\n  if (!ALLOWED_TYPES.includes(file.type as any)) {\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Invalid file type',\n    });\n  }\n\n  // Double-check with file extension\n  const ext = file.name.split('.').pop()?.toLowerCase();\n  const validExtensions = ['jpg', 'jpeg', 'png', 'webp', 'pdf'];\n\n  if (!ext || !validExtensions.includes(ext)) {\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Invalid file extension',\n    });\n  }\n};\n```\n\n### Scan Files for Malware\n\n```ts\nimport ClamScan from 'clamscan';\n\nconst clamscan = await new ClamScan().init();\n\nconst scanFile = async (filePath: string) => {\n  const { isInfected, file, viruses } = await clamscan.scanFile(filePath);\n\n  if (isInfected) {\n    await fs.unlink(filePath); // Delete infected file\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: `Malware detected: ${viruses.join(', ')}`,\n    });\n  }\n};\n```\n\n### Implement Rate Limiting\n\n```ts\nconst uploadLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // 10 uploads per window\n  message: 'Too many uploads, please try again later',\n});\n\n// Use in your upload handler\nexport default uploadLimiter(handler);\n```\n\n### Generate Secure Filenames\n\n```ts\nimport { randomUUID } from 'crypto';\n\nconst generateSecureFilename = (originalName: string) => {\n  const ext = originalName.split('.').pop();\n  const uuid = randomUUID();\n  return `${uuid}.${ext}`;\n};\n```\n\n### Advanced Security Implementation\n\nImplement comprehensive file upload security:\n\n**1. Setup File Validation Pipeline**\n\n```typescript title=\"src/lib/file-security.ts\"\nimport crypto from 'crypto';\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\ninterface FileValidationResult {\n  isValid: boolean;\n  errors: string[];\n  metadata: {\n    size: number;\n    mimeType: string;\n    hash: string;\n    extension: string;\n  };\n}\n\nexport class FileValidator {\n  private readonly allowedMimeTypes = [\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'application/pdf',\n    'text/plain',\n  ];\n\n  private readonly maxSizes = {\n    'image/*': 5 * 1024 * 1024,    // 5MB for images\n    'application/pdf': 10 * 1024 * 1024, // 10MB for PDFs\n    'text/plain': 1 * 1024 * 1024, // 1MB for text\n  };\n\n  async validateFile(buffer: Buffer, originalName: string): Promise<FileValidationResult> {\n    const errors: string[] = [];\n\n    // Detect actual MIME type (don't trust client)\n    const mimeType = await this.detectMimeType(buffer);\n    const extension = path.extname(originalName).toLowerCase();\n    const size = buffer.length;\n    const hash = crypto.createHash('sha256').update(buffer).digest('hex');\n\n    // Validate MIME type\n    if (!this.allowedMimeTypes.includes(mimeType)) {\n      errors.push(`File type ${mimeType} not allowed`);\n    }\n\n    // Validate size\n    const maxSize = this.getMaxSize(mimeType);\n    if (size > maxSize) {\n      errors.push(`File size ${size} exceeds limit ${maxSize}`);\n    }\n\n    // Validate extension matches MIME type\n    if (!this.extensionMatchesMimeType(extension, mimeType)) {\n      errors.push(`File extension ${extension} doesn't match type ${mimeType}`);\n    }\n\n    // Scan for malware (placeholder - use actual antivirus)\n    const hasMalware = await this.scanForMalware(buffer);\n    if (hasMalware) {\n      errors.push('File contains malware');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      metadata: { size, mimeType, hash, extension },\n    };\n  }\n\n  private async detectMimeType(buffer: Buffer): Promise<string> {\n    // Use file-type library or similar for accurate detection\n    const { fileTypeFromBuffer } = await import('file-type');\n    const result = await fileTypeFromBuffer(buffer);\n    return result?.mime || 'application/octet-stream';\n  }\n\n  private getMaxSize(mimeType: string): number {\n    for (const [pattern, size] of Object.entries(this.maxSizes)) {\n      if (mimeType.match(pattern.replace('*', '.*'))) {\n        return size;\n      }\n    }\n    return 1024 * 1024; // Default 1MB\n  }\n\n  private extensionMatchesMimeType(extension: string, mimeType: string): boolean {\n    const validCombinations: Record<string, string[]> = {\n      '.jpg': ['image/jpeg'],\n      '.jpeg': ['image/jpeg'],\n      '.png': ['image/png'],\n      '.gif': ['image/gif'],\n      '.pdf': ['application/pdf'],\n      '.txt': ['text/plain'],\n    };\n\n    return validCombinations[extension]?.includes(mimeType) || false;\n  }\n\n  private async scanForMalware(buffer: Buffer): Promise<boolean> {\n    // Integrate with ClamAV or similar service\n    // This is a placeholder implementation\n    try {\n      // Example: send to malware scanning service\n      const response = await fetch('https://api.malware-scanner.com/scan', {\n        method: 'POST',\n        body: buffer,\n        headers: {\n          'Authorization': `Bearer ${process.env.MALWARE_SCANNER_KEY}`,\n          'Content-Type': 'application/octet-stream',\n        },\n      });\n\n      const result = await response.json();\n      return result.isMalware || false;\n    } catch (error) {\n      console.error('Malware scan failed:', error);\n      // Fail secure - reject if scan fails\n      return true;\n    }\n  }\n}\n```\n\n**2. Implement Secure Upload Router**\n\n```typescript title=\"src/routers/secure-upload.ts\"\nimport { z } from 'zod';\nimport { TRPCError } from '@trpc/server';\nimport { FileValidator } from '../lib/file-security';\nimport { uploadToS3 } from '../lib/storage';\n\nconst fileValidator = new FileValidator();\n\nexport const secureUploadRouter = t.router({\n  uploadFile: t.procedure\n    .input(z.object({\n      filename: z.string().min(1).max(255),\n      contentType: z.string(),\n      base64Data: z.string(),\n      checksum: z.string(), // Client-provided checksum for integrity\n    }))\n    .mutation(async ({ input, ctx }) => {\n      try {\n        // Decode base64 data\n        const buffer = Buffer.from(input.base64Data, 'base64');\n\n        // Verify integrity\n        const actualChecksum = crypto\n          .createHash('sha256')\n          .update(buffer)\n          .digest('hex');\n\n        if (actualChecksum !== input.checksum) {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: 'File integrity check failed',\n          });\n        }\n\n        // Validate file\n        const validation = await fileValidator.validateFile(buffer, input.filename);\n\n        if (!validation.isValid) {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: `File validation failed: ${validation.errors.join(', ')}`,\n          });\n        }\n\n        // Generate secure filename\n        const secureFilename = `${ctx.user.id}/${Date.now()}-${crypto\n          .randomBytes(8)\n          .toString('hex')}${validation.metadata.extension}`;\n\n        // Upload to secure storage\n        const uploadResult = await uploadToS3({\n          bucket: process.env.S3_BUCKET!,\n          key: secureFilename,\n          body: buffer,\n          contentType: validation.metadata.mimeType,\n          metadata: {\n            userId: ctx.user.id,\n            originalName: input.filename,\n            hash: validation.metadata.hash,\n            uploadedAt: new Date().toISOString(),\n          },\n        });\n\n        // Log upload for audit\n        await ctx.db.fileUpload.create({\n          data: {\n            id: crypto.randomUUID(),\n            userId: ctx.user.id,\n            filename: input.filename,\n            secureFilename,\n            mimeType: validation.metadata.mimeType,\n            size: validation.metadata.size,\n            hash: validation.metadata.hash,\n            s3Key: uploadResult.key,\n            uploadedAt: new Date(),\n          },\n        });\n\n        return {\n          id: uploadResult.key,\n          filename: input.filename,\n          size: validation.metadata.size,\n          mimeType: validation.metadata.mimeType,\n          url: uploadResult.url,\n        };\n\n      } catch (error) {\n        // Log security incidents\n        console.error('File upload security incident:', {\n          userId: ctx.user.id,\n          filename: input.filename,\n          error: error.message,\n          timestamp: new Date().toISOString(),\n        });\n\n        throw error;\n      }\n    }),\n});\n```\n\n**3. Client-Side Secure Upload Component**\n\n```tsx title=\"components/SecureFileUpload.tsx\"\nimport React, { useState } from 'react';\nimport { trpc } from '../lib/trpc';\nimport crypto from 'crypto-js';\n\nexport function SecureFileUpload() {\n  const [uploading, setUploading] = useState(false);\n  const [progress, setProgress] = useState(0);\n\n  const uploadMutation = trpc.upload.uploadFile.useMutation({\n    onSuccess: (data) => {\n      console.log('Upload successful:', data);\n      setUploading(false);\n      setProgress(0);\n    },\n    onError: (error) => {\n      console.error('Upload failed:', error);\n      setUploading(false);\n      setProgress(0);\n      alert(`Upload failed: ${error.message}`);\n    },\n  });\n\n  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    // Validate file size on client first\n    if (file.size > 10 * 1024 * 1024) {\n      alert('File too large. Maximum size is 10MB.');\n      return;\n    }\n\n    setUploading(true);\n    setProgress(0);\n\n    try {\n      // Read file as array buffer\n      const arrayBuffer = await file.arrayBuffer();\n      const buffer = new Uint8Array(arrayBuffer);\n\n      // Calculate checksum\n      const checksum = crypto.SHA256(crypto.lib.WordArray.create(buffer)).toString();\n\n      // Convert to base64\n      const base64Data = btoa(String.fromCharCode(...buffer));\n\n      // Simulate upload progress\n      const progressInterval = setInterval(() => {\n        setProgress(prev => Math.min(prev + 10, 90));\n      }, 100);\n\n      // Upload file\n      await uploadMutation.mutateAsync({\n        filename: file.name,\n        contentType: file.type,\n        base64Data,\n        checksum,\n      });\n\n      clearInterval(progressInterval);\n      setProgress(100);\n\n    } catch (error) {\n      console.error('Upload error:', error);\n      setUploading(false);\n    }\n  };\n\n  return (\n    <div className=\"upload-container\">\n      <input\n        type=\"file\"\n        onChange={handleFileSelect}\n        disabled={uploading}\n        accept=\".jpg,.jpeg,.png,.gif,.pdf,.txt\"\n      />\n\n      {uploading && (\n        <div className=\"upload-progress\">\n          <div className=\"progress-bar\">\n            <div\n              className=\"progress-fill\"\n              style={{ width: `${progress}%` }}\n            />\n          </div>\n          <span>{progress}% uploading...</span>\n        </div>\n      )}\n\n      <div className=\"upload-guidelines\">\n        <h4>Upload Guidelines:</h4>\n        <ul>\n          <li>Maximum file size: 10MB</li>\n          <li>Allowed types: Images, PDFs, Text files</li>\n          <li>Files are scanned for malware</li>\n          <li>All uploads are logged for security</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n```\n\n## Error Handling\n\n### Comprehensive Error Types\n\n```ts\nexport class UploadError extends Error {\n  constructor(\n    public code: 'SIZE_LIMIT' | 'TYPE_INVALID' | 'MALWARE' | 'STORAGE_FULL',\n    message: string,\n    public originalError?: Error\n  ) {\n    super(message);\n    this.name = 'UploadError';\n  }\n}\n\nconst handleUploadError = (error: unknown) => {\n  if (error instanceof UploadError) {\n    switch (error.code) {\n      case 'SIZE_LIMIT':\n        throw new TRPCError({\n          code: 'PAYLOAD_TOO_LARGE',\n          message: error.message,\n        });\n      case 'TYPE_INVALID':\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: error.message,\n        });\n      case 'MALWARE':\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'File contains malware',\n        });\n      case 'STORAGE_FULL':\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Storage capacity exceeded',\n        });\n    }\n  }\n\n  throw new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    message: 'Upload failed',\n  });\n};\n```\n\n<Callout type=\"info\">\n  Choose the upload strategy that matches your needs. Base64 for simplicity,\n  FormData for most cases, and streaming for large files or high-performance\n  requirements.\n</Callout>\n"}, {"info":{"path":"server/index.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/index.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"tRPC Server","description":"Build typesafe backend APIs with tRPC server","icon":"IconServer","index":false},"content":"\ntRPC Server allows you to build fully typesafe APIs without schemas or code generation. Define your API procedures once, and get end-to-end type safety from server to client.\n\n<Callout title=\"Framework-First Approach\">\n  Start with your framework of choice and get up and running in minutes. tRPC\n  integrates seamlessly with Next.js, Express, Fastify, and more.\n</Callout>\n\n## Choose Your Framework\n\nGet started quickly with your preferred framework:\n\n<Cards>\n  <Card title=\"Next.js\" href=\"/docs/server/framework/nextjs\" icon=\"‚ö°\">\n    Full-stack framework with App Router and Pages Router support\n  </Card>\n  <Card title=\"Express\" href=\"/docs/server/framework/express\" icon=\"üöÇ\">\n    Most popular Node.js framework for traditional APIs\n  </Card>\n  <Card title=\"Fastify\" href=\"/docs/server/framework/fastify\" icon=\"‚ö°\">\n    High-performance framework for blazing-fast APIs\n  </Card>\n  <Card title=\"Standalone\" href=\"/docs/server/framework/standalone\" icon=\"üè≠\">\n    Pure HTTP server without framework dependencies\n  </Card>\n  <Card\n    title=\"Cloudflare Workers\"\n    href=\"/docs/server/framework/cloudflare-workers\"\n    icon=\"‚òÅÔ∏è\"\n  >\n    Deploy at the edge for global performance\n  </Card>\n  <Card title=\"AWS Lambda\" href=\"/docs/server/framework/aws-lambda\" icon=\"‚òÅÔ∏è\">\n    Serverless APIs with automatic scaling\n  </Card>\n</Cards>\n\n## Core Features\n\n<Cards>\n  <Card icon={<IconCode />} title=\"Type-Safe Procedures\">\n    Define queries and mutations with automatic TypeScript inference for inputs\n    and outputs.\n  </Card>\n  <Card icon={<IconShield />} title=\"Input Validation\">\n    Built-in support for Zod, Yup, and other validation libraries to ensure data\n    integrity.\n  </Card>\n  <Card icon={<IconPuzzle />} title=\"Flexible Middleware\">\n    Add authentication, logging, rate limiting, and custom logic with composable\n    middleware.\n  </Card>\n  <Card icon={<IconPlug />} title=\"Framework Agnostic\">\n    Deploy on any platform with framework-specific adapters and optimizations.\n  </Card>\n</Cards>\n\n## Quick Example\n\n<Tabs items={['Router Definition', 'Client Usage', 'Type Inference']}>\n  <Tab value=\"Router Definition\">\n    ```typescript title=\"server/router.ts\"\n    import { initTRPC } from '@trpc/server';\n    import { z } from 'zod';\n    \n    const t = initTRPC.create();\n    \n    export const appRouter = t.router({\n      hello: t.procedure\n        .input(z.object({ name: z.string() }))\n        .query(({ input }) => {\n          return { greeting: `Hello, ${input.name}!` };\n        }),\n      \n      createUser: t.procedure\n        .input(z.object({\n          name: z.string().min(2),\n          email: z.string().email(),\n        }))\n        .mutation(async ({ input }) => {\n          const user = await db.user.create({ data: input });\n          return user;\n        }),\n    });\n    \n    export type AppRouter = typeof appRouter;\n    ```\n  </Tab>\n  <Tab value=\"Client Usage\">\n    ```typescript title=\"client.ts\"\n    import { createTRPCClient, httpBatchLink } from '@trpc/client';\n    import type { AppRouter } from './server/router';\n    \n    const client = createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({ url: '/api/trpc' }),\n      ],\n    });\n    \n    // Fully typed client calls\n    const greeting = await client.hello.query({ name: 'tRPC' });\n    const user = await client.createUser.mutate({\n      name: 'John Doe',\n      email: 'john@example.com',\n    });\n    ```\n  </Tab>\n  <Tab value=\"Type Inference\">\n    ```typescript\n    // All types are automatically inferred:\n    \n    // ‚úÖ Valid - TypeScript knows name is required\n    client.hello.query({ name: 'World' });\n    \n    // ‚ùå Type error - name is missing\n    client.hello.query({});\n    \n    // ‚úÖ Valid - email format is correct\n    client.createUser.mutate({\n      name: 'Alice',\n      email: 'alice@example.com'\n    });\n    \n    // ‚ùå Type error - invalid email format\n    client.createUser.mutate({\n      name: 'Alice',\n      email: 'not-an-email'\n    });\n    ```\n  </Tab>\n</Tabs>\n\n## Why tRPC Server?\n\n<Accordions>\n  <Accordion title=\"No Code Generation\">\n    Unlike GraphQL or traditional REST APIs, tRPC doesn't require code generation. Your types are inferred directly from your TypeScript code.\n    \n    ```typescript\n    // ‚úÖ tRPC - Direct type inference\n    export const router = t.router({\n      getUser: t.procedure.query(() => ({ id: 1, name: 'John' }))\n    });\n    \n    // ‚ùå GraphQL - Requires codegen\n    // type User { id: ID!, name: String! }\n    // query GetUser { user { id name } }\n    ```\n  </Accordion>\n  \n  <Accordion title=\"End-to-End Type Safety\">\n    Changes to your server automatically propagate to your client without any build steps or manual updates.\n    \n    ```typescript\n    // Server change: Add 'age' field\n    const getUser = t.procedure.query(() => ({ \n      id: 1, \n      name: 'John',\n      age: 25 // New field\n    }));\n    \n    // Client automatically knows about 'age'\n    const user = await client.getUser.query();\n    console.log(user.age); // ‚úÖ TypeScript knows this exists\n    ```\n  </Accordion>\n  \n  <Accordion title=\"Lightweight & Fast\">\n    tRPC has minimal runtime overhead and small bundle size. Perfect for performance-critical applications.\n    \n    - **Server**: ~2KB runtime overhead\n    - **Client**: ~5KB for full React Query integration\n    - **No schema parsing**: Direct JavaScript function calls\n    - **Optimized bundling**: Tree-shakeable procedures\n  </Accordion>\n  \n  <Accordion title=\"Developer Experience\">\n    Built-in TypeScript support, excellent error messages, and great IDE integration.\n    \n    ```typescript\n    // Hover over any client call to see:\n    // - Parameter types\n    // - Return types  \n    // - JSDoc comments\n    // - Validation errors\n    \n    client.createUser.mutate({\n      name: '', // ‚ùå IDE shows: \"String must contain at least 2 character(s)\"\n      email: 'invalid' // ‚ùå IDE shows: \"Invalid email\"\n    });\n    ```\n  </Accordion>\n</Accordions>\n\n## Common Patterns\n\n<Tabs items={['Authentication', 'Database Integration', 'Error Handling', 'File Uploads']}>\n  <Tab value=\"Authentication\">\n    ```typescript\n    // Protected procedure with middleware\n    const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n      if (!ctx.user) {\n        throw new TRPCError({ code: 'UNAUTHORIZED' });\n      }\n      return next({ ctx: { user: ctx.user } });\n    });\n    \n    export const router = t.router({\n      getProfile: protectedProcedure.query(({ ctx }) => {\n        return ctx.user; // TypeScript knows user exists\n      }),\n    });\n    ```\n  </Tab>\n  \n  <Tab value=\"Database Integration\">\n    ```typescript\n    export const router = t.router({\n      getPosts: t.procedure\n        .input(z.object({\n          limit: z.number().min(1).max(100).default(10),\n          cursor: z.string().optional(),\n        }))\n        .query(async ({ input }) => {\n          const posts = await db.post.findMany({\n            take: input.limit + 1,\n            cursor: input.cursor ? { id: input.cursor } : undefined,\n            orderBy: { createdAt: 'desc' },\n          });\n          \n          const hasMore = posts.length > input.limit;\n          return {\n            items: hasMore ? posts.slice(0, -1) : posts,\n            nextCursor: hasMore ? posts[posts.length - 1].id : undefined,\n          };\n        }),\n    });\n    ```\n  </Tab>\n  \n  <Tab value=\"Error Handling\">\n    ```typescript\n    export const router = t.router({\n      createUser: t.procedure\n        .input(z.object({\n          email: z.string().email(),\n          name: z.string().min(2),\n        }))\n        .mutation(async ({ input }) => {\n          try {\n            return await db.user.create({ data: input });\n          } catch (error) {\n            if (error.code === 'P2002') { // Unique constraint\n              throw new TRPCError({\n                code: 'CONFLICT',\n                message: 'User with this email already exists',\n              });\n            }\n            throw new TRPCError({\n              code: 'INTERNAL_SERVER_ERROR',\n              message: 'Failed to create user',\n            });\n          }\n        }),\n    });\n    ```\n  </Tab>\n  \n  <Tab value=\"File Uploads\">\n    ```typescript\n    export const router = t.router({\n      uploadImage: t.procedure\n        .input(z.instanceof(FormData))\n        .mutation(async ({ input }) => {\n          const file = input.get('image') as File;\n          \n          if (!file || !file.type.startsWith('image/')) {\n            throw new TRPCError({\n              code: 'BAD_REQUEST',\n              message: 'Valid image file required',\n            });\n          }\n          \n          const fileName = `${Date.now()}-${file.name}`;\n          const url = await uploadToStorage(fileName, file);\n          \n          return { fileName, url };\n        }),\n    });\n    ```\n  </Tab>\n</Tabs>\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Framework Setup\" href=\"/docs/server/framework\">\n    Choose your framework and get started in minutes\n  </Card>\n  <Card title=\"Quick Tutorial\" href=\"/docs/server/quickstart\">\n    Build your first tRPC API step by step\n  </Card>\n  <Card title=\"Core Concepts\" href=\"/docs/server/procedures\">\n    Learn about procedures, routers, and middleware\n  </Card>\n  <Card title=\"Best Practices\" href=\"/docs/server/authorization\">\n    Authentication, validation, and error handling patterns\n  </Card>\n</Cards>\n\n<Callout title=\"Ready to deploy?\">\n  Once you've built your API locally, each framework guide includes deployment\n  instructions for production environments.\n</Callout>\n"}, {"info":{"path":"server/metadata.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/metadata.mdx"},"lastModified":null,"data":{"title":"Metadata","description":"Add custom metadata to procedures for enhanced functionality","icon":"IconTag","index":false},"content":"\nProcedure metadata allows you to add custom information to procedures that can be accessed throughout your middleware chain. This is perfect for adding annotations, configuration, or any other procedure-specific data.\n\n<Callout type=\"info\">\n  Use metadata together with\n  [`trpc-openapi`](https://github.com/jlalmes/trpc-openapi) if you want to\n  expose REST-compatible endpoints for your tRPC procedures.\n</Callout>\n\n## Creating a Router with Typed Metadata\n\nFirst, define your metadata interface and create a tRPC instance with typed metadata:\n\n```ts title=\"server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\n\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin';\n  rateLimit?: number;\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n```\n\n## Basic Usage\n\n### Adding Metadata to Procedures\n\nAdd metadata to individual procedures using the `.meta()` method:\n\n```ts title=\"server/routers/posts.ts\"\nimport { publicProcedure, router } from '../trpc';\nimport { z } from 'zod';\n\nexport const postsRouter = router({\n  // Public endpoint - no auth required\n  list: publicProcedure\n    .meta({ authRequired: false })\n    .query(() => {\n      return getPosts();\n    }),\n\n  // Protected endpoint - auth required\n  create: publicProcedure\n    .meta({ authRequired: true, role: 'user' })\n    .input(z.object({ title: z.string() }))\n    .mutation(({ input }) => {\n      return createPost(input);\n    }),\n\n  // Admin-only endpoint\n  delete: publicProcedure\n    .meta({ authRequired: true, role: 'admin' })\n    .input(z.object({ id: z.string() }))\n    .mutation(({ input }) => {\n      return deletePost(input.id);\n    }),\n});\n```\n\n### Accessing Metadata in Middleware\n\nUse metadata to create conditional middleware:\n\n```ts title=\"server/middleware/auth.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { publicProcedure } from '../trpc';\n\nexport const authMiddleware = publicProcedure.use(async (opts) => {\n  const { meta, ctx } = opts;\n\n  // Only check authorization if enabled in metadata\n  if (meta?.authRequired && !ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  // Check role if specified\n  if (meta?.role && ctx.user?.role !== meta.role) {\n    throw new TRPCError({ code: 'FORBIDDEN' });\n  }\n\n  return opts.next();\n});\n```\n\n## Advanced Patterns\n\n### Per-Route Authentication Settings\n\nCreate a flexible authentication system using metadata:\n\n```ts title=\"server/trpc.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\n\ninterface Meta {\n  authRequired: boolean;\n  roles?: string[];\n  permissions?: string[];\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const authProcedure = t.procedure.use(async (opts) => {\n  const { meta, ctx } = opts;\n\n  // Skip auth check if not required\n  if (!meta?.authRequired) {\n    return opts.next();\n  }\n\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  // Check roles if specified\n  if (meta.roles && !meta.roles.includes(ctx.user.role)) {\n    throw new TRPCError({ code: 'FORBIDDEN' });\n  }\n\n  // Check permissions if specified\n  if (meta.permissions) {\n    const hasPermission = meta.permissions.every(permission =>\n      ctx.user.permissions.includes(permission)\n    );\n\n    if (!hasPermission) {\n      throw new TRPCError({ code: 'FORBIDDEN' });\n    }\n  }\n\n  return opts.next({\n    ctx: {\n      user: ctx.user, // User is guaranteed to exist\n    },\n  });\n});\n\nexport const appRouter = t.router({\n  // Public endpoint\n  hello: authProcedure\n    .meta({ authRequired: false })\n    .query(() => 'Hello world'),\n\n  // User endpoint\n  profile: authProcedure\n    .meta({\n      authRequired: true,\n      roles: ['user', 'admin']\n    })\n    .query(({ ctx }) => ctx.user),\n\n  // Admin endpoint with specific permissions\n  users: authProcedure\n    .meta({\n      authRequired: true,\n      roles: ['admin'],\n      permissions: ['users:read']\n    })\n    .query(() => getAllUsers()),\n});\n```\n\n### Rate Limiting with Metadata\n\nImplement rate limiting based on procedure metadata:\n\n```ts title=\"server/middleware/rateLimit.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { publicProcedure } from '../trpc';\n\nconst rateLimitMap = new Map<string, number[]>();\n\nexport const rateLimitMiddleware = publicProcedure.use(async (opts) => {\n  const { meta, ctx } = opts;\n\n  // Skip rate limiting if not specified\n  if (!meta?.rateLimit) {\n    return opts.next();\n  }\n\n  const key = `${ctx.ip}-${opts.path}`;\n  const now = Date.now();\n  const windowMs = 60 * 1000; // 1 minute window\n\n  const requests = rateLimitMap.get(key) || [];\n  const recentRequests = requests.filter(time => now - time < windowMs);\n\n  if (recentRequests.length >= meta.rateLimit) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: 'Rate limit exceeded',\n    });\n  }\n\n  recentRequests.push(now);\n  rateLimitMap.set(key, recentRequests);\n\n  return opts.next();\n});\n\n// Usage in procedures\nexport const apiRouter = router({\n  search: rateLimitMiddleware\n    .meta({ rateLimit: 10 }) // 10 requests per minute\n    .input(z.object({ query: z.string() }))\n    .query(({ input }) => search(input.query)),\n\n  upload: rateLimitMiddleware\n    .meta({ rateLimit: 5 }) // 5 uploads per minute\n    .input(z.object({ file: z.string() }))\n    .mutation(({ input }) => uploadFile(input.file)),\n});\n```\n\n## Default Meta and Chaining\n\n### Setting Default Values\n\nYou can set default metadata values when creating the tRPC instance:\n\n```ts title=\"server/trpc.ts\"\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin';\n  cached?: boolean;\n}\n\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    // Set default metadata\n    defaultMeta: {\n      authRequired: false,\n      cached: true\n    }\n  });\n```\n\n### Metadata Merging\n\nWhen chaining procedures, metadata is shallow merged:\n\n```ts title=\"server/procedures.ts\"\nconst baseProcedure = publicProcedure\n  .meta({\n    authRequired: true,\n    role: 'user'\n  });\n\nconst adminProcedure = baseProcedure\n  .meta({\n    role: 'admin', // Overrides 'user'\n    permissions: ['admin:read'] // Adds new field\n  });\n// Final meta: { authRequired: true, role: 'admin', permissions: ['admin:read'] }\n```\n\n## OpenAPI Integration\n\n### REST Endpoint Generation\n\nUse metadata to generate REST endpoints with `trpc-openapi`:\n\n```ts title=\"server/routers/api.ts\"\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\n\nexport const apiRouter = router({\n  getUser: publicProcedure\n    .meta({\n      openapi: {\n        method: 'GET',\n        path: '/users/{id}',\n        tags: ['users'],\n        summary: 'Get user by ID',\n      }\n    })\n    .input(z.object({ id: z.string() }))\n    .output(z.object({\n      id: z.string(),\n      name: z.string(),\n      email: z.string(),\n    }))\n    .query(({ input }) => getUserById(input.id)),\n\n  createUser: publicProcedure\n    .meta({\n      openapi: {\n        method: 'POST',\n        path: '/users',\n        tags: ['users'],\n        summary: 'Create a new user',\n      }\n    })\n    .input(z.object({\n      name: z.string(),\n      email: z.string().email(),\n    }))\n    .output(z.object({\n      id: z.string(),\n      name: z.string(),\n      email: z.string(),\n    }))\n    .mutation(({ input }) => createUser(input)),\n});\n```\n\n## Best Practices\n\n<Steps>\n\n### Keep Metadata Simple\n\nDon't overload metadata with complex objects. Keep it simple and focused:\n\n```ts\n// ‚úÖ Good - simple, focused metadata\ninterface Meta {\n  authRequired: boolean;\n  rateLimit?: number;\n  cacheTime?: number;\n}\n\n// ‚ùå Avoid - complex nested objects\ninterface Meta {\n  auth: {\n    required: boolean;\n    roles: string[];\n    permissions: {\n      read: boolean;\n      write: boolean;\n      admin: boolean;\n    };\n  };\n}\n```\n\n### Use Consistent Naming\n\nEstablish consistent naming conventions for your metadata:\n\n```ts\ninterface Meta {\n  // Use consistent boolean naming\n  authRequired: boolean;    // not needsAuth\n  cacheEnabled: boolean;    // not shouldCache\n\n  // Use consistent array naming\n  requiredRoles: string[];  // not roles\n  allowedMethods: string[]; // not methods\n}\n```\n\n### Document Your Metadata\n\nCreate clear documentation for your metadata schema:\n\n```ts\n/**\n * Metadata interface for tRPC procedures\n */\ninterface Meta {\n  /** Whether authentication is required for this procedure */\n  authRequired: boolean;\n\n  /** Required user roles (user must have at least one) */\n  requiredRoles?: ('user' | 'admin' | 'moderator')[];\n\n  /** Rate limit per minute for this procedure */\n  rateLimit?: number;\n\n  /** Cache time in seconds (0 = no cache) */\n  cacheTime?: number;\n}\n```\n\n### Validate Metadata\n\nConsider validating metadata at build time:\n\n```ts\nimport { z } from 'zod';\n\nconst metaSchema = z.object({\n  authRequired: z.boolean(),\n  requiredRoles: z.array(z.enum(['user', 'admin'])).optional(),\n  rateLimit: z.number().positive().optional(),\n});\n\n// Use in development to validate metadata\nconst validateMeta = (meta: unknown) => {\n  return metaSchema.parse(meta);\n};\n```\n\n</Steps>\n\n## Common Use Cases\n\n### API Documentation\n\nGenerate API documentation based on metadata:\n\n```ts\ninterface Meta {\n  description?: string;\n  deprecated?: boolean;\n  version?: string;\n  tags?: string[];\n}\n\nexport const apiRouter = router({\n  getPost: publicProcedure\n    .meta({\n      description: 'Retrieve a blog post by ID',\n      tags: ['posts', 'public'],\n      version: '1.0'\n    })\n    .input(z.object({ id: z.string() }))\n    .query(({ input }) => getPost(input.id)),\n});\n```\n\n### Feature Flags\n\nControl feature availability with metadata:\n\n```ts\ninterface Meta {\n  feature?: string;\n  beta?: boolean;\n}\n\nconst featureMiddleware = publicProcedure.use(async (opts) => {\n  const { meta, ctx } = opts;\n\n  if (meta?.feature && !ctx.features?.includes(meta.feature)) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: 'Feature not available'\n    });\n  }\n\n  if (meta?.beta && !ctx.user?.betaAccess) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Beta access required'\n    });\n  }\n\n  return opts.next();\n});\n```\n\n### Logging and Analytics\n\nAdd tracking information with metadata:\n\n```ts\ninterface Meta {\n  trackingEvent?: string;\n  sensitive?: boolean;\n}\n\nconst analyticsMiddleware = publicProcedure.use(async (opts) => {\n  const { meta, path } = opts;\n\n  // Track API usage\n  if (meta?.trackingEvent) {\n    analytics.track(meta.trackingEvent, {\n      procedure: path,\n      userId: opts.ctx.user?.id,\n    });\n  }\n\n  // Skip logging sensitive procedures\n  if (!meta?.sensitive) {\n    logger.info(`Procedure called: ${path}`);\n  }\n\n  return opts.next();\n});\n```\n\n<Callout type=\"info\">\n  Metadata is a powerful feature that enables many advanced use cases. Start\n  simple and gradually add more sophisticated metadata as your application\n  grows.\n</Callout>\n"}, {"info":{"path":"server/middlewares.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/middlewares.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Middlewares","description":"Add authentication, logging, and custom logic to your tRPC procedures","icon":"IconStack3","index":false},"content":"\nMiddlewares allow you to add reusable logic that runs before your procedure handlers. They're perfect for authentication, logging, validation, rate limiting, and other cross-cutting concerns.\n\n<Callout title=\"Middleware Benefits\">\n  - **Reusability**: Share logic across multiple procedures - **Composability**:\n  Chain middlewares to build complex behavior - **Type Safety**: Maintain full\n  TypeScript inference - **Context Extension**: Add data to context for\n  downstream procedures\n</Callout>\n\n## Basic Middleware\n\n### Simple Logging Middleware\n\n```typescript title=\"src/middleware.ts\"\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create();\n\n// Basic logging middleware\nconst loggerMiddleware = t.middleware(({ path, type, next }) => {\n  const start = Date.now();\n\n  console.log(`‚û°Ô∏è ${type.toUpperCase()} ${path} - Started`);\n\n  return next().finally(() => {\n    const duration = Date.now() - start;\n    console.log(`‚¨ÖÔ∏è ${type.toUpperCase()} ${path} - Completed in ${duration}ms`);\n  });\n});\n\n// Create procedure with middleware\nexport const loggedProcedure = t.procedure.use(loggerMiddleware);\n\n// Usage in router\nexport const appRouter = t.router({\n  hello: loggedProcedure.query(() => {\n    return { message: 'Hello World!' };\n  }),\n\n  createUser: loggedProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(({ input }) => {\n      return { id: '1', name: input.name };\n    }),\n});\n```\n\n### Timing and Performance Middleware\n\n```typescript title=\"src/performance-middleware.ts\"\nconst performanceMiddleware = t.middleware(async ({ path, type, next }) => {\n  const start = performance.now();\n\n  const result = await next();\n\n  const duration = performance.now() - start;\n\n  // Log slow queries\n  if (duration > 1000) {\n    console.warn(`üêå Slow ${type}: ${path} took ${duration.toFixed(2)}ms`);\n  }\n\n  // Add performance headers\n  if (result.ok) {\n    // You could add duration to response or headers here\n    console.log(`‚ö° ${type} ${path}: ${duration.toFixed(2)}ms`);\n  }\n\n  return result;\n});\n\nexport const timedProcedure = t.procedure.use(performanceMiddleware);\n```\n\n## Authentication Middleware\n\n### Basic Authentication\n\n```typescript title=\"src/auth-middleware.ts\"\nimport { TRPCError } from '@trpc/server';\n\nconst authMiddleware = t.middleware(({ ctx, next }) => {\n  // Check if user is authenticated\n  if (!ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Authentication required',\n    });\n  }\n\n  return next({\n    ctx: {\n      // Extend context with verified user\n      ...ctx,\n      user: ctx.user, // Now guaranteed to be non-null\n    },\n  });\n});\n\nexport const protectedProcedure = t.procedure.use(authMiddleware);\n```\n\n### Role-Based Authorization\n\n```typescript title=\"src/rbac-middleware.ts\"\n// Create role-based middleware\nconst requireRole = (allowedRoles: string[]) => {\n  return t.middleware(({ ctx, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    if (!allowedRoles.includes(ctx.user.role)) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: `Required roles: ${allowedRoles.join(', ')}`,\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user: ctx.user, // TypeScript knows user exists\n      },\n    });\n  });\n};\n\n// Create different procedure types\nexport const adminProcedure = t.procedure.use(requireRole(['admin']));\nexport const moderatorProcedure = t.procedure.use(requireRole(['admin', 'moderator']));\nexport const userProcedure = t.procedure.use(requireRole(['admin', 'moderator', 'user']));\n\n// Usage in router\nexport const appRouter = t.router({\n  // Admin only\n  deleteAllUsers: adminProcedure.mutation(() => {\n    return deleteAllUsers();\n  }),\n\n  // Moderator or admin\n  banUser: moderatorProcedure\n    .input(z.object({ userId: z.string() }))\n    .mutation(({ input }) => {\n      return banUser(input.userId);\n    }),\n\n  // Any authenticated user\n  updateProfile: userProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(({ input, ctx }) => {\n      return updateUserProfile(ctx.user.id, input);\n    }),\n});\n```\n\n### JWT Authentication\n\n```typescript title=\"src/jwt-middleware.ts\"\nimport jwt from 'jsonwebtoken';\n\nconst jwtMiddleware = t.middleware(async ({ ctx, next }) => {\n  const token = ctx.req.headers.authorization?.replace('Bearer ', '');\n\n  if (!token) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'No token provided',\n    });\n  }\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {\n      userId: string;\n      role: string;\n    };\n\n    // Fetch full user data\n    const user = await getUserById(decoded.userId);\n\n    if (!user) {\n      throw new TRPCError({\n        code: 'UNAUTHORIZED',\n        message: 'Invalid token',\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user,\n        token: decoded,\n      },\n    });\n  } catch (error) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'Invalid or expired token',\n    });\n  }\n});\n\nexport const jwtProcedure = t.procedure.use(jwtMiddleware);\n```\n\n## Advanced Middleware Patterns\n\n### Context Extension\n\nMiddleware can extend the context with additional data:\n\n```typescript title=\"src/context-extension.ts\"\n// Organization middleware\nconst withOrganization = t.middleware(async ({ ctx, input, next }) => {\n  const organizationId = (input as any)?.organizationId;\n\n  if (!organizationId) {\n    throw new TRPCError({\n      code: 'BAD_REQUEST',\n      message: 'Organization ID required',\n    });\n  }\n\n  const organization = await getOrganization(organizationId);\n\n  if (!organization) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: 'Organization not found',\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      organization,\n    },\n  });\n});\n\n// Database transaction middleware\nconst withTransaction = t.middleware(async ({ ctx, next }) => {\n  return await db.transaction(async (tx) => {\n    return next({\n      ctx: {\n        ...ctx,\n        db: tx, // Replace db with transaction instance\n      },\n    });\n  });\n});\n\n// Usage\nexport const organizationProcedure = t.procedure\n  .use(authMiddleware)\n  .use(withOrganization);\n\nexport const transactionalProcedure = t.procedure\n  .use(authMiddleware)\n  .use(withTransaction);\n```\n\n### Validation Middleware\n\n```typescript title=\"src/validation-middleware.ts\"\n// Input validation middleware\nconst validateSchema = <T>(schema: z.ZodSchema<T>) => {\n  return t.middleware(({ input, next }) => {\n    const validated = schema.parse(input);\n\n    return next({\n      ctx: {\n        validatedInput: validated,\n      },\n    });\n  });\n};\n\n// Rate limiting middleware\nconst rateLimit = (limit: number, windowMs: number) => {\n  const attempts = new Map<string, { count: number; resetTime: number }>();\n\n  return t.middleware(({ ctx, next }) => {\n    const identifier = ctx.user?.id || ctx.req.ip || 'anonymous';\n    const now = Date.now();\n\n    const userAttempts = attempts.get(identifier);\n\n    if (!userAttempts || now > userAttempts.resetTime) {\n      attempts.set(identifier, { count: 1, resetTime: now + windowMs });\n    } else {\n      userAttempts.count++;\n\n      if (userAttempts.count > limit) {\n        throw new TRPCError({\n          code: 'TOO_MANY_REQUESTS',\n          message: 'Rate limit exceeded',\n        });\n      }\n    }\n\n    return next();\n  });\n};\n\n// Usage\nexport const rateLimitedProcedure = t.procedure\n  .use(rateLimit(10, 60000)); // 10 requests per minute\n```\n\n### Caching Middleware\n\n```typescript title=\"src/cache-middleware.ts\"\n// Simple in-memory cache middleware\nconst cache = new Map<string, { data: any; expiry: number }>();\n\nconst withCache = (ttlMs: number = 60000) => {\n  return t.middleware(async ({ path, input, next }) => {\n    const cacheKey = `${path}:${JSON.stringify(input)}`;\n    const cached = cache.get(cacheKey);\n\n    if (cached && Date.now() < cached.expiry) {\n      console.log(`üéØ Cache hit: ${cacheKey}`);\n      return { ok: true, data: cached.data };\n    }\n\n    const result = await next();\n\n    if (result.ok) {\n      cache.set(cacheKey, {\n        data: result.data,\n        expiry: Date.now() + ttlMs,\n      });\n      console.log(`üíæ Cached: ${cacheKey}`);\n    }\n\n    return result;\n  });\n};\n\n// Redis cache middleware\nconst withRedisCache = (ttlSeconds: number = 60) => {\n  return t.middleware(async ({ path, input, next }) => {\n    const cacheKey = `trpc:${path}:${JSON.stringify(input)}`;\n\n    try {\n      const cached = await redis.get(cacheKey);\n      if (cached) {\n        console.log(`üéØ Redis cache hit: ${cacheKey}`);\n        return { ok: true, data: JSON.parse(cached) };\n      }\n    } catch (error) {\n      console.warn('Cache read error:', error);\n    }\n\n    const result = await next();\n\n    if (result.ok) {\n      try {\n        await redis.setex(cacheKey, ttlSeconds, JSON.stringify(result.data));\n        console.log(`üíæ Redis cached: ${cacheKey}`);\n      } catch (error) {\n        console.warn('Cache write error:', error);\n      }\n    }\n\n    return result;\n  });\n};\n\n// Usage\nexport const cachedProcedure = t.procedure.use(withCache(300000)); // 5 minutes\nexport const redisCachedProcedure = t.procedure.use(withRedisCache(600)); // 10 minutes\n```\n\n## Middleware Chaining\n\nCombine multiple middlewares for complex behavior:\n\n```typescript title=\"src/chained-middleware.ts\"\n// Create a base procedure with multiple middlewares\nexport const fullProcedure = t.procedure\n  .use(loggerMiddleware)           // 1. Log the request\n  .use(performanceMiddleware)      // 2. Time the execution\n  .use(authMiddleware)             // 3. Authenticate user\n  .use(rateLimit(100, 60000))      // 4. Apply rate limiting\n  .use(withCache(60000));          // 5. Check cache\n\n// Specific procedure types\nexport const adminProcedure = fullProcedure\n  .use(requireRole(['admin']));\n\nexport const organizationProcedure = fullProcedure\n  .use(withOrganization);\n\nexport const transactionalOrganizationProcedure = organizationProcedure\n  .use(withTransaction);\n```\n\n### Conditional Middleware\n\n```typescript title=\"src/conditional-middleware.ts\"\n// Development-only middleware\nconst devOnlyMiddleware = t.middleware(({ next }) => {\n  if (process.env.NODE_ENV !== 'development') {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: 'Endpoint not available in production',\n    });\n  }\n  return next();\n});\n\n// Feature flag middleware\nconst withFeatureFlag = (flagName: string) => {\n  return t.middleware(async ({ ctx, next }) => {\n    const isEnabled = await checkFeatureFlag(flagName, ctx.user?.id);\n\n    if (!isEnabled) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Feature not available',\n      });\n    }\n\n    return next();\n  });\n};\n\n// IP allowlist middleware\nconst ipAllowlist = (allowedIPs: string[]) => {\n  return t.middleware(({ ctx, next }) => {\n    const clientIP = ctx.req.ip || ctx.req.connection.remoteAddress;\n\n    if (!allowedIPs.includes(clientIP)) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: 'IP not allowed',\n      });\n    }\n\n    return next();\n  });\n};\n\n// Usage\nexport const devProcedure = t.procedure.use(devOnlyMiddleware);\nexport const betaFeatureProcedure = t.procedure.use(withFeatureFlag('beta-features'));\nexport const adminIPProcedure = t.procedure.use(ipAllowlist(['10.0.0.1', '10.0.0.2']));\n```\n\n## Middleware Piping\n\nUse `.unstable_pipe()` to extend existing middlewares:\n\n```typescript title=\"src/piped-middleware.ts\"\n// Base authentication middleware\nconst baseAuth = t.middleware(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({ ctx: { ...ctx, user: ctx.user } });\n});\n\n// Extend base auth with role checking\nconst adminAuth = baseAuth.unstable_pipe(({ ctx, next }) => {\n  if (ctx.user.role !== 'admin') {\n    throw new TRPCError({ code: 'FORBIDDEN' });\n  }\n  return next();\n});\n\n// Extend admin auth with audit logging\nconst auditedAdminAuth = adminAuth.unstable_pipe(async ({ ctx, path, next }) => {\n  // Log admin action\n  await auditLog({\n    userId: ctx.user.id,\n    action: path,\n    timestamp: new Date(),\n  });\n\n  const result = await next();\n\n  // Log completion\n  await auditLog({\n    userId: ctx.user.id,\n    action: `${path}_completed`,\n    timestamp: new Date(),\n  });\n\n  return result;\n});\n\nexport const auditedAdminProcedure = t.procedure.use(auditedAdminAuth);\n```\n\n## Error Handling in Middleware\n\n```typescript title=\"src/error-middleware.ts\"\n// Error handling middleware\nconst errorHandler = t.middleware(async ({ next, path, type }) => {\n  try {\n    return await next();\n  } catch (error) {\n    // Log error\n    console.error(`Error in ${type} ${path}:`, error);\n\n    // Transform known errors\n    if (error instanceof DatabaseError) {\n      throw new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'Database operation failed',\n        cause: error,\n      });\n    }\n\n    if (error instanceof ValidationError) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: error.message,\n        cause: error,\n      });\n    }\n\n    // Re-throw tRPC errors as-is\n    if (error instanceof TRPCError) {\n      throw error;\n    }\n\n    // Unknown error\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred',\n      cause: error,\n    });\n  }\n});\n\n// Retry middleware for idempotent operations\nconst withRetry = (maxRetries: number = 3) => {\n  return t.middleware(async ({ next }) => {\n    let lastError: Error | undefined;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await next();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry client errors\n        if (error instanceof TRPCError &&\n            ['BAD_REQUEST', 'UNAUTHORIZED', 'FORBIDDEN'].includes(error.code)) {\n          throw error;\n        }\n\n        if (attempt === maxRetries) {\n          break;\n        }\n\n        // Exponential backoff\n        await new Promise(resolve =>\n          setTimeout(resolve, Math.pow(2, attempt) * 100)\n        );\n      }\n    }\n\n    throw lastError;\n  });\n};\n\nexport const resilientProcedure = t.procedure\n  .use(errorHandler)\n  .use(withRetry(3));\n```\n\n## Testing Middleware\n\n```typescript title=\"src/middleware.test.ts\"\nimport { describe, it, expect, vi } from 'vitest';\nimport { createCallerFactory } from '@trpc/server';\n\ndescribe('Authentication Middleware', () => {\n  const createCaller = createCallerFactory(appRouter);\n\n  it('should allow authenticated users', async () => {\n    const caller = createCaller({\n      user: { id: 'user1', role: 'user' },\n    });\n\n    const result = await caller.protected.getProfile();\n    expect(result).toBeDefined();\n  });\n\n  it('should reject unauthenticated users', async () => {\n    const caller = createCaller({\n      user: null,\n    });\n\n    await expect(\n      caller.protected.getProfile()\n    ).rejects.toThrow('UNAUTHORIZED');\n  });\n\n  it('should enforce role-based access', async () => {\n    const userCaller = createCaller({\n      user: { id: 'user1', role: 'user' },\n    });\n\n    await expect(\n      userCaller.admin.deleteUser({ id: 'user2' })\n    ).rejects.toThrow('FORBIDDEN');\n  });\n});\n\ndescribe('Rate Limiting Middleware', () => {\n  it('should allow requests within limit', async () => {\n    const caller = createCaller({});\n\n    // Should succeed for requests within limit\n    for (let i = 0; i < 5; i++) {\n      await expect(caller.rateLimited.hello()).resolves.toBeDefined();\n    }\n  });\n\n  it('should reject requests exceeding limit', async () => {\n    const caller = createCaller({});\n\n    // Exhaust rate limit\n    for (let i = 0; i < 10; i++) {\n      await caller.rateLimited.hello().catch(() => {});\n    }\n\n    // Next request should fail\n    await expect(\n      caller.rateLimited.hello()\n    ).rejects.toThrow('TOO_MANY_REQUESTS');\n  });\n});\n```\n\n## Best Practices\n\n<Accordions>\n  <Accordion title=\"Performance\">\n    - **Minimize middleware overhead**: Keep middleware logic lightweight\n    - **Cache expensive operations**: Don't repeat work in each middleware\n    - **Use early returns**: Fail fast when validation fails\n    - **Optimize middleware order**: Put cheap validations first\n    \n    ```typescript\n    // Good: Fast checks first\n    const optimizedProcedure = t.procedure\n      .use(simpleAuthCheck)       // Fast\n      .use(rateLimitCheck)        // Medium\n      .use(expensiveValidation);  // Slow\n    \n    // Bad: Expensive operations first\n    const badProcedure = t.procedure\n      .use(expensiveValidation)   // Slow first\n      .use(simpleAuthCheck);      // Fast last\n    ```\n  </Accordion>\n\n  <Accordion title=\"Error Handling\">\n    - **Use appropriate error codes**: Return correct HTTP status codes\n    - **Provide helpful messages**: Help developers debug issues\n    - **Log errors appropriately**: Don't lose important error information\n    - **Handle async errors**: Always await or catch async operations\n    \n    ```typescript\n    const safeMiddleware = t.middleware(async ({ next }) => {\n      try {\n        return await next();\n      } catch (error) {\n        // Log for debugging\n        console.error('Middleware error:', error);\n        \n        // Re-throw with context\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'Middleware failed',\n          cause: error,\n        });\n      }\n    });\n    ```\n  </Accordion>\n\n  <Accordion title=\"Security\">\n    - **Validate all inputs**: Don't trust middleware inputs\n    - **Sanitize context data**: Clean user-provided data\n    - **Use least privilege**: Only add necessary permissions\n    - **Audit sensitive operations**: Log important actions\n    \n    ```typescript\n    const secureMiddleware = t.middleware(({ ctx, input, next }) => {\n      // Validate context\n      if (!ctx.user || !ctx.user.id) {\n        throw new TRPCError({ code: 'UNAUTHORIZED' });\n      }\n      \n      // Sanitize inputs\n      const sanitizedInput = sanitizeInput(input);\n      \n      return next({\n        ctx: {\n          ...ctx,\n          user: {\n            id: ctx.user.id,\n            role: ctx.user.role,\n            // Don't pass sensitive data\n          },\n        },\n      });\n    });\n    ```\n  </Accordion>\n\n  <Accordion title=\"Type Safety\">\n    - **Extend context properly**: Maintain type inference\n    - **Use generic middleware**: Make middleware reusable\n    - **Type middleware inputs**: Ensure type safety\n    - **Document middleware behavior**: Help other developers\n    \n    ```typescript\n    // Generic typed middleware\n    const withValidation = <T>(schema: z.ZodSchema<T>) => {\n      return t.middleware(({ input, next }) => {\n        const validated = schema.parse(input);\n        return next({\n          ctx: {\n            validatedInput: validated,\n          },\n        });\n      });\n    };\n    \n    // Usage maintains types\n    const typedProcedure = t.procedure\n      .use(withValidation(UserSchema))\n      .mutation(({ ctx }) => {\n        // ctx.validatedInput is properly typed\n        return processUser(ctx.validatedInput);\n      });\n    ```\n  </Accordion>\n</Accordions>\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Authorization\" href=\"/docs/server/authorization\">\n    Learn advanced authentication and authorization patterns\n  </Card>\n  <Card title=\"Context\" href=\"/docs/server/context\">\n    Understand how to create and extend context\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Master error handling in middleware and procedures\n  </Card>\n  <Card title=\"Server-Side Calls\" href=\"/docs/server/server-side-calls\">\n    Test your middleware with server-side callers\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/procedures.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/procedures.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Define Procedures","description":"Create queries, mutations, and subscriptions with full type safety","icon":"IconCode","index":false},"content":"\nProcedures are the core building blocks of your tRPC API. They are functions exposed to the client that can be one of three types: **queries** (for fetching data), **mutations** (for changing data), or **subscriptions** (for real-time updates).\n\n<Callout title=\"Type-Safe by Design\">\n  tRPC procedures provide automatic TypeScript inference from server to client,\n  eliminating the need for manual type definitions or code generation.\n</Callout>\n\n## Procedure Types\n\n<Cards>\n  <Card title=\"Query\" icon=\"üìñ\">\n    **Read operations** - Used to fetch data, generally doesn't change server\n    state\n  </Card>\n  <Card title=\"Mutation\" icon=\"‚úèÔ∏è\">\n    **Write operations** - Used to create, update, or delete data on the server\n  </Card>\n  <Card title=\"Subscription\" icon=\"üîÑ\">\n    **Real-time updates** - Used for live data streams and real-time\n    functionality\n  </Card>\n</Cards>\n\n## Basic Procedures\n\n### Query Procedures\n\nUse queries for reading data without side effects:\n\n```typescript title=\"server/router.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Simple query without input\n  hello: t.procedure.query(() => {\n    return { message: 'Hello World!' };\n  }),\n\n  // Query with input validation\n  getUser: t.procedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      // input is automatically typed as string\n      const user = await db.user.findUnique({\n        where: { id: input },\n      });\n\n      if (!user) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'User not found',\n        });\n      }\n\n      return user;\n    }),\n\n  // Query with complex input\n  getUserPosts: t.procedure\n    .input(z.object({\n      userId: z.string(),\n      limit: z.number().min(1).max(100).default(10),\n      cursor: z.string().optional(),\n    }))\n    .query(async ({ input }) => {\n      const posts = await db.post.findMany({\n        where: { authorId: input.userId },\n        take: input.limit + 1,\n        cursor: input.cursor ? { id: input.cursor } : undefined,\n        orderBy: { createdAt: 'desc' },\n      });\n\n      const hasMore = posts.length > input.limit;\n      const items = hasMore ? posts.slice(0, -1) : posts;\n\n      return {\n        items,\n        nextCursor: hasMore ? items[items.length - 1].id : undefined,\n      };\n    }),\n});\n```\n\n### Mutation Procedures\n\nUse mutations for operations that change server state:\n\n```typescript title=\"server/mutations.ts\"\nexport const mutationRouter = t.router({\n  // Simple mutation\n  createPost: t.procedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string(),\n      authorId: z.string(),\n    }))\n    .mutation(async ({ input }) => {\n      const post = await db.post.create({\n        data: input,\n        include: { author: true },\n      });\n\n      return post;\n    }),\n\n  // Mutation with conditional logic\n  updatePost: t.procedure\n    .input(z.object({\n      id: z.string(),\n      title: z.string().optional(),\n      content: z.string().optional(),\n      published: z.boolean().optional(),\n    }))\n    .mutation(async ({ input }) => {\n      const { id, ...updates } = input;\n\n      // Only update fields that were provided\n      const post = await db.post.update({\n        where: { id },\n        data: Object.fromEntries(\n          Object.entries(updates).filter(([, value]) => value !== undefined)\n        ),\n      });\n\n      return post;\n    }),\n\n  // Mutation with side effects\n  deletePost: t.procedure\n    .input(z.string())\n    .mutation(async ({ input }) => {\n      // Delete associated data first\n      await db.comment.deleteMany({\n        where: { postId: input },\n      });\n\n      // Delete the post\n      const deletedPost = await db.post.delete({\n        where: { id: input },\n      });\n\n      // Trigger side effects (notifications, cache invalidation, etc.)\n      await notificationService.notifyPostDeleted(deletedPost);\n      await cacheService.invalidatePost(input);\n\n      return { success: true, deletedId: input };\n    }),\n});\n```\n\n### Subscription Procedures\n\nUse subscriptions for real-time data streams:\n\n```typescript title=\"server/subscriptions.ts\"\nimport { observable } from '@trpc/server/observable';\nimport EventEmitter from 'events';\n\nconst eventEmitter = new EventEmitter();\n\nexport const subscriptionRouter = t.router({\n  // Simple subscription\n  onPostAdd: t.procedure.subscription(() => {\n    return observable<Post>((emit) => {\n      const handler = (post: Post) => {\n        emit.next(post);\n      };\n\n      eventEmitter.on('postAdded', handler);\n\n      // Cleanup when subscription ends\n      return () => {\n        eventEmitter.off('postAdded', handler);\n      };\n    });\n  }),\n\n  // Subscription with input\n  onUserPostAdd: t.procedure\n    .input(z.object({ userId: z.string() }))\n    .subscription(({ input }) => {\n      return observable<Post>((emit) => {\n        const handler = (post: Post) => {\n          if (post.authorId === input.userId) {\n            emit.next(post);\n          }\n        };\n\n        eventEmitter.on('postAdded', handler);\n\n        return () => {\n          eventEmitter.off('postAdded', handler);\n        };\n      });\n    }),\n\n  // Subscription with periodic updates\n  serverStats: t.procedure.subscription(() => {\n    return observable<ServerStats>((emit) => {\n      const interval = setInterval(async () => {\n        const stats = await getServerStats();\n        emit.next(stats);\n      }, 5000); // Every 5 seconds\n\n      return () => {\n        clearInterval(interval);\n      };\n    });\n  }),\n});\n```\n\n## Input & Output Validation\n\n### Input Validation\n\nAlways validate inputs to ensure type safety and security:\n\n```typescript title=\"server/validation.ts\"\nexport const validatedRouter = t.router({\n  createUser: t.procedure\n    .input(z.object({\n      email: z.string().email('Invalid email format'),\n      name: z.string().min(2, 'Name must be at least 2 characters'),\n      age: z.number().int().min(13, 'Must be at least 13 years old'),\n      role: z.enum(['user', 'admin']).default('user'),\n      preferences: z.object({\n        theme: z.enum(['light', 'dark']).default('light'),\n        notifications: z.boolean().default(true),\n      }).optional(),\n    }))\n    .mutation(async ({ input }) => {\n      // input is fully typed and validated\n      return await db.user.create({ data: input });\n    }),\n\n  // Complex validation with custom logic\n  updateUserProfile: t.procedure\n    .input(z.object({\n      userId: z.string(),\n      updates: z.object({\n        bio: z.string().max(500).optional(),\n        website: z.string().url().optional(),\n        location: z.string().max(100).optional(),\n      }),\n    }))\n    .mutation(async ({ input }) => {\n      // Custom validation logic\n      if (input.updates.website &&\n          !input.updates.website.startsWith('https://')) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'Website must use HTTPS',\n        });\n      }\n\n      return await db.user.update({\n        where: { id: input.userId },\n        data: input.updates,\n      });\n    }),\n});\n```\n\n### Output Validation\n\nWhile optional, output validation can catch bugs and ensure consistency:\n\n```typescript title=\"server/output-validation.ts\"\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  name: z.string(),\n  createdAt: z.date(),\n});\n\nexport const outputValidatedRouter = t.router({\n  getUser: t.procedure\n    .input(z.string())\n    .output(UserSchema)\n    .query(async ({ input }) => {\n      const user = await db.user.findUnique({ where: { id: input } });\n      if (!user) {\n        throw new TRPCError({ code: 'NOT_FOUND' });\n      }\n\n      // Output will be validated against UserSchema\n      return user;\n    }),\n\n  // Array output validation\n  getUserList: t.procedure\n    .output(z.array(UserSchema))\n    .query(async () => {\n      return await db.user.findMany();\n    }),\n});\n```\n\n## Reusable Base Procedures\n\nCreate reusable base procedures for common patterns:\n\n```typescript title=\"server/base-procedures.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nconst t = initTRPC.context<Context>().create();\n\n// Public procedure (anyone can call)\nexport const publicProcedure = t.procedure;\n\n// Authenticated procedure\nexport const authedProcedure = t.procedure.use(async ({ ctx, next }) => {\n  if (!ctx.session?.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.session.user, // User is guaranteed to exist\n    },\n  });\n});\n\n// Admin procedure\nexport const adminProcedure = authedProcedure.use(async ({ ctx, next }) => {\n  if (ctx.user.role !== 'admin') {\n    throw new TRPCError({ code: 'FORBIDDEN' });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      user: ctx.user, // Admin user\n    },\n  });\n});\n\n// Rate limited procedure\nexport const rateLimitedProcedure = publicProcedure.use(async ({ ctx, next }) => {\n  const clientId = ctx.req.ip || 'unknown';\n  const isAllowed = await rateLimiter.check(clientId);\n\n  if (!isAllowed) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: 'Rate limit exceeded',\n    });\n  }\n\n  return next();\n});\n\n// Organization-specific procedure\nexport const organizationProcedure = authedProcedure\n  .input(z.object({ organizationId: z.string() }))\n  .use(async ({ input, ctx, next }) => {\n    const membership = await db.membership.findUnique({\n      where: {\n        userId_organizationId: {\n          userId: ctx.user.id,\n          organizationId: input.organizationId,\n        },\n      },\n      include: { organization: true },\n    });\n\n    if (!membership) {\n      throw new TRPCError({ code: 'FORBIDDEN' });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        organization: membership.organization,\n        membership,\n      },\n    });\n  });\n```\n\n### Using Base Procedures\n\n```typescript title=\"server/user-router.ts\"\nexport const userRouter = t.router({\n  // Public endpoint\n  getPublicProfile: publicProcedure\n    .input(z.string())\n    .query(async ({ input }) => {\n      return await db.user.findUnique({\n        where: { id: input },\n        select: { id: true, name: true, bio: true }, // Only public fields\n      });\n    }),\n\n  // Authenticated endpoint\n  getProfile: authedProcedure\n    .query(async ({ ctx }) => {\n      return await db.user.findUnique({\n        where: { id: ctx.user.id },\n        include: { preferences: true },\n      });\n    }),\n\n  // Admin endpoint\n  getAllUsers: adminProcedure\n    .input(z.object({\n      page: z.number().default(1),\n      limit: z.number().min(1).max(100).default(20),\n    }))\n    .query(async ({ input }) => {\n      const skip = (input.page - 1) * input.limit;\n\n      const [users, total] = await Promise.all([\n        db.user.findMany({\n          skip,\n          take: input.limit,\n          orderBy: { createdAt: 'desc' },\n        }),\n        db.user.count(),\n      ]);\n\n      return {\n        users,\n        pagination: {\n          page: input.page,\n          limit: input.limit,\n          total,\n          totalPages: Math.ceil(total / input.limit),\n        },\n      };\n    }),\n\n  // Organization-specific endpoint\n  getOrganizationMembers: organizationProcedure\n    .query(async ({ ctx }) => {\n      return await db.membership.findMany({\n        where: { organizationId: ctx.organization.id },\n        include: { user: true },\n      });\n    }),\n});\n```\n\n## Advanced Patterns\n\n### Conditional Procedures\n\nUse middleware to create conditional logic:\n\n```typescript title=\"server/conditional.ts\"\nconst withPostAccess = t.procedure\n  .input(z.object({ postId: z.string() }))\n  .use(async ({ input, ctx, next }) => {\n    const post = await db.post.findUnique({\n      where: { id: input.postId },\n      include: { author: true },\n    });\n\n    if (!post) {\n      throw new TRPCError({ code: 'NOT_FOUND', message: 'Post not found' });\n    }\n\n    // Check access permissions\n    const hasAccess = post.published ||\n                     post.authorId === ctx.user?.id ||\n                     ctx.user?.role === 'admin';\n\n    if (!hasAccess) {\n      throw new TRPCError({ code: 'FORBIDDEN' });\n    }\n\n    return next({\n      ctx: { ...ctx, post }, // Add post to context\n    });\n  });\n\nexport const postRouter = t.router({\n  getPost: withPostAccess.query(({ ctx }) => {\n    // ctx.post is guaranteed to exist and user has access\n    return ctx.post;\n  }),\n\n  updatePost: withPostAccess\n    .input(z.object({\n      postId: z.string(),\n      updates: z.object({\n        title: z.string().optional(),\n        content: z.string().optional(),\n      }),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Only allow author or admin to update\n      if (ctx.post.authorId !== ctx.user?.id && ctx.user?.role !== 'admin') {\n        throw new TRPCError({ code: 'FORBIDDEN' });\n      }\n\n      return await db.post.update({\n        where: { id: input.postId },\n        data: input.updates,\n      });\n    }),\n});\n```\n\n### Batch Operations\n\nHandle multiple operations efficiently:\n\n```typescript title=\"server/batch.ts\"\nexport const batchRouter = t.router({\n  createMultiplePosts: t.procedure\n    .input(z.array(z.object({\n      title: z.string(),\n      content: z.string(),\n      authorId: z.string(),\n    })))\n    .mutation(async ({ input }) => {\n      // Use database transaction for atomicity\n      return await db.$transaction(\n        input.map((post) => db.post.create({ data: post }))\n      );\n    }),\n\n  getMultipleUsers: t.procedure\n    .input(z.array(z.string()))\n    .query(async ({ input }) => {\n      const users = await db.user.findMany({\n        where: { id: { in: input } },\n      });\n\n      // Return in same order as requested\n      return input.map(id => users.find(user => user.id === id) || null);\n    }),\n});\n```\n\n### File Upload Procedures\n\nHandle file uploads with proper validation:\n\n```typescript title=\"server/upload.ts\"\nexport const uploadRouter = t.router({\n  uploadImage: t.procedure\n    .input(z.instanceof(FormData))\n    .mutation(async ({ input }) => {\n      const file = input.get('image') as File;\n\n      if (!file) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'No file provided',\n        });\n      }\n\n      // Validate file type\n      if (!file.type.startsWith('image/')) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'File must be an image',\n        });\n      }\n\n      // Validate file size (5MB limit)\n      if (file.size > 5 * 1024 * 1024) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'File size must be less than 5MB',\n        });\n      }\n\n      // Process and store file\n      const fileName = `${Date.now()}-${file.name}`;\n      const url = await fileStorage.upload(fileName, file);\n\n      return { url, fileName };\n    }),\n});\n```\n\n## Error Handling\n\nImplement comprehensive error handling:\n\n```typescript title=\"server/errors.ts\"\nexport const errorHandlingRouter = t.router({\n  riskyOperation: t.procedure\n    .input(z.string())\n    .mutation(async ({ input }) => {\n      try {\n        const result = await externalAPI.processData(input);\n        return result;\n      } catch (error) {\n        // Handle different error types\n        if (error instanceof ValidationError) {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: 'Invalid input data',\n            cause: error,\n          });\n        }\n\n        if (error instanceof NetworkError) {\n          throw new TRPCError({\n            code: 'INTERNAL_SERVER_ERROR',\n            message: 'External service unavailable',\n            cause: error,\n          });\n        }\n\n        // Unknown error\n        console.error('Unexpected error:', error);\n        throw new TRPCError({\n          code: 'INTERNAL_SERVER_ERROR',\n          message: 'An unexpected error occurred',\n        });\n      }\n    }),\n});\n```\n\n## Testing Procedures\n\nTest your procedures effectively:\n\n```typescript title=\"server/procedures.test.ts\"\nimport { createCallerFactory } from '@trpc/server';\nimport { appRouter } from './router';\n\nconst createCaller = createCallerFactory(appRouter);\n\ndescribe('User Procedures', () => {\n  const caller = createCaller({\n    user: { id: 'user1', role: 'user' },\n    db: mockDb,\n  });\n\n  it('should get user profile', async () => {\n    const profile = await caller.user.getProfile();\n    expect(profile.id).toBe('user1');\n  });\n\n  it('should create a post', async () => {\n    const post = await caller.post.create({\n      title: 'Test Post',\n      content: 'This is a test',\n      authorId: 'user1',\n    });\n\n    expect(post.title).toBe('Test Post');\n    expect(post.authorId).toBe('user1');\n  });\n\n  it('should throw error for unauthorized access', async () => {\n    const unauthorizedCaller = createCaller({});\n\n    await expect(\n      unauthorizedCaller.user.getProfile()\n    ).rejects.toThrow('UNAUTHORIZED');\n  });\n});\n```\n\n## Best Practices\n\n<Accordions>\n  <Accordion title=\"Input Validation\">\n    - Always validate inputs with Zod or similar - Use specific error messages\n    for better UX - Set reasonable limits on string lengths and array sizes -\n    Validate business rules in procedures, not just types\n  </Accordion>\n\n<Accordion title=\"Error Handling\">\n  - Use appropriate tRPC error codes - Provide helpful error messages - Log\n  errors for debugging - Don't expose sensitive information in error messages\n</Accordion>\n\n<Accordion title=\"Performance\">\n  - Use database indexes for query procedures - Implement pagination for large\n  datasets - Consider caching for frequently accessed data - Use database\n  transactions for related mutations\n</Accordion>\n\n  <Accordion title=\"Security\">\n    - Always authenticate sensitive procedures - Validate user permissions\n    before data access - Rate limit public endpoints - Sanitize user inputs\n  </Accordion>\n</Accordions>\n\n## Next Steps\n\n<Cards>\n  <Card href=\"/docs/server/routers\" title=\"Define Routers\">\n    Learn how to organize procedures into routers and merge them\n  </Card>\n  <Card href=\"/docs/server/context\" title=\"Add Context\">\n    Share data like database connections and user sessions\n  </Card>\n  <Card href=\"/docs/server/middlewares\" title=\"Add Middleware\">\n    Implement authentication, logging, and custom logic\n  </Card>\n  <Card href=\"/docs/server/error-handling\" title=\"Error Handling\">\n    Master error handling and debugging techniques\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/quickstart.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/quickstart.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Server Quickstart","description":"Build your first tRPC server in 5 minutes","icon":"IconRocket","index":false},"content":"\nBuild a complete tRPC server with queries, mutations, and type safety in under 5 minutes. This guide uses a standalone server that works everywhere.\n\n<Callout title=\"Framework-Specific Guides\">\n  For production apps, see our [framework-specific\n  guides](/docs/server/framework) for Next.js, Express, Fastify, and more.\n</Callout>\n\n## What You'll Build\n\nA blog API server with:\n\n- ‚úÖ **Get all posts** (query)\n- ‚úÖ **Create new post** (mutation)\n- ‚úÖ **Full type safety** (TypeScript)\n- ‚úÖ **Input validation** (Zod)\n- ‚úÖ **Testable endpoints** (HTTP)\n\n## Setup\n\nInitialize a new project:\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash mkdir my-trpc-server && cd my-trpc-server npm init -y npm install\n    @trpc/server zod npm install -D typescript @types/node tsx ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash mkdir my-trpc-server && cd my-trpc-server pnpm init pnpm add\n    @trpc/server zod pnpm add -D typescript @types/node tsx ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash mkdir my-trpc-server && cd my-trpc-server yarn init -y yarn add\n    @trpc/server zod yarn add -D typescript @types/node tsx ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash mkdir my-trpc-server && cd my-trpc-server bun init bun add\n    @trpc/server zod bun add -D typescript @types/node tsx ```\n  </Tab>\n</Tabs>\n\nAdd TypeScript config:\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\nAdd scripts:\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"dev\": \"tsx watch server.ts\",\n    \"start\": \"tsx server.ts\"\n  }\n}\n```\n\n## Step 1: Create Your API\n\n```typescript title=\"server.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { z } from 'zod';\n\n// Initialize tRPC\nconst t = initTRPC.create();\n\n// In-memory database (use a real database in production)\nconst posts = [\n  { id: '1', title: 'Hello World', content: 'This is my first post!', createdAt: new Date() },\n  { id: '2', title: 'tRPC is Awesome', content: 'Building APIs has never been easier.', createdAt: new Date() },\n];\n\n// Create your API router\nconst appRouter = t.router({\n  // Query: Get all posts\n  getPosts: t.procedure.query(() => {\n    return {\n      posts: posts.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()),\n      total: posts.length,\n    };\n  }),\n\n  // Query: Get a specific post\n  getPost: t.procedure\n    .input(z.object({ id: z.string() }))\n    .query(({ input }) => {\n      const post = posts.find(p => p.id === input.id);\n      if (!post) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found',\n        });\n      }\n      return post;\n    }),\n\n  // Mutation: Create a new post\n  createPost: t.procedure\n    .input(z.object({\n      title: z.string().min(1, 'Title is required').max(100, 'Title too long'),\n      content: z.string().min(1, 'Content is required'),\n    }))\n    .mutation(({ input }) => {\n      const newPost = {\n        id: String(posts.length + 1),\n        title: input.title,\n        content: input.content,\n        createdAt: new Date(),\n      };\n      posts.push(newPost);\n      return newPost;\n    }),\n\n  // Mutation: Delete a post\n  deletePost: t.procedure\n    .input(z.object({ id: z.string() }))\n    .mutation(({ input }) => {\n      const index = posts.findIndex(p => p.id === input.id);\n      if (index === -1) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Post not found',\n        });\n      }\n      const deletedPost = posts.splice(index, 1)[0];\n      return { success: true, deletedPost };\n    }),\n});\n\n// Create HTTP server\nconst server = createHTTPServer({\n  router: appRouter,\n  createContext: () => ({}),\n});\n\n// Start the server\nconst port = 3000;\nserver.listen(port);\n\nconsole.log(`üöÄ tRPC server running on http://localhost:${port}`);\nconsole.log('üìã Available endpoints:');\nconsole.log('  GET  /getPosts');\nconsole.log('  GET  /getPost?input={\"id\":\"1\"}');\nconsole.log('  POST /createPost');\nconsole.log('  POST /deletePost');\n\n// Export the router type for the client\nexport type AppRouter = typeof appRouter;\n```\n\n## Step 2: Start Your Server\n\n```bash\nnpm run dev\n```\n\nYou should see:\n\n```\nüöÄ tRPC server running on http://localhost:3000\nüìã Available endpoints:\n  GET  /getPosts\n  GET  /getPost?input={\"id\":\"1\"}\n  POST /createPost\n  POST /deletePost\n```\n\n## Step 3: Test Your API\n\n<Tabs items={['Get Posts', 'Get Single Post', 'Create Post', 'Delete Post']}>\n<Tab value=\"Get Posts\">\n```bash\ncurl http://localhost:3000/getPosts\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"posts\": [\n        {\n          \"id\": \"2\",\n          \"title\": \"tRPC is Awesome\",\n          \"content\": \"Building APIs has never been easier.\",\n          \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n        },\n        {\n          \"id\": \"1\",\n          \"title\": \"Hello World\",\n          \"content\": \"This is my first post!\",\n          \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n        }\n      ],\n      \"total\": 2\n    }\n  }\n}\n```\n\n</Tab>\n\n<Tab value=\"Get Single Post\">\n```bash\ncurl \"http://localhost:3000/getPost?input=%7B%22id%22%3A%221%22%7D\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"id\": \"1\",\n      \"title\": \"Hello World\",\n      \"content\": \"This is my first post!\",\n      \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n\n<Tab value=\"Create Post\">\n```bash\ncurl -X POST http://localhost:3000/createPost \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"My New Post\", \"content\": \"This is the content of my new post.\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"id\": \"3\",\n      \"title\": \"My New Post\",\n      \"content\": \"This is the content of my new post.\",\n      \"createdAt\": \"2024-01-15T10:35:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n\n<Tab value=\"Delete Post\">\n```bash\ncurl -X POST http://localhost:3000/deletePost \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\": \"1\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"success\": true,\n      \"deletedPost\": {\n        \"id\": \"1\",\n        \"title\": \"Hello World\",\n        \"content\": \"This is my first post!\",\n        \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n      }\n    }\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n## Step 4: Add a Client\n\nCreate a simple client to consume your API:\n\n```typescript title=\"client.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n\n// Create the client\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n\n// Use the client\nasync function main() {\n  try {\n    // Get all posts\n    console.log('üìñ Getting all posts...');\n    const { posts, total } = await client.getPosts.query();\n    console.log(`Found ${total} posts:`);\n    posts.forEach(post => {\n      console.log(`  - ${post.title}`);\n    });\n\n    // Create a new post\n    console.log('\\n‚úèÔ∏è Creating a new post...');\n    const newPost = await client.createPost.mutate({\n      title: 'Client Created Post',\n      content: 'This post was created using the tRPC client!',\n    });\n    console.log(`Created post: ${newPost.title}`);\n\n    // Get the specific post\n    console.log('\\nüîç Getting the new post...');\n    const post = await client.getPost.query({ id: newPost.id });\n    console.log(`Post content: ${post.content}`);\n\n  } catch (error) {\n    console.error('‚ùå Error:', error);\n  }\n}\n\nmain();\n```\n\nRun the client:\n\n```bash\nnpx tsx client.ts\n```\n\nOutput:\n\n```\nüìñ Getting all posts...\nFound 2 posts:\n  - tRPC is Awesome\n  - Hello World\n\n‚úèÔ∏è Creating a new post...\nCreated post: Client Created Post\n\nüîç Getting the new post...\nPost content: This post was created using the tRPC client!\n```\n\n## What Just Happened?\n\nüéâ **Congratulations!** You just built a complete type-safe API with:\n\n1. **Automatic Type Inference**: Your client knows exactly what data each endpoint returns\n2. **Input Validation**: Zod schemas validate all inputs automatically\n3. **Error Handling**: Proper HTTP status codes and error messages\n4. **No Code Generation**: Everything works with pure TypeScript\n\n## Key Concepts\n\n<Cards>\n  <Card title=\"Procedures\" icon=\"üîß\">\n    **Queries** fetch data, **Mutations** change data. Both are fully typed\n    functions.\n  </Card>\n  <Card title=\"Input Validation\" icon=\"üõ°Ô∏è\">\n    Zod schemas validate inputs and provide automatic TypeScript types.\n  </Card>\n  <Card title=\"Type Export\" icon=\"üì§\">\n    Export your `AppRouter` type to get full type safety on the client.\n  </Card>\n  <Card title=\"Error Handling\" icon=\"‚ö†Ô∏è\">\n    `TRPCError` provides structured errors with proper HTTP status codes.\n  </Card>\n</Cards>\n\n## Add Features\n\nNow that you have the basics, try adding:\n\n<Accordions>\n<Accordion title=\"Authentication\">\nAdd a simple API key check:\n\n```typescript\n// Add middleware for protected routes\nconst protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  const apiKey = ctx.req.headers['x-api-key'];\n  if (apiKey !== 'secret-key') {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next();\n});\n\n// Use in your router\nconst appRouter = t.router({\n  // Public route\n  getPosts: t.procedure.query(/* ... */),\n\n  // Protected route\n  createPost: protectedProcedure\n    .input(/* ... */)\n    .mutation(/* ... */),\n});\n```\n\n</Accordion>\n\n<Accordion title=\"Database Integration\">\nReplace the in-memory array with a real database:\n\n```typescript\n// With Prisma\nconst appRouter = t.router({\n  getPosts: t.procedure.query(async () => {\n    const posts = await prisma.post.findMany({\n      orderBy: { createdAt: 'desc' },\n    });\n    return { posts, total: posts.length };\n  }),\n\n  createPost: t.procedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(async ({ input }) => {\n      return await prisma.post.create({\n        data: input,\n      });\n    }),\n});\n```\n\n</Accordion>\n\n<Accordion title=\"Nested Routers\">\nOrganize your API into logical groups:\n\n```typescript\nconst postsRouter = t.router({\n  getAll: t.procedure.query(/* ... */),\n  getById: t.procedure.input(/* ... */).query(/* ... */),\n  create: t.procedure.input(/* ... */).mutation(/* ... */),\n  delete: t.procedure.input(/* ... */).mutation(/* ... */),\n});\n\nconst usersRouter = t.router({\n  getAll: t.procedure.query(/* ... */),\n  create: t.procedure.input(/* ... */).mutation(/* ... */),\n});\n\nconst appRouter = t.router({\n  posts: postsRouter,\n  users: usersRouter,\n});\n\n// Client usage:\n// client.posts.getAll.query()\n// client.users.create.mutate({...})\n```\n\n</Accordion>\n</Accordions>\n\n## Production Ready\n\nFor production apps, choose a framework:\n\n<Cards>\n  <Card title=\"Next.js\" href=\"/docs/server/framework/nextjs\">\n    Full-stack React with SSR and API routes\n  </Card>\n  <Card title=\"Express\" href=\"/docs/server/framework/express\">\n    Traditional Node.js server with middleware support\n  </Card>\n  <Card title=\"Fastify\" href=\"/docs/server/framework/fastify\">\n    High-performance server with plugins\n  </Card>\n  <Card title=\"Serverless\" href=\"/docs/server/framework/aws-lambda\">\n    AWS Lambda, Cloudflare Workers, and more\n  </Card>\n</Cards>\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Learn Core Concepts\" href=\"/docs/server/procedures\">\n    Deep dive into procedures, routers, and middleware\n  </Card>\n  <Card title=\"Add Authentication\" href=\"/docs/server/authorization\">\n    Implement user authentication and authorization\n  </Card>\n  <Card title=\"Handle Errors\" href=\"/docs/server/error-handling\">\n    Master error handling and debugging\n  </Card>\n  <Card title=\"Connect a Client\" href=\"/docs/client\">\n    Build a frontend with React, Vue, or vanilla TypeScript\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/routers.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/routers.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Define Routers","description":"Organize your tRPC procedures into structured, reusable routers","icon":"IconRoute","index":false},"content":"\nRouters are the foundation of your tRPC API structure. They allow you to organize procedures into logical groups, create nested hierarchies, and build scalable APIs that are easy to maintain and understand.\n\n<Callout title=\"Router Benefits\">\n  - **Organization**: Group related procedures together - **Nesting**: Create\n  hierarchical API structures - **Reusability**: Share routers across different\n  parts of your application - **Type Safety**: Maintain full type inference\n  across your entire API\n</Callout>\n\n## Basic Router Setup\n\n### Initialize tRPC\n\nYou should initialize tRPC **exactly once** per application. Multiple instances will cause issues.\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\n\n// Initialize tRPC\nconst t = initTRPC.create();\n\n// Export reusable helpers\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n<Callout title=\"Naming Convention\">\n  Export specific methods rather than the entire `t` object to establish\n  consistent patterns across your codebase.\n</Callout>\n\n### Create Your First Router\n\nDefine a router with procedures to expose as API endpoints:\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  // Simple query\n  hello: publicProcedure.query(() => {\n    return { message: 'Hello from tRPC!' };\n  }),\n\n  // Query with input validation\n  greet: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .query(({ input }) => {\n      return { message: `Hello, ${input.name}!` };\n    }),\n\n  // Mutation example\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string(),\n      content: z.string(),\n    }))\n    .mutation(({ input }) => {\n      // Database logic here\n      return { id: '1', ...input };\n    }),\n});\n\n// Export type definition for client inference\nexport type AppRouter = typeof appRouter;\n```\n\n## Nested Routers\n\nOrganize your API into logical groups using nested routers:\n\n```typescript title=\"src/routers/index.ts\"\nimport { router } from '../trpc';\nimport { userRouter } from './user';\nimport { postRouter } from './post';\nimport { commentRouter } from './comment';\n\nexport const appRouter = router({\n  user: userRouter,     // All user procedures under /user.*\n  post: postRouter,     // All post procedures under /post.*\n  comment: commentRouter, // All comment procedures under /comment.*\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### Individual Router Files\n\n<Tabs items={['User Router', 'Post Router', 'Comment Router']}>\n  <Tab value=\"User Router\">\n    ```typescript title=\"src/routers/user.ts\"\n    import { z } from 'zod';\n    import { router, publicProcedure } from '../trpc';\n\n    export const userRouter = router({\n      // GET /user.list\n      list: publicProcedure.query(async () => {\n        return await db.user.findMany();\n      }),\n\n      // GET /user.getById\n      getById: publicProcedure\n        .input(z.object({ id: z.string() }))\n        .query(async ({ input }) => {\n          return await db.user.findUnique({\n            where: { id: input.id }\n          });\n        }),\n\n      // POST /user.create\n      create: publicProcedure\n        .input(z.object({\n          name: z.string().min(2),\n          email: z.string().email(),\n        }))\n        .mutation(async ({ input }) => {\n          return await db.user.create({ data: input });\n        }),\n\n      // POST /user.update\n      update: publicProcedure\n        .input(z.object({\n          id: z.string(),\n          name: z.string().optional(),\n          email: z.string().email().optional(),\n        }))\n        .mutation(async ({ input }) => {\n          const { id, ...data } = input;\n          return await db.user.update({\n            where: { id },\n            data,\n          });\n        }),\n\n      // POST /user.delete\n      delete: publicProcedure\n        .input(z.object({ id: z.string() }))\n        .mutation(async ({ input }) => {\n          return await db.user.delete({\n            where: { id: input.id }\n          });\n        }),\n    });\n    ```\n\n  </Tab>\n\n  <Tab value=\"Post Router\">\n    ```typescript title=\"src/routers/post.ts\"\n    import { z } from 'zod';\n    import { router, publicProcedure } from '../trpc';\n\n    export const postRouter = router({\n      // GET /post.list\n      list: publicProcedure\n        .input(z.object({\n          limit: z.number().min(1).max(100).default(10),\n          cursor: z.string().optional(),\n        }))\n        .query(async ({ input }) => {\n          const posts = await db.post.findMany({\n            take: input.limit + 1,\n            cursor: input.cursor ? { id: input.cursor } : undefined,\n            orderBy: { createdAt: 'desc' },\n            include: { author: true },\n          });\n\n          const hasNextPage = posts.length > input.limit;\n          const items = hasNextPage ? posts.slice(0, -1) : posts;\n\n          return {\n            items,\n            nextCursor: hasNextPage ? items[items.length - 1].id : undefined,\n          };\n        }),\n\n      // GET /post.getById\n      getById: publicProcedure\n        .input(z.object({ id: z.string() }))\n        .query(async ({ input }) => {\n          return await db.post.findUnique({\n            where: { id: input.id },\n            include: { author: true, comments: true },\n          });\n        }),\n\n      // POST /post.create\n      create: publicProcedure\n        .input(z.object({\n          title: z.string().min(1).max(200),\n          content: z.string().min(1),\n          authorId: z.string(),\n        }))\n        .mutation(async ({ input }) => {\n          return await db.post.create({\n            data: input,\n            include: { author: true },\n          });\n        }),\n    });\n    ```\n\n  </Tab>\n\n  <Tab value=\"Comment Router\">\n    ```typescript title=\"src/routers/comment.ts\"\n    import { z } from 'zod';\n    import { router, publicProcedure } from '../trpc';\n\n    export const commentRouter = router({\n      // GET /comment.listByPost\n      listByPost: publicProcedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          return await db.comment.findMany({\n            where: { postId: input.postId },\n            include: { author: true },\n            orderBy: { createdAt: 'asc' },\n          });\n        }),\n\n      // POST /comment.create\n      create: publicProcedure\n        .input(z.object({\n          content: z.string().min(1).max(500),\n          postId: z.string(),\n          authorId: z.string(),\n        }))\n        .mutation(async ({ input }) => {\n          return await db.comment.create({\n            data: input,\n            include: { author: true },\n          });\n        }),\n\n      // POST /comment.delete\n      delete: publicProcedure\n        .input(z.object({ id: z.string() }))\n        .mutation(async ({ input }) => {\n          return await db.comment.delete({\n            where: { id: input.id },\n          });\n        }),\n    });\n    ```\n\n  </Tab>\n</Tabs>\n\n## Inline Sub-routers\n\nYou can define routers inline using plain objects:\n\n```typescript title=\"src/router.ts\"\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  // Inline sub-router using plain object\n  auth: {\n    login: publicProcedure\n      .input(z.object({ email: z.string(), password: z.string() }))\n      .mutation(({ input }) => {\n        // Login logic\n        return { token: 'jwt-token' };\n      }),\n\n    logout: publicProcedure.mutation(() => {\n      // Logout logic\n      return { success: true };\n    }),\n  },\n\n  // Equivalent using router() function\n  profile: router({\n    get: publicProcedure.query(() => {\n      return { id: '1', name: 'John' };\n    }),\n\n    update: publicProcedure\n      .input(z.object({ name: z.string() }))\n      .mutation(({ input }) => {\n        return { id: '1', ...input };\n      }),\n  }),\n});\n```\n\n## Advanced Router Patterns\n\n### Router with Context\n\nInclude shared context like database connections:\n\n```typescript title=\"src/router-with-context.ts\"\nimport { router, publicProcedure } from './trpc';\n\n// Assuming context includes database and user\nexport const appRouter = router({\n  posts: router({\n    list: publicProcedure.query(async ({ ctx }) => {\n      return await ctx.db.post.findMany({\n        where: { published: true },\n      });\n    }),\n\n    myPosts: publicProcedure.query(async ({ ctx }) => {\n      if (!ctx.user) {\n        throw new Error('Unauthorized');\n      }\n\n      return await ctx.db.post.findMany({\n        where: { authorId: ctx.user.id },\n      });\n    }),\n  }),\n});\n```\n\n### Conditional Router Loading\n\nLoad routers conditionally based on environment or features:\n\n```typescript title=\"src/conditional-router.ts\"\nimport { router } from './trpc';\nimport { userRouter } from './routers/user';\nimport { postRouter } from './routers/post';\n\nconst baseRouter = router({\n  user: userRouter,\n  post: postRouter,\n});\n\n// Add admin routes only in development or for admin users\nconst adminRouter = router({\n  admin: router({\n    deleteAllPosts: publicProcedure.mutation(async () => {\n      if (process.env.NODE_ENV !== 'development') {\n        throw new Error('Not allowed in production');\n      }\n      return await db.post.deleteMany();\n    }),\n  }),\n});\n\nexport const appRouter = process.env.NODE_ENV === 'development'\n  ? router({\n      ...baseRouter._def.procedures,\n      ...adminRouter._def.procedures,\n    })\n  : baseRouter;\n```\n\n### Router with Middleware\n\nApply middleware to entire router branches:\n\n```typescript title=\"src/middleware-router.ts\"\nimport { router, publicProcedure } from './trpc';\n\n// Protected procedure with auth middleware\nconst protectedProcedure = publicProcedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({ ctx: { user: ctx.user } });\n});\n\nexport const appRouter = router({\n  // Public routes\n  public: router({\n    health: publicProcedure.query(() => ({ status: 'ok' })),\n    posts: publicProcedure.query(() => getPublicPosts()),\n  }),\n\n  // Protected routes - all require authentication\n  protected: router({\n    profile: protectedProcedure.query(({ ctx }) => {\n      return getUserProfile(ctx.user.id);\n    }),\n\n    settings: protectedProcedure\n      .input(z.object({ theme: z.enum(['light', 'dark']) }))\n      .mutation(({ input, ctx }) => {\n        return updateUserSettings(ctx.user.id, input);\n      }),\n  }),\n});\n```\n\n## Router Best Practices\n\n<Accordions>\n  <Accordion title=\"Organization\">\n    - **Group by domain**: Organize routers by business domains (users, posts, orders)\n    - **Keep files focused**: Each router file should handle one main entity\n    - **Use consistent naming**: Follow consistent patterns for procedure names\n    - **Separate concerns**: Keep business logic separate from route definitions\n    \n    ```typescript\n    // Good structure\n    src/\n      routers/\n        user.ts      // User-related procedures\n        post.ts      // Post-related procedures  \n        comment.ts   // Comment-related procedures\n        index.ts     // Main router combining all\n    ```\n  </Accordion>\n\n  <Accordion title=\"Performance\">\n    - **Lazy load large routers**: Use dynamic imports for optional functionality\n    - **Paginate large datasets**: Always implement pagination for list endpoints\n    - **Cache frequently accessed data**: Use appropriate caching strategies\n    - **Optimize database queries**: Include necessary relations, avoid N+1 queries\n    \n    ```typescript\n    // Pagination example\n    list: publicProcedure\n      .input(z.object({\n        cursor: z.string().optional(),\n        limit: z.number().min(1).max(100).default(10),\n      }))\n      .query(async ({ input }) => {\n        const items = await db.post.findMany({\n          take: input.limit + 1,\n          cursor: input.cursor ? { id: input.cursor } : undefined,\n        });\n        \n        const hasMore = items.length > input.limit;\n        return {\n          items: hasMore ? items.slice(0, -1) : items,\n          nextCursor: hasMore ? items[items.length - 1].id : undefined,\n        };\n      });\n    ```\n  </Accordion>\n\n<Accordion title=\"Type Safety\">\n  - **Export router types**: Always export `AppRouter` type for client inference\n  - **Use input validation**: Validate all inputs with Zod or similar libraries\n  - **Define output types**: Use output validation for critical data -\n  **Leverage inference**: Let TypeScript infer types from your schemas\n  ```typescript // Always export the router type export const appRouter =\n  router(\n  {\n    // ... procedures\n  }\n  ); export type AppRouter = typeof appRouter; ```\n</Accordion>\n\n  <Accordion title=\"Error Handling\">\n    - **Use proper error codes**: Return appropriate HTTP status codes\n    - **Provide helpful messages**: Include actionable error messages\n    - **Log errors appropriately**: Log server errors for debugging\n    - **Handle edge cases**: Account for missing data, network issues, etc.\n    \n    ```typescript\n    getUser: publicProcedure\n      .input(z.object({ id: z.string() }))\n      .query(async ({ input }) => {\n        const user = await db.user.findUnique({ where: { id: input.id } });\n        \n        if (!user) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `User with ID ${input.id} not found`,\n          });\n        }\n        \n        return user;\n      });\n    ```\n  </Accordion>\n</Accordions>\n\n## Testing Routers\n\nTest your routers effectively with server-side callers:\n\n```typescript title=\"src/routers/__tests__/user.test.ts\"\nimport { createCallerFactory } from '@trpc/server';\nimport { appRouter } from '../index';\n\nconst createCaller = createCallerFactory(appRouter);\n\ndescribe('User Router', () => {\n  const caller = createCaller({\n    // Mock context\n    db: mockDb,\n    user: { id: 'test-user', role: 'user' },\n  });\n\n  it('should create a user', async () => {\n    const input = {\n      name: 'John Doe',\n      email: 'john@example.com',\n    };\n\n    const result = await caller.user.create(input);\n\n    expect(result).toMatchObject(input);\n    expect(result.id).toBeDefined();\n  });\n\n  it('should list users', async () => {\n    const users = await caller.user.list();\n\n    expect(Array.isArray(users)).toBe(true);\n  });\n\n  it('should throw on invalid input', async () => {\n    await expect(\n      caller.user.create({ name: '', email: 'invalid' })\n    ).rejects.toThrow();\n  });\n});\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Add Procedures\" href=\"/docs/server/procedures\">\n    Learn how to create queries, mutations, and subscriptions\n  </Card>\n  <Card title=\"Context Setup\" href=\"/docs/server/context\">\n    Share data like database connections across procedures\n  </Card>\n  <Card title=\"Middleware\" href=\"/docs/server/middlewares\">\n    Add authentication, logging, and validation logic\n  </Card>\n  <Card title=\"Merge Routers\" href=\"/docs/server/merging-routers\">\n    Learn advanced patterns for combining multiple routers\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/server-side-calls.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/server-side-calls.mdx"},"lastModified":null,"data":{"title":"Server-Side Calls","description":"Call your tRPC procedures directly on the server without HTTP","icon":"IconServer2","index":false},"content":"\nYou may need to call your tRPC procedures directly from server code for testing, server-side rendering, or internal operations. tRPC provides `createCallerFactory()` to enable this pattern safely and efficiently.\n\n<Callout type=\"warn\">\n  **Important:** `createCaller` should not be used to call procedures from\n  within other procedures. This creates unnecessary overhead by recreating\n  context and re-executing middleware. Instead, extract shared logic into\n  separate functions.\n</Callout>\n\n<div className=\"flex w-full justify-between gap-2 pt-2\">\n  <div className=\"w-[49.5%]\">\n    <h3 className=\"mb-2 text-sm font-medium text-red-600\">‚ùå Don't do this</h3>\n    <img\n      src=\"https://assets.trpc.io/www/docs/server/server-side-calls/bad.png\"\n      className=\"w-full rounded border\"\n    />\n  </div>\n  <div className=\"w-[49.5%]\">\n    <h3 className=\"mb-2 text-sm font-medium text-green-600\">\n      ‚úÖ Do this instead\n    </h3>\n    <img\n      src=\"https://assets.trpc.io/www/docs/server/server-side-calls/good.png\"\n      className=\"w-full rounded border\"\n    />\n  </div>\n</div>\n\n## Creating a Caller\n\nUse `t.createCallerFactory` to create a server-side caller for any router. This returns a function that accepts a context and returns a caller instance.\n\n### Basic Example\n\n```ts title=\"server/caller.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\ntype Context = {\n  user?: { id: string; name: string };\n  db: Database;\n};\n\nconst t = initTRPC.context<Context>().create();\nconst { createCallerFactory, router } = t;\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n}\n\nconst posts: Post[] = [\n  { id: '1', title: 'Hello world', content: 'First post content' },\n];\n\nconst appRouter = router({\n  post: router({\n    list: t.procedure.query(() => posts),\n\n    byId: t.procedure\n      .input(z.object({ id: z.string() }))\n      .query(({ input }) => {\n        const post = posts.find(p => p.id === input.id);\n        if (!post) throw new Error('Post not found');\n        return post;\n      }),\n\n    create: t.procedure\n      .input(z.object({\n        title: z.string().min(1),\n        content: z.string().min(1),\n      }))\n      .mutation(({ input }) => {\n        const post: Post = {\n          id: `${posts.length + 1}`,\n          ...input,\n        };\n        posts.push(post);\n        return post;\n      }),\n  }),\n});\n\n// 1. Create a caller factory for your router\nconst createCaller = createCallerFactory(appRouter);\n\n// 2. Create a caller using your Context\nconst caller = createCaller({\n  user: { id: '1', name: 'Test User' },\n  db: mockDatabase,\n});\n\n// 3. Use the caller to call procedures\nconst newPost = await caller.post.create({\n  title: 'Server-side post',\n  content: 'Created from server code',\n});\n\nconst allPosts = await caller.post.list();\n```\n\n## Testing Use Cases\n\n### Integration Testing\n\nPerfect for testing your procedures without HTTP overhead:\n\n```ts title=\"tests/posts.test.ts\"\nimport { describe, it, expect } from 'vitest';\nimport { inferProcedureInput } from '@trpc/server';\nimport { createContextInner } from '../server/context';\nimport { AppRouter, createCaller } from '../server/routers/_app';\n\ndescribe('Posts API', () => {\n  it('should create and retrieve a post', async () => {\n    const ctx = await createContextInner({});\n    const caller = createCaller(ctx);\n\n    const input: inferProcedureInput<AppRouter['post']['create']> = {\n      title: 'Test Post',\n      content: 'This is a test post',\n    };\n\n    const createdPost = await caller.post.create(input);\n    const retrievedPost = await caller.post.byId({ id: createdPost.id });\n\n    expect(retrievedPost).toMatchObject(input);\n  });\n\n  it('should handle validation errors', async () => {\n    const ctx = await createContextInner({});\n    const caller = createCaller(ctx);\n\n    await expect(\n      caller.post.create({\n        title: '', // Empty title should fail\n        content: 'Content',\n      })\n    ).rejects.toThrow('String must contain at least 1 character(s)');\n  });\n});\n```\n\n### Seeding Data\n\nUse server-side calls to populate your database:\n\n```ts title=\"scripts/seed.ts\"\nimport { createCaller } from '../server/routers/_app';\nimport { createContext } from '../server/context';\n\nasync function seedDatabase() {\n  const ctx = await createContext();\n  const caller = createCaller(ctx);\n\n  const posts = [\n    { title: 'Welcome to our blog', content: 'This is our first post...' },\n    { title: 'Getting started', content: 'Here\\'s how to begin...' },\n    { title: 'Advanced tips', content: 'For experienced users...' },\n  ];\n\n  for (const postData of posts) {\n    const post = await caller.post.create(postData);\n    console.log(`Created post: ${post.id}`);\n  }\n\n  console.log('Database seeded successfully!');\n}\n\nseedDatabase().catch(console.error);\n```\n\n## Router.createCaller() (Legacy)\n\n<Callout type=\"warn\">\n  This method is deprecated. Use `createCallerFactory()` instead for better type\n  safety and performance.\n</Callout>\n\nThe legacy `router.createCaller({})` method is still supported but not recommended:\n\n```ts title=\"legacy-example.ts\"\n// ‚ùå Legacy method (still works but not recommended)\nconst legacyCaller = router.createCaller({\n  user: { id: '1', name: 'User' },\n});\n\n// ‚úÖ Preferred method\nconst createCaller = createCallerFactory(router);\nconst caller = createCaller({\n  user: { id: '1', name: 'User' },\n});\n```\n\n## Advanced Patterns\n\n### Context with Middleware\n\nHandle complex context creation with middleware:\n\n```ts title=\"server/context.ts\"\nimport { TRPCError } from '@trpc/server';\n\ntype Context = {\n  user?: { id: string; role: string };\n  db: Database;\n};\n\nconst protectedProcedure = t.procedure.use(async (opts) => {\n  const { ctx } = opts;\n\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return opts.next({\n    ctx: {\n      ...ctx,\n      user: ctx.user, // User is now guaranteed to exist\n    },\n  });\n});\n\nexport const appRouter = t.router({\n  protected: t.router({\n    profile: protectedProcedure.query(({ ctx }) => {\n      return getUserProfile(ctx.user.id);\n    }),\n  }),\n});\n\n// Testing protected procedures\ndescribe('Protected Procedures', () => {\n  it('should work with authenticated user', async () => {\n    const authenticatedCaller = createCaller({\n      user: { id: '1', role: 'user' },\n      db: mockDb,\n    });\n\n    const profile = await authenticatedCaller.protected.profile();\n    expect(profile).toBeDefined();\n  });\n\n  it('should fail without authentication', async () => {\n    const unauthenticatedCaller = createCaller({\n      user: null,\n      db: mockDb,\n    });\n\n    await expect(\n      unauthenticatedCaller.protected.profile()\n    ).rejects.toThrow('UNAUTHORIZED');\n  });\n});\n```\n\n### Error Handling in Server Calls\n\nHandle and transform errors from server-side calls:\n\n```ts title=\"server/utils.ts\"\nimport { TRPCError } from '@trpc/server';\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\n\nexport async function callProcedureWithErrorHandling<T>(\n  procedureCall: Promise<T>\n): Promise<{ data?: T; error?: string; status?: number }> {\n  try {\n    const data = await procedureCall;\n    return { data };\n  } catch (cause) {\n    if (cause instanceof TRPCError) {\n      const status = getHTTPStatusCodeFromError(cause);\n      return {\n        error: cause.message,\n        status\n      };\n    }\n    return {\n      error: 'Internal server error',\n      status: 500\n    };\n  }\n}\n\n// Usage\nconst result = await callProcedureWithErrorHandling(\n  caller.post.byId({ id: 'invalid-id' })\n);\n\nif (result.error) {\n  console.error(`Error ${result.status}: ${result.error}`);\n} else {\n  console.log('Post:', result.data);\n}\n```\n\n## Next.js API Route Example\n\nUse server-side calls in Next.js API routes for custom endpoints:\n\n```ts title=\"pages/api/custom/posts/[id].ts\"\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { TRPCError } from '@trpc/server';\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\nimport { appRouter } from '~/server/routers/_app';\nimport { createContext } from '~/server/context';\n\ntype ResponseData = {\n  data?: {\n    post: Post;\n    relatedPosts: Post[];\n  };\n  error?: {\n    message: string;\n  };\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>\n) {\n  const { id } = req.query;\n\n  if (typeof id !== 'string') {\n    return res.status(400).json({\n      error: { message: 'Invalid post ID' }\n    });\n  }\n\n  try {\n    const ctx = await createContext({ req, res });\n    const caller = appRouter.createCaller(ctx);\n\n    // Get the main post and related posts in parallel\n    const [post, relatedPosts] = await Promise.all([\n      caller.post.byId({ id }),\n      caller.post.related({ id, limit: 5 }),\n    ]);\n\n    res.status(200).json({\n      data: { post, relatedPosts }\n    });\n  } catch (cause) {\n    if (cause instanceof TRPCError) {\n      const httpStatusCode = getHTTPStatusCodeFromError(cause);\n      res.status(httpStatusCode).json({\n        error: { message: cause.message }\n      });\n    } else {\n      res.status(500).json({\n        error: { message: 'Internal server error' },\n      });\n    }\n  }\n}\n```\n\n## Error Handling\n\n### Custom Error Handler\n\nAdd custom error handling to caller creation:\n\n```ts title=\"server/caller.ts\"\nconst createCaller = createCallerFactory(appRouter);\n\nconst callerWithErrorHandling = createCaller(\n  context,\n  {\n    onError: (opts) => {\n      console.error('Server call error:', {\n        path: opts.path,\n        error: opts.error.message,\n        input: opts.input,\n      });\n\n      // Send to error reporting service\n      errorReporter.captureException(opts.error, {\n        tags: {\n          procedure: opts.path,\n          type: opts.type\n        },\n      });\n    },\n  }\n);\n```\n\n### Graceful Error Recovery\n\nImplement fallback strategies for failed server calls:\n\n```ts title=\"server/utils.ts\"\nexport async function callWithFallback<T>(\n  primaryCall: () => Promise<T>,\n  fallbackCall: () => Promise<T>,\n  logger?: (error: Error) => void\n): Promise<T> {\n  try {\n    return await primaryCall();\n  } catch (error) {\n    logger?.(error as Error);\n    return await fallbackCall();\n  }\n}\n\n// Usage\nconst posts = await callWithFallback(\n  () => caller.post.fromCache(),\n  () => caller.post.fromDatabase(),\n  (error) => console.warn('Cache miss:', error.message)\n);\n```\n\n## Best Practices\n\n<Steps>\n\n### Use Type Inference\n\nLeverage TypeScript's type inference for better type safety:\n\n```ts\nimport type { inferProcedureInput, inferProcedureOutput } from '@trpc/server';\nimport type { AppRouter } from '../server/routers/_app';\n\n// Infer input and output types\ntype PostCreateInput = inferProcedureInput<AppRouter['post']['create']>;\ntype PostCreateOutput = inferProcedureOutput<AppRouter['post']['create']>;\n\nconst validInput: PostCreateInput = {\n  title: 'Valid title',\n  content: 'Valid content',\n};\n```\n\n### Create Context Helpers\n\nBuild utilities for different contexts:\n\n```ts title=\"server/test-utils.ts\"\nexport function createTestContext(overrides?: Partial<Context>) {\n  return {\n    user: null,\n    db: testDatabase,\n    ...overrides,\n  };\n}\n\nexport function createAuthedContext(userId: string) {\n  return createTestContext({\n    user: { id: userId, name: 'Test User' },\n  });\n}\n\nexport function createAdminContext() {\n  return createTestContext({\n    user: { id: 'admin', name: 'Admin', role: 'admin' },\n  });\n}\n```\n\n### Batch Operations\n\nUse server-side calls for efficient batch operations:\n\n```ts title=\"server/batch-operations.ts\"\nexport async function bulkCreatePosts(\n  postsData: PostCreateInput[],\n  context: Context\n) {\n  const caller = createCaller(context);\n\n  const results = await Promise.allSettled(\n    postsData.map(data => caller.post.create(data))\n  );\n\n  const successful = results\n    .filter((r): r is PromiseFulfilledResult<Post> => r.status === 'fulfilled')\n    .map(r => r.value);\n\n  const failed = results\n    .filter((r): r is PromiseRejectedResult => r.status === 'rejected')\n    .map(r => r.reason);\n\n  return { successful, failed };\n}\n```\n\n### Performance Monitoring\n\nTrack performance of server-side calls:\n\n```ts title=\"server/monitoring.ts\"\nexport function withPerformanceTracking<T extends any[], R>(\n  fn: (...args: T) => Promise<R>,\n  operationName: string\n) {\n  return async (...args: T): Promise<R> => {\n    const start = performance.now();\n\n    try {\n      const result = await fn(...args);\n      const duration = performance.now() - start;\n\n      console.log(`${operationName} completed in ${duration.toFixed(2)}ms`);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      console.error(`${operationName} failed after ${duration.toFixed(2)}ms:`, error);\n      throw error;\n    }\n  };\n}\n\n// Usage\nconst trackedCaller = {\n  post: {\n    create: withPerformanceTracking(\n      caller.post.create,\n      'post.create'\n    ),\n    list: withPerformanceTracking(\n      caller.post.list,\n      'post.list'\n    ),\n  },\n};\n```\n\n</Steps>\n\n<Callout type=\"info\">\n  Server-side calls are powerful for testing, data seeding, and internal\n  operations. Use them judiciously and always prefer extracting shared logic\n  into utilities rather than calling procedures from within other procedures.\n</Callout>\n"}, {"info":{"path":"server/subscriptions.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/subscriptions.mdx"},"lastModified":null,"data":{"title":"Subscriptions","description":"Build real-time features with tRPC subscriptions and event streams","icon":"IconRadio","index":false},"content":"\nSubscriptions are a powerful way to create real-time connections between your client and server. They enable you to push updates to clients as soon as data changes, perfect for chat applications, live feeds, or any real-time feature.\n\n<Callout type=\"info\">\n  tRPC subscriptions work over WebSockets or Server-Sent Events (SSE). If you're\n  unsure which to use, we recommend SSE for most applications as it's easier to\n  set up and doesn't require a WebSocket server.\n</Callout>\n\n## Overview\n\nWith tRPC subscriptions:\n\n- **Persistent connections** are maintained between client and server\n- **Automatic reconnection** handles connection drops gracefully\n- **Type safety** is preserved end-to-end\n- **Event tracking** enables reliable message delivery\n\n## Getting Started\n\n### Choose Your Transport\n\n<Tabs items={['Server-Sent Events', 'WebSockets']}>\n\n```mdx tab=\"Server-Sent Events\"\n**Recommended for most applications**\n\n- Easier to setup and deploy\n- Works through firewalls and proxies\n- Automatic reconnection built-in\n- Unidirectional (server to client)\n\nSee our [SSE example](https://github.com/trpc/examples-next-sse-chat) for a complete implementation.\n```\n\n```mdx tab=\"WebSockets\"\n**For bidirectional communication**\n\n- Bidirectional communication\n- Lower latency\n- More complex setup\n- Requires WebSocket server\n\nSee our [WebSocket guide](./websockets) and [WebSocket example](https://github.com/trpc/examples-next-prisma-starter-websockets).\n```\n\n</Tabs>\n\n## Basic Subscription\n\n### Server Setup\n\nCreate a simple subscription that yields data over time:\n\n```ts title=\"server/routers/posts.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nimport { EventEmitter } from 'events';\n\nconst t = initTRPC.create();\nconst ee = new EventEmitter();\n\nexport const postsRouter = t.router({\n  onPostAdd: t.procedure.subscription(() => {\n    return observable<Post>((emit) => {\n      const onAdd = (data: Post) => {\n        emit.next(data);\n      };\n\n      ee.on('add', onAdd);\n\n      // Cleanup function\n      return () => {\n        ee.off('add', onAdd);\n      };\n    });\n  }),\n\n  create: t.procedure\n    .input(z.object({\n      title: z.string(),\n      content: z.string(),\n    }))\n    .mutation(async ({ input }) => {\n      const post = await createPost(input);\n      // Emit the new post to all subscribers\n      ee.emit('add', post);\n      return post;\n    }),\n});\n```\n\n### Client Usage\n\nSubscribe to real-time updates on the client:\n\n```tsx title=\"components/PostList.tsx\"\nimport { trpc } from '../lib/trpc';\n\nexport function PostList() {\n  const [posts, setPosts] = useState<Post[]>([]);\n\n  // Subscribe to new posts\n  trpc.posts.onPostAdd.useSubscription(undefined, {\n    onData: (post) => {\n      setPosts((prev) => [post, ...prev]);\n    },\n    onError: (err) => {\n      console.error('Subscription error:', err);\n    },\n  });\n\n  return (\n    <div>\n      {posts.map((post) => (\n        <div key={post.id} className=\"border rounded p-4 mb-2\">\n          <h3>{post.title}</h3>\n          <p>{post.content}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n## Tracked Subscriptions (Recommended)\n\nUse the `tracked()` helper for automatic reconnection with last known ID. This ensures reliable message delivery even if the connection drops.\n\n### Server Implementation\n\n```ts title=\"server/routers/chat.ts\"\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const chatRouter = t.router({\n  onMessage: t.procedure\n    .input(z.object({\n      lastEventId: z.string().nullish(),\n    }).optional())\n    .subscription(async function* (opts) {\n      if (opts.input?.lastEventId) {\n        // Send missed messages since last event ID\n        const missedMessages = await getMessagesSince(opts.input.lastEventId);\n        for (const message of missedMessages) {\n          yield tracked(message.id, message);\n        }\n      }\n\n      // Listen for new messages\n      for await (const [data] of on(ee, 'message', {\n        signal: opts.signal,\n      })) {\n        const message = data as Message;\n        yield tracked(message.id, message);\n      }\n    }),\n\n  sendMessage: t.procedure\n    .input(z.object({\n      content: z.string(),\n      channelId: z.string(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      const message = await createMessage({\n        ...input,\n        userId: ctx.user.id,\n      });\n\n      ee.emit('message', message);\n      return message;\n    }),\n});\n```\n\n### Client with Reconnection\n\n```tsx title=\"components/ChatRoom.tsx\"\nexport function ChatRoom({ channelId }: { channelId: string }) {\n  const [messages, setMessages] = useState<Message[]>([]);\n\n  trpc.chat.onMessage.useSubscription(\n    { lastEventId: null }, // Will be automatically updated\n    {\n      onData: (message) => {\n        setMessages((prev) => [...prev, message]);\n      },\n      onError: (err) => {\n        console.error('Chat subscription error:', err);\n      },\n    }\n  );\n\n  return (\n    <div className=\"chat-container\">\n      <div className=\"messages\">\n        {messages.map((message) => (\n          <div key={message.id} className=\"message\">\n            <strong>{message.user.name}: </strong>\n            {message.content}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n## Advanced Patterns\n\n### Pull-Based Subscriptions\n\nPeriodically check for new data instead of using events:\n\n```ts title=\"server/routers/notifications.ts\"\nexport const notificationsRouter = t.router({\n  onNotification: t.procedure\n    .input(z.object({\n      lastEventId: z.coerce.date().nullish(),\n    }))\n    .subscription(async function* (opts) {\n      let lastEventId = opts.input?.lastEventId ?? null;\n\n      while (!opts.signal!.aborted) {\n        const notifications = await db.notification.findMany({\n          where: lastEventId ? {\n            createdAt: { gt: lastEventId },\n          } : undefined,\n          orderBy: { createdAt: 'asc' },\n          take: 10,\n        });\n\n        for (const notification of notifications) {\n          yield tracked(notification.createdAt.toJSON(), notification);\n          lastEventId = notification.createdAt;\n        }\n\n        // Wait before checking again\n        await sleep(1000);\n      }\n    }),\n});\n```\n\n### Input-Based Subscriptions\n\nCreate subscriptions that accept input parameters:\n\n```ts title=\"server/routers/live.ts\"\nexport const liveRouter = t.router({\n  onChannelMessage: t.procedure\n    .input(z.object({\n      channelId: z.string(),\n      lastEventId: z.string().nullish(),\n    }))\n    .subscription(async function* (opts) {\n      const { channelId, lastEventId } = opts.input;\n\n      // Check permissions\n      const canAccess = await checkChannelAccess(channelId, opts.ctx.user.id);\n      if (!canAccess) {\n        throw new TRPCError({ code: 'FORBIDDEN' });\n      }\n\n      if (lastEventId) {\n        const missedMessages = await getChannelMessagesSince(channelId, lastEventId);\n        for (const message of missedMessages) {\n          yield tracked(message.id, message);\n        }\n      }\n\n      // Listen for new messages in this channel\n      const eventName = `channel:${channelId}:message`;\n      for await (const [data] of on(ee, eventName, {\n        signal: opts.signal,\n      })) {\n        const message = data as Message;\n        yield tracked(message.id, message);\n      }\n    }),\n});\n```\n\n### Connection Limits\n\nLimit the number of concurrent subscriptions:\n\n```ts title=\"server/middleware/connectionLimit.ts\"\nconst connectionCounts = new Map<string, number>();\n\nexport const connectionLimitMiddleware = t.middleware(async (opts) => {\n  const userId = opts.ctx.user?.id;\n  if (!userId) return opts.next();\n\n  const currentConnections = connectionCounts.get(userId) || 0;\n  const maxConnections = 5;\n\n  if (currentConnections >= maxConnections) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: 'Too many active connections',\n    });\n  }\n\n  // Increment connection count\n  connectionCounts.set(userId, currentConnections + 1);\n\n  try {\n    return await opts.next();\n  } finally {\n    // Decrement on cleanup\n    const count = connectionCounts.get(userId) || 0;\n    if (count <= 1) {\n      connectionCounts.delete(userId);\n    } else {\n      connectionCounts.set(userId, count - 1);\n    }\n  }\n});\n```\n\n## Error Handling\n\n### Server-Side Error Recovery\n\nHandle errors gracefully in subscriptions:\n\n```ts title=\"server/routers/resilient.ts\"\nexport const resilientRouter = t.router({\n  onData: t.procedure.subscription(async function* (opts) {\n    try {\n      for await (const [data] of on(ee, 'data', {\n        signal: opts.signal,\n      })) {\n        try {\n          // Process data with potential failure\n          const processedData = await processData(data);\n          yield tracked(processedData.id, processedData);\n        } catch (error) {\n          // Log error but continue subscription\n          console.error('Error processing data:', error);\n          // Optionally yield error information\n          yield tracked(\n            `error-${Date.now()}`,\n            { error: 'Processing failed', timestamp: Date.now() }\n          );\n        }\n      }\n    } finally {\n      // Cleanup resources\n      await cleanupResources();\n    }\n  }),\n});\n```\n\n### Client-Side Error Handling\n\nHandle connection issues on the client:\n\n```tsx title=\"hooks/useResilientSubscription.ts\"\nexport function useResilientSubscription<T>(\n  subscription: any,\n  input: any,\n  options?: {\n    onData?: (data: T) => void;\n    onError?: (error: Error) => void;\n    maxRetries?: number;\n  }\n) {\n  const [retryCount, setRetryCount] = useState(0);\n  const [isConnected, setIsConnected] = useState(false);\n  const maxRetries = options?.maxRetries ?? 5;\n\n  subscription.useSubscription(input, {\n    onData: (data: T) => {\n      setIsConnected(true);\n      setRetryCount(0); // Reset retry count on successful data\n      options?.onData?.(data);\n    },\n    onError: (error: Error) => {\n      setIsConnected(false);\n      console.error('Subscription error:', error);\n\n      if (retryCount < maxRetries) {\n        setTimeout(() => {\n          setRetryCount(prev => prev + 1);\n        }, Math.pow(2, retryCount) * 1000); // Exponential backoff\n      }\n\n      options?.onError?.(error);\n    },\n  });\n\n  return { isConnected, retryCount };\n}\n```\n\n## Output Validation\n\n### Validate Subscription Outputs\n\nUse Zod to validate subscription outputs:\n\n```ts title=\"server/utils/validation.ts\"\nimport { tracked, type TrackedEnvelope } from '@trpc/server';\nimport { z } from 'zod';\n\n// Helper for validating async iterables\nexport function validateAsyncIterable<TInput, TOutput>(\n  schema: z.ZodType<TInput, any, TOutput>\n) {\n  return function* (iterable: AsyncIterable<TOutput>) {\n    for await (const item of iterable) {\n      if (isTrackedEnvelope(item)) {\n        const [id, data] = item;\n        const validatedData = schema.parse(data);\n        yield tracked(id, validatedData);\n      } else {\n        yield schema.parse(item);\n      }\n    }\n  };\n}\n\n// Usage in procedures\nexport const validatedRouter = t.router({\n  onMessage: t.procedure\n    .output(z.object({\n      id: z.string(),\n      content: z.string(),\n      userId: z.string(),\n      createdAt: z.date(),\n    }))\n    .subscription(async function* (opts) {\n      const messageStream = getMessageStream();\n      yield* validateAsyncIterable(messageSchema)(messageStream);\n    }),\n});\n```\n\n## Performance Optimization\n\n### Subscription Batching\n\nBatch multiple events to reduce client updates:\n\n```ts title=\"server/utils/batching.ts\"\nexport async function* batchEvents<T>(\n  eventStream: AsyncIterable<T>,\n  batchSize: number = 10,\n  maxWaitMs: number = 100\n) {\n  let batch: T[] = [];\n  let lastFlush = Date.now();\n\n  for await (const event of eventStream) {\n    batch.push(event);\n\n    const shouldFlush =\n      batch.length >= batchSize ||\n      Date.now() - lastFlush >= maxWaitMs;\n\n    if (shouldFlush) {\n      yield batch;\n      batch = [];\n      lastFlush = Date.now();\n    }\n  }\n\n  // Flush remaining events\n  if (batch.length > 0) {\n    yield batch;\n  }\n}\n\n// Usage\nexport const batchedRouter = t.router({\n  onBatchedEvents: t.procedure.subscription(async function* (opts) {\n    const eventStream = getEventStream();\n    const batchedStream = batchEvents(eventStream, 5, 200);\n\n    for await (const batch of batchedStream) {\n      yield tracked(`batch-${Date.now()}`, batch);\n    }\n  }),\n});\n```\n\n### Memory Management\n\nPrevent memory leaks in long-running subscriptions:\n\n**1. Implement Subscription Cleanup**\n\n```typescript title=\"src/lib/subscription-manager.ts\"\ninterface SubscriptionManager {\n  subscriptions: Map<string, () => void>;\n  timers: Map<string, NodeJS.Timeout>;\n  cleanup: (id: string) => void;\n}\n\nexport const subscriptionManager: SubscriptionManager = {\n  subscriptions: new Map(),\n  timers: new Map(),\n\n  cleanup(id: string) {\n    // Cleanup subscription\n    const unsubscribe = this.subscriptions.get(id);\n    if (unsubscribe) {\n      unsubscribe();\n      this.subscriptions.delete(id);\n    }\n\n    // Clear any associated timers\n    const timer = this.timers.get(id);\n    if (timer) {\n      clearTimeout(timer);\n      this.timers.delete(id);\n    }\n\n    console.log(`Cleaned up subscription: ${id}`);\n  },\n};\n\n// Auto-cleanup after 1 hour of inactivity\nexport const registerSubscription = (id: string, unsubscribe: () => void) => {\n  subscriptionManager.subscriptions.set(id, unsubscribe);\n\n  // Set cleanup timer\n  const timer = setTimeout(() => {\n    subscriptionManager.cleanup(id);\n  }, 60 * 60 * 1000); // 1 hour\n\n  subscriptionManager.timers.set(id, timer);\n};\n```\n\n**2. Create Memory-Safe Subscription**\n\n```typescript title=\"src/routers/managed-subscription.ts\"\nexport const managedSubscriptionRouter = t.router({\n  onDataUpdates: t.procedure\n    .input(z.object({\n      subscriptionId: z.string(),\n      dataType: z.enum(['posts', 'comments', 'users']),\n    }))\n    .subscription(async function* ({ input, signal }) {\n      const { subscriptionId, dataType } = input;\n\n      // Register for cleanup\n      registerSubscription(subscriptionId, () => {\n        console.log(`Subscription ${subscriptionId} cleaned up`);\n      });\n\n      try {\n        // Listen for data updates\n        for await (const [data] of on(ee, dataType, { signal })) {\n          // Reset cleanup timer on activity\n          subscriptionManager.timers.delete(subscriptionId);\n          const timer = setTimeout(() => {\n            subscriptionManager.cleanup(subscriptionId);\n          }, 60 * 60 * 1000);\n          subscriptionManager.timers.set(subscriptionId, timer);\n\n          yield data;\n        }\n      } catch (error) {\n        console.error(`Subscription error: ${subscriptionId}`, error);\n      } finally {\n        // Ensure cleanup on exit\n        subscriptionManager.cleanup(subscriptionId);\n      }\n    }),\n});\n```\n\n**3. Client-Side Memory Management**\n\n```tsx title=\"components/ManagedSubscription.tsx\"\nimport { useEffect, useRef } from 'react';\nimport { trpc } from '../lib/trpc';\n\nexport function ManagedSubscription() {\n  const subscriptionIdRef = useRef<string>();\n\n  useEffect(() => {\n    // Generate unique subscription ID\n    subscriptionIdRef.current = `sub-${Date.now()}-${Math.random()}`;\n\n    return () => {\n      // Cleanup on unmount\n      if (subscriptionIdRef.current) {\n        // Send cleanup signal to server if needed\n        fetch('/api/cleanup-subscription', {\n          method: 'POST',\n          body: JSON.stringify({\n            subscriptionId: subscriptionIdRef.current\n          }),\n        });\n      }\n    };\n  }, []);\n\n  trpc.subscriptions.onDataUpdates.useSubscription(\n    {\n      subscriptionId: subscriptionIdRef.current!,\n      dataType: 'posts',\n    },\n    {\n      onData: (data) => {\n        console.log('Received data:', data);\n      },\n      onError: (error) => {\n        console.error('Subscription error:', error);\n      },\n    }\n  );\n\n  return <div>Managed subscription active</div>;\n}\n```\n\n## Best Practices\n\n<Steps>\n\n### Use Tracked Events\n\nAlways use `tracked()` for production subscriptions to enable automatic reconnection:\n\n```ts\n// ‚úÖ Good - with tracking\nyield tracked(event.id, event);\n\n// ‚ùå Avoid - no reconnection support\nyield event;\n```\n\n### Handle Cleanup Properly\n\nAlways clean up resources in the finally block:\n\n```ts\nsubscription(async function* (opts) {\n  const resources = [];\n  try {\n    // ... subscription logic\n  } finally {\n    // Clean up resources\n    resources.forEach(cleanup => cleanup());\n  }\n})\n```\n\n### Implement Proper Error Boundaries\n\nDon't let one bad event kill the entire subscription:\n\n```ts\nfor await (const [data] of eventStream) {\n  try {\n    const processed = await processData(data);\n    yield tracked(processed.id, processed);\n  } catch (error) {\n    // Log but continue\n    console.error('Processing error:', error);\n  }\n}\n```\n\n### Monitor Performance\n\nTrack subscription performance and connection counts:\n\n```ts\nconst activeSubscriptions = new Map();\n\nsubscription(async function* (opts) {\n  const subId = Math.random().toString();\n  activeSubscriptions.set(subId, Date.now());\n\n  try {\n    // Subscription logic\n  } finally {\n    activeSubscriptions.delete(subId);\n  }\n})\n```\n\n</Steps>\n\n## Reference Projects\n\n<TypeTable\n  type={{\n    'SSE Chat': {\n      description: 'Complete chat application using Server-Sent Events',\n      type: 'github.com/trpc/examples-next-sse-chat',\n    },\n    'WebSocket Starter': {\n      description: 'Full-stack WebSocket implementation with Prisma',\n      type: 'github.com/trpc/examples-next-prisma-websockets-starter',\n    },\n    'Standalone Server': {\n      description: 'Minimal WebSocket server example',\n      type: '/examples/standalone-server',\n    },\n  }}\n/>\n\n<Callout type=\"info\">\n  Subscriptions are powerful but should be used thoughtfully. For many use\n  cases, regular queries with polling or refetching may be simpler and more\n  efficient.\n</Callout>\n"}, {"info":{"path":"server/testing.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/testing.mdx"},"lastModified":null,"data":{"title":"Testing","description":"Test your tRPC procedures with confidence using server-side callers","icon":"IconTestPipe","index":false},"content":"\nTesting is crucial for maintaining reliable tRPC applications. This guide covers testing strategies for procedures, routers, middleware, and integration testing patterns.\n\n## Overview\n\ntRPC provides excellent testing capabilities through:\n\n- **Server-side calls** for unit testing procedures\n- **createCallerFactory** for isolated testing\n- **Integration testing** with real HTTP requests\n- **Type-safe mocking** with TypeScript\n\n## Unit Testing Procedures\n\n### Basic Procedure Testing\n\nUse `createCallerFactory` to test procedures in isolation:\n\n```ts title=\"tests/posts.test.ts\"\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createCallerFactory } from '../server/trpc';\nimport { postsRouter } from '../server/routers/posts';\n\nconst createCaller = createCallerFactory(postsRouter);\n\ndescribe('Posts Router', () => {\n  let caller: ReturnType<typeof createCaller>;\n\n  beforeEach(() => {\n    caller = createCaller({\n      user: { id: '1', name: 'Test User' },\n      db: mockDb,\n    });\n  });\n\n  it('should create a new post', async () => {\n    const input = {\n      title: 'Test Post',\n      content: 'This is a test post',\n    };\n\n    const result = await caller.create(input);\n\n    expect(result).toMatchObject({\n      id: expect.any(String),\n      title: input.title,\n      content: input.content,\n      authorId: '1',\n    });\n  });\n\n  it('should list posts', async () => {\n    const posts = await caller.list();\n\n    expect(Array.isArray(posts)).toBe(true);\n    expect(posts.length).toBeGreaterThan(0);\n  });\n});\n```\n\n### Testing with Database\n\nUse real database connections or in-memory databases for integration testing:\n\n<Tabs items={['Prisma', 'Drizzle', 'In-Memory']}>\n\n```ts tab=\"Prisma\" title=\"tests/setup.ts\"\nimport { PrismaClient } from '@prisma/client';\nimport { execSync } from 'child_process';\n\nconst prisma = new PrismaClient({\n  datasources: {\n    db: {\n      url: 'file:./test.db',\n    },\n  },\n});\n\nexport async function setupTestDb() {\n  // Run migrations\n  execSync('npx prisma migrate deploy', {\n    env: { ...process.env, DATABASE_URL: 'file:./test.db' },\n  });\n\n  return prisma;\n}\n\nexport async function cleanupTestDb() {\n  await prisma.$disconnect();\n}\n\n// Test helper\nexport function createTestContext() {\n  return {\n    prisma,\n    user: null,\n  };\n}\n```\n\n```ts tab=\"Drizzle\" title=\"tests/setup.ts\"\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\nimport { migrate } from 'drizzle-orm/better-sqlite3/migrator';\n\nconst sqlite = new Database(':memory:');\nconst db = drizzle(sqlite);\n\nexport async function setupTestDb() {\n  await migrate(db, { migrationsFolder: './drizzle' });\n  return db;\n}\n\nexport function createTestContext() {\n  return {\n    db,\n    user: null,\n  };\n}\n```\n\n```ts tab=\"In-Memory\" title=\"tests/setup.ts\"\n// Simple in-memory store for testing\nclass InMemoryStore {\n  private data = new Map<string, any[]>();\n\n  get(table: string) {\n    return this.data.get(table) || [];\n  }\n\n  add(table: string, item: any) {\n    const items = this.get(table);\n    const newItem = { ...item, id: Math.random().toString() };\n    items.push(newItem);\n    this.data.set(table, items);\n    return newItem;\n  }\n\n  clear() {\n    this.data.clear();\n  }\n}\n\nexport const testDb = new InMemoryStore();\n\nexport function createTestContext() {\n  return {\n    db: testDb,\n    user: null,\n  };\n}\n```\n\n</Tabs>\n\n### Testing Error Cases\n\nTest error scenarios and validation:\n\n```ts title=\"tests/posts.test.ts\"\nimport { describe, it, expect } from 'vitest';\nimport { TRPCError } from '@trpc/server';\n\ndescribe('Posts Router - Error Cases', () => {\n  it('should throw UNAUTHORIZED when user is not logged in', async () => {\n    const caller = createCaller({ user: null, db: mockDb });\n\n    await expect(\n      caller.create({\n        title: 'Test Post',\n        content: 'Content',\n      })\n    ).rejects.toThrow(TRPCError);\n  });\n\n  it('should validate input properly', async () => {\n    const caller = createCaller(createTestContext());\n\n    await expect(\n      caller.create({\n        title: '', // Empty title should fail\n        content: 'Content',\n      })\n    ).rejects.toThrow('String must contain at least 1 character(s)');\n  });\n\n  it('should handle not found errors', async () => {\n    const caller = createCaller(createTestContext());\n\n    await expect(\n      caller.byId({ id: 'non-existent-id' })\n    ).rejects.toThrow('Post not found');\n  });\n});\n```\n\n## Testing Middleware\n\n### Authentication Middleware\n\nTest middleware behavior in isolation:\n\n```ts title=\"tests/middleware.test.ts\"\nimport { describe, it, expect } from 'vitest';\nimport { TRPCError } from '@trpc/server';\nimport { authMiddleware } from '../server/middleware/auth';\n\ndescribe('Auth Middleware', () => {\n  it('should pass through when user is authenticated', async () => {\n    const mockNext = vi.fn().mockResolvedValue({ ok: true, data: 'success' });\n\n    const result = await authMiddleware({\n      ctx: { user: { id: '1', role: 'user' } },\n      next: mockNext,\n      path: 'test',\n      type: 'query',\n    });\n\n    expect(mockNext).toHaveBeenCalled();\n    expect(result.data).toBe('success');\n  });\n\n  it('should throw UNAUTHORIZED when user is not authenticated', async () => {\n    const mockNext = vi.fn();\n\n    await expect(\n      authMiddleware({\n        ctx: { user: null },\n        next: mockNext,\n        path: 'test',\n        type: 'query',\n      })\n    ).rejects.toThrow(TRPCError);\n\n    expect(mockNext).not.toHaveBeenCalled();\n  });\n\n  it('should throw FORBIDDEN for insufficient role', async () => {\n    const mockNext = vi.fn();\n\n    await expect(\n      adminMiddleware({\n        ctx: { user: { id: '1', role: 'user' } },\n        next: mockNext,\n        path: 'test',\n        type: 'query',\n        meta: { requiresAdmin: true },\n      })\n    ).rejects.toThrow(TRPCError);\n  });\n});\n```\n\n### Rate Limiting Middleware\n\nTest rate limiting logic:\n\n```ts title=\"tests/rateLimit.test.ts\"\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { rateLimitMiddleware } from '../server/middleware/rateLimit';\n\ndescribe('Rate Limit Middleware', () => {\n  beforeEach(() => {\n    // Clear rate limit cache\n    rateLimitMiddleware.clearCache();\n  });\n\n  it('should allow requests under the limit', async () => {\n    const mockNext = vi.fn().mockResolvedValue({ ok: true });\n\n    // First request should pass\n    await rateLimitMiddleware({\n      ctx: { ip: '127.0.0.1' },\n      next: mockNext,\n      path: 'test',\n      type: 'query',\n      meta: { rateLimit: 5 },\n    });\n\n    expect(mockNext).toHaveBeenCalled();\n  });\n\n  it('should block requests over the limit', async () => {\n    const mockNext = vi.fn().mockResolvedValue({ ok: true });\n\n    // Make 5 requests (the limit)\n    for (let i = 0; i < 5; i++) {\n      await rateLimitMiddleware({\n        ctx: { ip: '127.0.0.1' },\n        next: mockNext,\n        path: 'test',\n        type: 'query',\n        meta: { rateLimit: 5 },\n      });\n    }\n\n    // 6th request should fail\n    await expect(\n      rateLimitMiddleware({\n        ctx: { ip: '127.0.0.1' },\n        next: mockNext,\n        path: 'test',\n        type: 'query',\n        meta: { rateLimit: 5 },\n      })\n    ).rejects.toThrow('TOO_MANY_REQUESTS');\n  });\n});\n```\n\n## Integration Testing\n\n### HTTP Integration Tests\n\nTest the complete HTTP flow:\n\n```ts title=\"tests/integration.test.ts\"\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from '../server/routers/_app';\nimport { createContext } from '../server/context';\n\ndescribe('tRPC Integration Tests', () => {\n  let server: any;\n  let serverUrl: string;\n\n  beforeAll(async () => {\n    server = createHTTPServer({\n      router: appRouter,\n      createContext,\n    });\n\n    await new Promise<void>((resolve) => {\n      server.listen(0, () => {\n        const port = server.address()?.port;\n        serverUrl = `http://localhost:${port}`;\n        resolve();\n      });\n    });\n  });\n\n  afterAll(() => {\n    server?.close();\n  });\n\n  it('should handle HTTP requests', async () => {\n    const response = await fetch(\n      `${serverUrl}/posts.list`,\n      {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    expect(response.ok).toBe(true);\n    const data = await response.json();\n    expect(data.result).toBeDefined();\n  });\n\n  it('should handle authentication', async () => {\n    const response = await fetch(\n      `${serverUrl}/posts.create`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer invalid-token',\n        },\n        body: JSON.stringify({\n          title: 'Test Post',\n          content: 'Content',\n        }),\n      }\n    );\n\n    expect(response.status).toBe(401);\n  });\n});\n```\n\n### Next.js API Route Testing\n\nTest Next.js API routes with tRPC:\n\n```ts title=\"tests/api.test.ts\"\nimport { createMocks } from 'node-mocks-http';\nimport handler from '../pages/api/trpc/[trpc]';\n\ndescribe('/api/trpc', () => {\n  it('should handle GET requests', async () => {\n    const { req, res } = createMocks({\n      method: 'GET',\n      url: '/api/trpc/posts.list',\n    });\n\n    await handler(req, res);\n\n    expect(res._getStatusCode()).toBe(200);\n    const data = JSON.parse(res._getData());\n    expect(data.result).toBeDefined();\n  });\n\n  it('should handle POST requests', async () => {\n    const { req, res } = createMocks({\n      method: 'POST',\n      url: '/api/trpc/posts.create',\n      body: {\n        title: 'Test Post',\n        content: 'Content',\n      },\n      headers: {\n        'content-type': 'application/json',\n      },\n    });\n\n    await handler(req, res);\n\n    expect(res._getStatusCode()).toBe(200);\n  });\n});\n```\n\n## Testing Patterns\n\n### Test Factories\n\nCreate reusable test data factories:\n\n```ts title=\"tests/factories.ts\"\nimport { faker } from '@faker-js/faker';\n\nexport const userFactory = (overrides?: Partial<User>) => ({\n  id: faker.string.uuid(),\n  email: faker.internet.email(),\n  name: faker.person.fullName(),\n  role: 'user' as const,\n  createdAt: new Date(),\n  ...overrides,\n});\n\nexport const postFactory = (overrides?: Partial<Post>) => ({\n  id: faker.string.uuid(),\n  title: faker.lorem.sentence(),\n  content: faker.lorem.paragraphs(3),\n  authorId: faker.string.uuid(),\n  published: false,\n  createdAt: new Date(),\n  ...overrides,\n});\n\n// Usage in tests\ndescribe('Posts', () => {\n  it('should create post with valid data', async () => {\n    const user = userFactory();\n    const postData = postFactory({ authorId: user.id });\n\n    const caller = createCaller({ user, db: mockDb });\n    const result = await caller.create(postData);\n\n    expect(result).toMatchObject(postData);\n  });\n});\n```\n\n### Mock Services\n\nMock external dependencies:\n\n```ts title=\"tests/mocks.ts\"\nimport { vi } from 'vitest';\n\n// Mock email service\nexport const mockEmailService = {\n  send: vi.fn().mockResolvedValue({ id: 'email-123' }),\n  verify: vi.fn().mockResolvedValue(true),\n};\n\n// Mock storage service\nexport const mockStorageService = {\n  upload: vi.fn().mockResolvedValue({ url: 'https://example.com/file.jpg' }),\n  delete: vi.fn().mockResolvedValue(true),\n};\n\n// Mock external API\nexport const mockExternalApi = {\n  get: vi.fn(),\n  post: vi.fn(),\n};\n\n// Use in tests\ndescribe('User Registration', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should send welcome email after registration', async () => {\n    const caller = createCaller({\n      emailService: mockEmailService,\n      db: testDb,\n    });\n\n    await caller.register({\n      email: 'test@example.com',\n      password: 'password123',\n    });\n\n    expect(mockEmailService.send).toHaveBeenCalledWith({\n      to: 'test@example.com',\n      template: 'welcome',\n      data: expect.any(Object),\n    });\n  });\n});\n```\n\n### Advanced Test Factories\n\nCreate reusable test factories for complex scenarios:\n\n**1. Create Test Factory System**\n\n```typescript title=\"tests/factories/index.ts\"\ninterface TestUser {\n  id: string;\n  email: string;\n  role: 'user' | 'admin';\n  createdAt: Date;\n}\n\ninterface TestPost {\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n  published: boolean;\n}\n\nexport class TestFactory {\n  private userCounter = 0;\n  private postCounter = 0;\n\n  createUser(overrides: Partial<TestUser> = {}): TestUser {\n    this.userCounter++;\n    return {\n      id: `user-${this.userCounter}`,\n      email: `user${this.userCounter}@example.com`,\n      role: 'user',\n      createdAt: new Date(),\n      ...overrides,\n    };\n  }\n\n  createPost(authorId: string, overrides: Partial<TestPost> = {}): TestPost {\n    this.postCounter++;\n    return {\n      id: `post-${this.postCounter}`,\n      title: `Test Post ${this.postCounter}`,\n      content: `Content for post ${this.postCounter}`,\n      authorId,\n      published: false,\n      ...overrides,\n    };\n  }\n\n  async seedDatabase(db: Database) {\n    const users = [\n      this.createUser({ role: 'admin' }),\n      this.createUser(),\n      this.createUser(),\n    ];\n\n    const posts = [\n      this.createPost(users[1].id, { published: true }),\n      this.createPost(users[1].id),\n      this.createPost(users[2].id, { published: true }),\n    ];\n\n    await db.user.createMany({ data: users });\n    await db.post.createMany({ data: posts });\n\n    return { users, posts };\n  }\n}\n```\n\n**2. Setup Database Test Utilities**\n\n```typescript title=\"tests/utils/db.ts\"\nimport { PrismaClient } from '@prisma/client';\nimport { execSync } from 'child_process';\n\nlet prisma: PrismaClient;\n\nexport async function setupTestDatabase() {\n  // Generate unique database URL for this test run\n  const testId = Math.random().toString(36).substring(7);\n  const databaseUrl = `file:./test-${testId}.db`;\n\n  process.env.DATABASE_URL = databaseUrl;\n\n  // Run migrations\n  execSync('npx prisma migrate deploy', {\n    env: { ...process.env, DATABASE_URL: databaseUrl },\n    stdio: 'ignore'\n  });\n\n  prisma = new PrismaClient();\n  await prisma.$connect();\n\n  return prisma;\n}\n\nexport async function teardownTestDatabase() {\n  await prisma.$disconnect();\n\n  // Clean up test database file\n  const fs = await import('fs');\n  const path = require('path');\n  const dbPath = process.env.DATABASE_URL?.replace('file:', '');\n  if (dbPath && fs.existsSync(dbPath)) {\n    fs.unlinkSync(dbPath);\n  }\n}\n\nexport { prisma };\n```\n\n**3. Create Comprehensive Test Suite**\n\n```typescript title=\"tests/integration/posts.test.ts\"\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { setupTestDatabase, teardownTestDatabase } from '../utils/db';\nimport { TestFactory } from '../factories';\nimport { createCaller } from '../../src/server/trpc';\n\ndescribe('Posts Integration Tests', () => {\n  let caller: ReturnType<typeof createCaller>;\n  let factory: TestFactory;\n  let testData: Awaited<ReturnType<typeof factory.seedDatabase>>;\n\n  beforeEach(async () => {\n    const db = await setupTestDatabase();\n    factory = new TestFactory();\n    testData = await factory.seedDatabase(db);\n\n    caller = createCaller({\n      user: testData.users[0], // Admin user\n      db,\n    });\n  });\n\n  afterEach(async () => {\n    await teardownTestDatabase();\n  });\n\n  describe('Post Creation', () => {\n    it('should create a post successfully', async () => {\n      const newPost = await caller.posts.create({\n        title: 'Integration Test Post',\n        content: 'This is a test post content',\n      });\n\n      expect(newPost).toMatchObject({\n        id: expect.any(String),\n        title: 'Integration Test Post',\n        content: 'This is a test post content',\n        authorId: testData.users[0].id,\n        published: false,\n      });\n    });\n\n    it('should handle validation errors', async () => {\n      await expect(\n        caller.posts.create({\n          title: '', // Invalid empty title\n          content: 'Valid content',\n        })\n      ).rejects.toThrow('Title cannot be empty');\n    });\n  });\n\n  describe('Post Querying', () => {\n    it('should return published posts only for non-authors', async () => {\n      // Create caller as regular user\n      const userCaller = createCaller({\n        user: testData.users[1],\n        db: prisma,\n      });\n\n      const posts = await userCaller.posts.list();\n\n      expect(posts.every(p => p.published)).toBe(true);\n      expect(posts).toHaveLength(2); // Only published posts\n    });\n\n    it('should return all posts for admin users', async () => {\n      const posts = await caller.posts.list();\n\n      expect(posts).toHaveLength(3); // All posts including unpublished\n    });\n  });\n\n  describe('Post Updates', () => {\n    it('should allow authors to update their posts', async () => {\n      const authorCaller = createCaller({\n        user: testData.users[1],\n        db: prisma,\n      });\n\n      const updatedPost = await authorCaller.posts.update({\n        id: testData.posts[0].id,\n        title: 'Updated Title',\n      });\n\n      expect(updatedPost.title).toBe('Updated Title');\n    });\n\n    it('should prevent non-authors from updating posts', async () => {\n      const otherUserCaller = createCaller({\n        user: testData.users[2],\n        db: prisma,\n      });\n\n      await expect(\n        otherUserCaller.posts.update({\n          id: testData.posts[0].id, // Post by users[1]\n          title: 'Hacked Title',\n        })\n      ).rejects.toThrow('Unauthorized');\n    });\n  });\n});\n```\n\n## Best Practices\n\n<Steps>\n\n### Use Type-Safe Testing\n\nLeverage TypeScript for better test safety:\n\n```ts\nimport type { inferProcedureInput, inferProcedureOutput } from '@trpc/server';\nimport type { AppRouter } from '../server/routers/_app';\n\ntype PostCreateInput = inferProcedureInput<AppRouter['posts']['create']>;\ntype PostCreateOutput = inferProcedureOutput<AppRouter['posts']['create']>;\n\nconst validInput: PostCreateInput = {\n  title: 'Test',\n  content: 'Content',\n};\n```\n\n### Test Error Boundaries\n\nAlways test both success and failure cases:\n\n```ts\ndescribe('Error Handling', () => {\n  it('should handle validation errors', async () => {\n    await expect(caller.create({})).rejects.toThrow(ZodError);\n  });\n\n  it('should handle authorization errors', async () => {\n    const unauthorizedCaller = createCaller({ user: null });\n    await expect(unauthorizedCaller.create(validInput))\n      .rejects.toThrow('UNAUTHORIZED');\n  });\n\n  it('should handle not found errors', async () => {\n    await expect(caller.byId({ id: 'invalid' }))\n      .rejects.toThrow('NOT_FOUND');\n  });\n});\n```\n\n### Use Test Utilities\n\nCreate reusable test utilities:\n\n```ts title=\"tests/utils.ts\"\nexport function createAuthedCaller(user?: Partial<User>) {\n  return createCaller({\n    user: userFactory(user),\n    db: testDb,\n  });\n}\n\nexport function createAnonCaller() {\n  return createCaller({\n    user: null,\n    db: testDb,\n  });\n}\n\nexport async function expectTRPCError(\n  promise: Promise<any>,\n  code: string\n) {\n  try {\n    await promise;\n    throw new Error('Expected promise to reject');\n  } catch (error) {\n    expect(error).toBeInstanceOf(TRPCError);\n    expect(error.code).toBe(code);\n  }\n}\n```\n\n### Test Performance\n\nMonitor procedure performance:\n\n```ts\ndescribe('Performance Tests', () => {\n  it('should complete list query within time limit', async () => {\n    const start = Date.now();\n\n    await caller.list();\n\n    const duration = Date.now() - start;\n    expect(duration).toBeLessThan(1000); // Should complete in under 1s\n  });\n\n  it('should handle concurrent requests', async () => {\n    const promises = Array(10).fill(null).map(() =>\n      caller.list()\n    );\n\n    const results = await Promise.all(promises);\n\n    expect(results).toHaveLength(10);\n    results.forEach(result => {\n      expect(Array.isArray(result)).toBe(true);\n    });\n  });\n});\n```\n\n</Steps>\n\n## Testing Tools\n\n### Recommended Testing Stack\n\n<TypeTable\n  type={{\n    Vitest: {\n      description: 'Fast test runner with great TypeScript support',\n      type: 'Test Runner',\n    },\n    Jest: {\n      description: 'Popular testing framework with extensive ecosystem',\n      type: 'Test Runner',\n    },\n    '@faker-js/faker': {\n      description: 'Generate realistic test data',\n      type: 'Test Data',\n    },\n    'node-mocks-http': {\n      description: 'Mock HTTP requests for Next.js API testing',\n      type: 'Mocking',\n    },\n    supertest: {\n      description: 'HTTP assertion library for integration tests',\n      type: 'HTTP Testing',\n    },\n    msw: {\n      description: 'Mock external API calls',\n      type: 'API Mocking',\n    },\n  }}\n/>\n\n### Configuration Example\n\n```ts title=\"vitest.config.ts\"\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    setupFiles: ['./tests/setup.ts'],\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n      exclude: [\n        'node_modules/',\n        'tests/',\n        '**/*.d.ts',\n      ],\n    },\n  },\n});\n```\n\n<Callout type=\"info\">\n  Remember to test both the happy path and edge cases. Good tests give you\n  confidence to refactor and add new features without breaking existing\n  functionality.\n</Callout>\n"}, {"info":{"path":"server/validators.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/validators.mdx"},"lastModified":"2025-06-28T20:49:45.000Z","data":{"title":"Input & Output Validators","description":"Validate inputs and outputs with type-safe schema validation libraries","icon":"IconShield","index":false},"content":"\ntRPC procedures can define validation logic for their input and/or output, ensuring data integrity and providing automatic TypeScript type inference. We support many popular validation libraries out of the box.\n\n<Callout title=\"Validation Benefits\">\n  - **Type Safety**: Automatic TypeScript inference for inputs and outputs -\n  **Data Integrity**: Ensure data matches expected schemas before processing -\n  **Error Prevention**: Catch validation errors before they reach your business\n  logic - **Documentation**: Schemas serve as living documentation of your API\n</Callout>\n\n## Input Validation\n\nInput validation checks that procedure calls are correct and returns structured validation errors if not.\n\n### Basic Input Validation\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  createUser: publicProcedure\n    .input(z.object({\n      name: z.string().min(2, 'Name must be at least 2 characters'),\n      email: z.string().email('Must be a valid email'),\n      age: z.number().int().min(13, 'Must be at least 13 years old'),\n    }))\n    .mutation(({ input }) => {\n      // input is fully typed and validated\n      const { name, email, age } = input;\n      //      ^? string, string, number\n\n      return createUserInDatabase({ name, email, age });\n    }),\n});\n```\n\n### Input Merging\n\nStack multiple `.input()` calls to build complex validation schemas:\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Base procedure with common validation\nconst baseProcedure = publicProcedure\n  .input(z.object({\n    organizationId: z.string().uuid()\n  }))\n  .use(({ input, next }) => {\n    console.log(`Request for organization: ${input.organizationId}`);\n    return next();\n  });\n\nexport const appRouter = router({\n  createProject: baseProcedure\n    .input(z.object({\n      name: z.string().min(1),\n      description: z.string().optional(),\n    }))\n    .mutation(({ input }) => {\n      // input contains both organizationId and project data\n      const { organizationId, name, description } = input;\n      //      ^? string, string, string | undefined\n\n      return createProject({ organizationId, name, description });\n    }),\n\n  updateProject: baseProcedure\n    .input(z.object({\n      projectId: z.string().uuid(),\n      name: z.string().min(1).optional(),\n      description: z.string().optional(),\n    }))\n    .mutation(({ input }) => {\n      // input has organizationId + update data\n      const { organizationId, projectId, ...updates } = input;\n      return updateProject(projectId, updates);\n    }),\n});\n```\n\n## Output Validation\n\nOutput validation ensures your procedures return the expected data structure:\n\n<Callout title=\"When to use output validation\">\n  - Validating data from untrusted sources (external APIs, databases) - Ensuring\n  you don't expose sensitive information - Catching bugs in your business logic\n  - Creating consistent response formats\n</Callout>\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().email(),\n  createdAt: z.date(),\n  // Explicitly omit sensitive fields like password hashes\n});\n\nexport const appRouter = router({\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .output(UserSchema)\n    .query(async ({ input }) => {\n      const user = await getUserFromDatabase(input.id);\n\n      if (!user) {\n        throw new TRPCError({ code: 'NOT_FOUND' });\n      }\n\n      // Output will be validated against UserSchema\n      // TypeScript will enforce the return type matches\n      return user;\n    }),\n\n  getUserList: publicProcedure\n    .input(z.object({\n      limit: z.number().min(1).max(100).default(10),\n    }))\n    .output(z.object({\n      users: z.array(UserSchema),\n      total: z.number(),\n      hasMore: z.boolean(),\n    }))\n    .query(async ({ input }) => {\n      const { users, total } = await getUserList(input.limit);\n\n      return {\n        users,\n        total,\n        hasMore: total > input.limit,\n      };\n    }),\n});\n```\n\n## Library Integrations\n\ntRPC works with many popular validation libraries:\n\n### Zod (Recommended)\n\nZod is our default recommendation with excellent TypeScript integration:\n\n<Tabs items={['Basic', 'Advanced', 'Nested Objects']}>\n  <Tab value=\"Basic\">\n    ```typescript title=\"zod-basic.ts\"\n    import { z } from 'zod';\n    \n    const CreateUserSchema = z.object({\n      name: z.string().min(2).max(50),\n      email: z.string().email(),\n      age: z.number().int().min(13).max(120),\n      role: z.enum(['user', 'admin']).default('user'),\n    });\n    \n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(CreateUserSchema)\n        .mutation(({ input }) => {\n          // Fully typed and validated\n          return createUser(input);\n        }),\n    });\n    ```\n  </Tab>\n  \n  <Tab value=\"Advanced\">\n    ```typescript title=\"zod-advanced.ts\"\n    import { z } from 'zod';\n    \n    const AdvancedUserSchema = z.object({\n      name: z.string()\n        .min(2, 'Name too short')\n        .max(50, 'Name too long')\n        .regex(/^[a-zA-Z\\s]+$/, 'Name can only contain letters'),\n      \n      email: z.string()\n        .email('Invalid email format')\n        .transform(email => email.toLowerCase()),\n      \n      password: z.string()\n        .min(8, 'Password must be at least 8 characters')\n        .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/, \n               'Password must contain uppercase, lowercase, and number'),\n      \n      preferences: z.object({\n        theme: z.enum(['light', 'dark']).default('light'),\n        notifications: z.boolean().default(true),\n        language: z.string().default('en'),\n      }).optional(),\n      \n      tags: z.array(z.string()).max(10, 'Too many tags'),\n    });\n    \n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(AdvancedUserSchema)\n        .mutation(({ input }) => {\n          // email is automatically lowercased\n          // preferences has defaults applied\n          return createUser(input);\n        }),\n    });\n    ```\n  </Tab>\n  \n  <Tab value=\"Nested Objects\">\n    ```typescript title=\"zod-nested.ts\"\n    import { z } from 'zod';\n    \n    const AddressSchema = z.object({\n      street: z.string().min(1),\n      city: z.string().min(1),\n      state: z.string().length(2),\n      zipCode: z.string().regex(/^\\d{5}(-\\d{4})?$/),\n      country: z.string().default('US'),\n    });\n    \n    const ContactSchema = z.object({\n      phone: z.string().regex(/^\\+?[\\d\\s\\-\\(\\)]+$/),\n      email: z.string().email(),\n      preferredMethod: z.enum(['phone', 'email']),\n    });\n    \n    const CreateBusinessSchema = z.object({\n      name: z.string().min(1).max(100),\n      description: z.string().optional(),\n      address: AddressSchema,\n      contact: ContactSchema,\n      employees: z.array(z.object({\n        name: z.string(),\n        role: z.string(),\n        email: z.string().email(),\n      })).min(1, 'At least one employee required'),\n      established: z.date().max(new Date(), 'Cannot be in the future'),\n    });\n    \n    export const appRouter = router({\n      createBusiness: publicProcedure\n        .input(CreateBusinessSchema)\n        .mutation(({ input }) => {\n          // Fully typed nested object\n          return createBusiness(input);\n        }),\n    });\n    ```\n  </Tab>\n</Tabs>\n\n### Other Libraries\n\n<Tabs items={['Yup', 'Valibot', 'ArkType', 'Effect']}>\n  <Tab value=\"Yup\">\n    ```typescript title=\"yup-example.ts\"\n    import * as yup from 'yup';\n\n    const userSchema = yup.object({\n      name: yup.string().required().min(2).max(50),\n      email: yup.string().email().required(),\n      age: yup.number().integer().min(13).max(120).required(),\n    });\n\n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(userSchema)\n        .mutation(({ input }) => {\n          return createUser(input);\n        }),\n    });\n    ```\n\n  </Tab>\n\n  <Tab value=\"Valibot\">\n    ```typescript title=\"valibot-example.ts\"\n    import * as v from 'valibot';\n\n    const UserSchema = v.object({\n      name: v.pipe(v.string(), v.minLength(2), v.maxLength(50)),\n      email: v.pipe(v.string(), v.email()),\n      age: v.pipe(v.number(), v.integer(), v.minValue(13)),\n    });\n\n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(UserSchema)\n        .mutation(({ input }) => {\n          return createUser(input);\n        }),\n    });\n    ```\n\n  </Tab>\n\n  <Tab value=\"ArkType\">\n    ```typescript title=\"arktype-example.ts\"\n    import { type } from 'arktype';\n\n    const UserType = type({\n      name: 'string>2',\n      email: 'string.email',\n      age: 'number.integer>=13',\n    });\n\n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(UserType)\n        .mutation(({ input }) => {\n          return createUser(input);\n        }),\n    });\n    ```\n\n  </Tab>\n\n  <Tab value=\"Effect\">\n    ```typescript title=\"effect-example.ts\"\n    import { Schema } from 'effect';\n\n    const UserSchema = Schema.Struct({\n      name: Schema.String,\n      email: Schema.String,\n      age: Schema.Number,\n    });\n\n    export const appRouter = router({\n      createUser: publicProcedure\n        .input(Schema.standardSchemaV1(UserSchema))\n        .mutation(({ input }) => {\n          return createUser(input);\n        }),\n    });\n    ```\n\n  </Tab>\n</Tabs>\n\n## Advanced Validation Patterns\n\n### Conditional Validation\n\n```typescript title=\"conditional-validation.ts\"\nimport { z } from 'zod';\n\nconst CreateAccountSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('personal'),\n    name: z.string(),\n    email: z.string().email(),\n  }),\n  z.object({\n    type: z.literal('business'),\n    companyName: z.string(),\n    taxId: z.string(),\n    contactEmail: z.string().email(),\n  }),\n]);\n\nexport const appRouter = router({\n  createAccount: publicProcedure\n    .input(CreateAccountSchema)\n    .mutation(({ input }) => {\n      if (input.type === 'personal') {\n        // input.name and input.email are available\n        return createPersonalAccount(input);\n      } else {\n        // input.companyName and input.taxId are available\n        return createBusinessAccount(input);\n      }\n    }),\n});\n```\n\n### Transform and Sanitize\n\n```typescript title=\"transform-sanitize.ts\"\nimport { z } from 'zod';\n\nconst SanitizedUserSchema = z.object({\n  name: z.string()\n    .trim()\n    .transform(name => name.split(' ').map(word =>\n      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\n    ).join(' ')),\n\n  email: z.string()\n    .email()\n    .transform(email => email.toLowerCase()),\n\n  phone: z.string()\n    .transform(phone => phone.replace(/\\D/g, ''))\n    .refine(phone => phone.length === 10, 'Must be 10 digits'),\n\n  tags: z.array(z.string())\n    .transform(tags => [...new Set(tags.map(tag => tag.toLowerCase()))])\n    .refine(tags => tags.length <= 10, 'Too many tags'),\n});\n\nexport const appRouter = router({\n  createUser: publicProcedure\n    .input(SanitizedUserSchema)\n    .mutation(({ input }) => {\n      // input.name is properly capitalized\n      // input.email is lowercase\n      // input.phone contains only digits\n      // input.tags are unique and lowercase\n      return createUser(input);\n    }),\n});\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Learn how to handle validation errors gracefully\n  </Card>\n  <Card title=\"Middleware\" href=\"/docs/server/middlewares\">\n    Add validation middleware for reusable patterns\n  </Card>\n  <Card title=\"Data Transformers\" href=\"/docs/server/data-transformers\">\n    Transform data between client and server\n  </Card>\n  <Card title=\"Authorization\" href=\"/docs/server/authorization\">\n    Combine validation with authorization checks\n  </Card>\n</Cards>\n"}, {"info":{"path":"server/websockets.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/websockets.mdx"},"lastModified":null,"data":{"title":"WebSockets","description":"Set up real-time communication with WebSocket support in tRPC","icon":"IconBolt","index":false},"content":"\nYou can use WebSockets for all or some of the communication with your server, enabling real-time bidirectional communication between client and server.\n\n<Callout type=\"info\">\n  This document outlines the specific details of using WebSockets. For general\n  usage of subscriptions, see our [subscriptions guide](../subscriptions).\n</Callout>\n\n## Getting Started\n\n### Installation\n\nFirst, install the WebSocket dependency:\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n\n```bash tab=\"npm\"\nnpm install ws\nnpm install -D @types/ws\n```\n\n```bash tab=\"pnpm\"\npnpm add ws\npnpm add -D @types/ws\n```\n\n```bash tab=\"yarn\"\nyarn add ws\nyarn add -D @types/ws\n```\n\n```bash tab=\"bun\"\nbun add ws\nbun add -D @types/ws\n```\n\n</Tabs>\n\n### Creating a WebSocket Server\n\nCreate a WebSocket server that works alongside your HTTP server:\n\n```ts title=\"server/wsServer.ts\"\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\n\nconst wss = new ws.Server({\n  port: 3001,\n});\n\nconst handler = applyWSSHandler({\n  wss,\n  router: appRouter,\n  createContext,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n});\n\nwss.on('connection', (ws) => {\n  console.log(`‚ûï‚ûï Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`‚ûñ‚ûñ Connection (${wss.clients.size})`);\n  });\n});\n\nconsole.log('‚úÖ WebSocket Server listening on ws://localhost:3001');\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\n```\n\n## Client Setup\n\n### Using WebSocket Link\n\nConfigure your tRPC client to use WebSockets:\n\n```ts title=\"lib/trpc.ts\"\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server/routers/_app';\n\n// Create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n\n// Configure TRPCClient to use WebSockets transport\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\n```\n\n### Hybrid HTTP + WebSocket Setup\n\nYou can use [Links](../../client/links/overview) to route queries and mutations to HTTP transport and subscriptions over WebSockets:\n\n```ts title=\"lib/trpc.ts\"\nimport {\n  createTRPCClient,\n  createWSClient,\n  httpBatchLink,\n  wsLink,\n  splitLink\n} from '@trpc/client';\nimport type { AppRouter } from '../server/routers/_app';\n\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        return op.type === 'subscription';\n      },\n      true: wsLink({\n        client: wsClient,\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000/api/trpc',\n      }),\n    }),\n  ],\n});\n```\n\n## Authentication\n\n### Connection Parameters\n\nFor authentication, you can define `connectionParams` that will be sent when establishing the WebSocket connection:\n\n<Tabs items={['Server Context', 'Client Setup']}>\n\n```ts tab=\"Server Context\" title=\"server/context.ts\"\nimport type { CreateWSSContextFnOptions } from '@trpc/server/adapters/ws';\n\nexport const createContext = async (opts: CreateWSSContextFnOptions) => {\n  const token = opts.info.connectionParams?.token;\n\n  // Authenticate the user\n  const user = token ? await getUserFromToken(token) : null;\n\n  return {\n    user,\n  };\n};\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n```ts tab=\"Client Setup\" title=\"lib/trpc.ts\"\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server/routers/_app';\n\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n  connectionParams: async () => {\n    return {\n      token: localStorage.getItem('authToken'),\n    };\n  },\n});\n\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [wsLink({ client: wsClient })],\n});\n```\n\n</Tabs>\n\n<Callout type=\"info\">\n  If you're building a web application, cookies are automatically sent as part\n  of the WebSocket handshake, so you might not need connection parameters.\n</Callout>\n\n## Subscriptions with WebSockets\n\n### Basic Subscription\n\nCreate a subscription that sends real-time updates:\n\n```ts title=\"server/routers/posts.ts\"\nimport { observable } from '@trpc/server/observable';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nimport { EventEmitter } from 'events';\n\nconst ee = new EventEmitter();\n\nexport const postsRouter = router({\n  onPostAdd: publicProcedure.subscription(() => {\n    return observable<Post>((emit) => {\n      const onAdd = (data: Post) => {\n        emit.next(data);\n      };\n\n      ee.on('add', onAdd);\n\n      return () => {\n        ee.off('add', onAdd);\n      };\n    });\n  }),\n\n  add: publicProcedure\n    .input(z.object({ title: z.string() }))\n    .mutation(async ({ input }) => {\n      const post = await createPost(input);\n      ee.emit('add', post);\n      return post;\n    }),\n});\n```\n\n### Tracked Subscriptions\n\nUse the `tracked()` helper for automatic reconnection with last known ID:\n\n```ts title=\"server/routers/posts.ts\"\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\n\nexport const postsRouter = router({\n  onPostAdd: publicProcedure\n    .input(z.object({\n      lastEventId: z.string().nullish(),\n    }).optional())\n    .subscription(async function* (opts) {\n      if (opts.input?.lastEventId) {\n        // Get posts since last event ID\n        const posts = await getPostsSince(opts.input.lastEventId);\n        for (const post of posts) {\n          yield tracked(post.id, post);\n        }\n      }\n\n      // Listen for new events\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        yield tracked(post.id, post);\n      }\n    }),\n});\n```\n\n## WebSocket RPC Specification\n\ntRPC WebSockets follow a specific RPC specification for message format:\n\n### Query/Mutation Request\n\n```ts\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // optional\n  method: 'query' | 'mutation';\n  params: {\n    path: string;\n    input?: unknown; // procedure input, serialized by transformer\n  };\n}\n```\n\n### Query/Mutation Response\n\n```ts\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // only defined if included in request\n  result: {\n    type: 'data'; // always 'data' for mutation / queries\n    data: TOutput; // output from procedure\n  }\n}\n```\n\n### Subscription Messages\n\n#### Start Subscription\n\n```ts\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  method: 'subscription';\n  params: {\n    path: string;\n    input?: unknown;\n  };\n}\n```\n\n#### Stop Subscription\n\n```ts\n{\n  id: number | string; // id of your created subscription\n  jsonrpc?: '2.0';\n  method: 'subscription.stop';\n}\n```\n\n#### Subscription Response\n\n```ts\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  result: (\n    | {\n        type: 'data';\n        data: TData; // subscription emitted data\n      }\n    | {\n        type: 'started'; // subscription started\n      }\n    | {\n        type: 'stopped'; // subscription stopped\n      }\n  )\n}\n```\n\n## Error Handling\n\nWebSocket errors follow the [JSON-RPC 2.0 error specification](https://www.jsonrpc.org/specification#error_object):\n\n```ts\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  error: {\n    code: number;\n    message: string;\n    data?: {\n      code: string;\n      httpStatus: number;\n      path: string;\n      stack?: string; // only in development\n    };\n  };\n}\n```\n\n## Advanced Features\n\n### Connection Lifecycle\n\nHandle connection events for better user experience:\n\n```ts title=\"lib/trpc.ts\"\nconst wsClient = createWSClient({\n  url: 'ws://localhost:3001',\n  onOpen() {\n    console.log('WebSocket connected');\n  },\n  onClose() {\n    console.log('WebSocket disconnected');\n  },\n  onError(err) {\n    console.error('WebSocket error:', err);\n  },\n});\n```\n\n### Graceful Shutdown\n\nProperly handle server shutdown with reconnection notifications:\n\n```ts title=\"server/wsServer.ts\"\n// Broadcast reconnect notification before shutdown\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, broadcasting reconnect notification');\n  handler.broadcastReconnectNotification();\n\n  setTimeout(() => {\n    wss.close();\n    process.exit(0);\n  }, 1000);\n});\n```\n\n### Heartbeat Configuration\n\nKeep connections alive with heartbeat messages:\n\n```ts title=\"server/wsServer.ts\"\nconst handler = applyWSSHandler({\n  wss,\n  router: appRouter,\n  createContext,\n  keepAlive: {\n    enabled: true,\n    pingMs: 30000,    // Send ping every 30 seconds\n    pongWaitMs: 5000, // Wait 5 seconds for pong response\n  },\n});\n```\n\n## Best Practices\n\n<Steps>\n\n### Use Subscriptions Sparingly\n\nOnly use subscriptions for data that needs real-time updates. For most data, regular queries with polling or refetching work better.\n\n### Handle Connection States\n\nAlways handle WebSocket connection states in your UI:\n\n```tsx\nfunction useConnectionState() {\n  const [isConnected, setIsConnected] = useState(false);\n\n  useEffect(() => {\n    const ws = wsClient.getConnection();\n\n    ws.addEventListener('open', () => setIsConnected(true));\n    ws.addEventListener('close', () => setIsConnected(false));\n\n    return () => {\n      // Cleanup listeners\n    };\n  }, []);\n\n  return isConnected;\n}\n```\n\n### Implement Reconnection Logic\n\nThe WebSocket client automatically reconnects, but you should handle this in your UI:\n\n```tsx\nfunction MyComponent() {\n  const isConnected = useConnectionState();\n\n  if (!isConnected) {\n    return <div className=\"banner\">Reconnecting...</div>;\n  }\n\n  return <div>{/* Your content */}</div>;\n}\n```\n\n### Clean Up Subscriptions\n\nAlways unsubscribe when components unmount:\n\n```tsx\nuseEffect(() => {\n  const subscription = trpc.posts.onAdd.subscribe(undefined, {\n    onData: (post) => {\n      // Handle new post\n    },\n  });\n\n  return () => {\n    subscription.unsubscribe();\n  };\n}, []);\n```\n\n</Steps>\n\n## Notifications from Server\n\n### Reconnect Notification\n\nThe server can send reconnect notifications to all clients:\n\n```ts\n{\n  id: null,\n  type: 'reconnect'\n}\n```\n\nThis tells clients to reconnect before the server shuts down. You can trigger this with:\n\n```ts\nhandler.broadcastReconnectNotification();\n```\n\n### Advanced WebSocket Features\n\n**1. Implement Heartbeat System**\n\n```typescript title=\"src/lib/websocket-heartbeat.ts\"\ninterface HeartbeatConfig {\n  interval: number;\n  timeout: number;\n  maxMissed: number;\n}\n\nexport class WebSocketHeartbeat {\n  private intervals = new Map<string, NodeJS.Timeout>();\n  private missedPings = new Map<string, number>();\n\n  constructor(private config: HeartbeatConfig = {\n    interval: 30000,  // 30 seconds\n    timeout: 5000,    // 5 seconds\n    maxMissed: 3,     // 3 missed pings\n  }) {}\n\n  start(connectionId: string, ws: WebSocket) {\n    const interval = setInterval(() => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.ping();\n\n        // Set timeout for pong response\n        const timeout = setTimeout(() => {\n          const missed = (this.missedPings.get(connectionId) || 0) + 1;\n          this.missedPings.set(connectionId, missed);\n\n          if (missed >= this.config.maxMissed) {\n            console.log(`Connection ${connectionId} missed ${missed} pings, closing`);\n            ws.close(1000, 'Heartbeat timeout');\n            this.stop(connectionId);\n          }\n        }, this.config.timeout);\n\n        ws.once('pong', () => {\n          clearTimeout(timeout);\n          this.missedPings.set(connectionId, 0);\n        });\n      }\n    }, this.config.interval);\n\n    this.intervals.set(connectionId, interval);\n  }\n\n  stop(connectionId: string) {\n    const interval = this.intervals.get(connectionId);\n    if (interval) {\n      clearInterval(interval);\n      this.intervals.delete(connectionId);\n    }\n    this.missedPings.delete(connectionId);\n  }\n}\n```\n\n**2. Create Connection Manager**\n\n```typescript title=\"src/lib/websocket-manager.ts\"\ninterface Connection {\n  id: string;\n  ws: WebSocket;\n  userId?: string;\n  subscriptions: Set<string>;\n  lastActivity: Date;\n}\n\nexport class WebSocketManager {\n  private connections = new Map<string, Connection>();\n  private heartbeat = new WebSocketHeartbeat();\n\n  addConnection(ws: WebSocket, userId?: string): string {\n    const connectionId = crypto.randomUUID();\n\n    const connection: Connection = {\n      id: connectionId,\n      ws,\n      userId,\n      subscriptions: new Set(),\n      lastActivity: new Date(),\n    };\n\n    this.connections.set(connectionId, connection);\n    this.heartbeat.start(connectionId, ws);\n\n    // Handle connection close\n    ws.on('close', () => {\n      this.removeConnection(connectionId);\n    });\n\n    return connectionId;\n  }\n\n  removeConnection(connectionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (connection) {\n      // Clean up subscriptions\n      connection.subscriptions.forEach(subId => {\n        this.unsubscribe(connectionId, subId);\n      });\n\n      this.heartbeat.stop(connectionId);\n      this.connections.delete(connectionId);\n\n      console.log(`Connection ${connectionId} removed`);\n    }\n  }\n\n  subscribe(connectionId: string, subscriptionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (connection) {\n      connection.subscriptions.add(subscriptionId);\n      connection.lastActivity = new Date();\n    }\n  }\n\n  unsubscribe(connectionId: string, subscriptionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (connection) {\n      connection.subscriptions.delete(subscriptionId);\n      // Clean up subscription logic here\n    }\n  }\n\n  broadcast(message: any, filter?: (connection: Connection) => boolean) {\n    this.connections.forEach((connection) => {\n      if (!filter || filter(connection)) {\n        if (connection.ws.readyState === WebSocket.OPEN) {\n          connection.ws.send(JSON.stringify(message));\n          connection.lastActivity = new Date();\n        }\n      }\n    });\n  }\n\n  getConnectionStats() {\n    return {\n      total: this.connections.size,\n      authenticated: Array.from(this.connections.values())\n        .filter(c => c.userId).length,\n      byUser: Array.from(this.connections.values())\n        .reduce((acc, c) => {\n          if (c.userId) {\n            acc[c.userId] = (acc[c.userId] || 0) + 1;\n          }\n          return acc;\n        }, {} as Record<string, number>),\n    };\n  }\n}\n```\n\n**3. Implement Graceful Shutdown**\n\n```typescript title=\"src/lib/graceful-shutdown.ts\"\nimport { WebSocketManager } from './websocket-manager';\n\nexport class GracefulShutdown {\n  private isShuttingDown = false;\n\n  constructor(private wsManager: WebSocketManager) {\n    // Handle process signals\n    process.on('SIGTERM', () => this.shutdown('SIGTERM'));\n    process.on('SIGINT', () => this.shutdown('SIGINT'));\n  }\n\n  private async shutdown(signal: string) {\n    if (this.isShuttingDown) return;\n\n    console.log(`Received ${signal}, starting graceful shutdown...`);\n    this.isShuttingDown = true;\n\n    // Stop accepting new connections\n    // (This would be handled at the server level)\n\n    // Notify all connected clients\n    this.wsManager.broadcast({\n      type: 'server_shutdown',\n      message: 'Server is shutting down, please reconnect shortly',\n      reconnectAfter: 5000, // 5 seconds\n    });\n\n    // Wait for clients to receive the message\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Close all connections gracefully\n    const connections = Array.from(this.wsManager['connections'].values());\n\n    await Promise.all(\n      connections.map(async (connection) => {\n        if (connection.ws.readyState === WebSocket.OPEN) {\n          connection.ws.close(1001, 'Server restart');\n        }\n      })\n    );\n\n    console.log('All WebSocket connections closed gracefully');\n    process.exit(0);\n  }\n}\n\n// Usage in your server setup\nconst wsManager = new WebSocketManager();\nconst gracefulShutdown = new GracefulShutdown(wsManager);\n```\n"}, {"info":{"path":"server/framework/aws-lambda.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/aws-lambda.mdx"},"lastModified":null,"data":{"title":"AWS Lambda","description":"Deploy tRPC on AWS Lambda for serverless APIs","icon":"IconCloud","index":false},"content":"\nAWS Lambda lets you run tRPC serverlessly with automatic scaling and pay-per-request pricing. This guide shows you how to deploy tRPC on Lambda.\n\n## Installation\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/server zod npm install -D @types/aws-lambda\n    serverless typescript ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/server zod pnpm add -D @types/aws-lambda serverless\n    typescript ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/server zod yarn add -D @types/aws-lambda serverless\n    typescript ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/server zod bun add -D @types/aws-lambda serverless\n    typescript ```\n  </Tab>\n</Tabs>\n\n## Setup Guide\n\n### 1. Create tRPC Instance\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Create Your API Router\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.name ?? 'World'} from Lambda!`,\n        region: process.env.AWS_REGION || 'unknown',\n        timestamp: new Date(),\n      };\n    }),\n\n  getEnvironment: publicProcedure.query(() => {\n    return {\n      nodeVersion: process.version,\n      region: process.env.AWS_REGION,\n      functionName: process.env.AWS_LAMBDA_FUNCTION_NAME,\n      memorySize: process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE,\n      runtime: process.env.AWS_EXECUTION_ENV,\n    };\n  }),\n\n  processData: publicProcedure\n    .input(z.object({\n      data: z.array(z.number()),\n      operation: z.enum(['sum', 'average', 'max', 'min']),\n    }))\n    .mutation(({ input }) => {\n      const { data, operation } = input;\n\n      let result: number;\n      switch (operation) {\n        case 'sum':\n          result = data.reduce((a, b) => a + b, 0);\n          break;\n        case 'average':\n          result = data.reduce((a, b) => a + b, 0) / data.length;\n          break;\n        case 'max':\n          result = Math.max(...data);\n          break;\n        case 'min':\n          result = Math.min(...data);\n          break;\n      }\n\n      return {\n        operation,\n        input: data,\n        result,\n        processedAt: new Date(),\n      };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### 3. Create Lambda Handler\n\n```typescript title=\"src/lambda.ts\"\nimport { awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\nimport type { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';\nimport { appRouter } from './router';\n\n// Create context from Lambda event\nconst createContext = ({\n  event,\n  context,\n}: {\n  event: APIGatewayProxyEvent;\n  context: Context;\n}) => {\n  return {\n    event,\n    context,\n    user: null, // Add your auth logic here\n  };\n};\n\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n  onError: ({ error, path }) => {\n    console.error(`‚ùå tRPC failed on ${path}:`, error);\n  },\n});\n```\n\n### 4. Configure Serverless Framework\n\n```yaml title=\"serverless.yml\"\nservice: trpc-lambda-api\n\nframeworkVersion: '3'\n\nprovider:\n  name: aws\n  runtime: nodejs18.x\n  stage: ${opt:stage, 'dev'}\n  region: ${opt:region, 'us-east-1'}\n\n  environment:\n    NODE_ENV: ${self:provider.stage}\n\n  iam:\n    role:\n      statements:\n        # Add DynamoDB permissions if needed\n        - Effect: Allow\n          Action:\n            - dynamodb:Query\n            - dynamodb:Scan\n            - dynamodb:GetItem\n            - dynamodb:PutItem\n            - dynamodb:UpdateItem\n            - dynamodb:DeleteItem\n          Resource: '*'\n\nfunctions:\n  api:\n    handler: src/lambda.handler\n    events:\n      - http:\n          path: /{proxy+}\n          method: ANY\n          cors: true\n      - http:\n          path: /\n          method: ANY\n          cors: true\n\nplugins:\n  - serverless-plugin-typescript\n  - serverless-offline\n\ncustom:\n  serverless-offline:\n    httpPort: 3000\n```\n\n### 5. Add Build Configuration\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"dev\": \"serverless offline\",\n    \"deploy\": \"serverless deploy\",\n    \"deploy:prod\": \"serverless deploy --stage prod\",\n    \"build\": \"tsc\"\n  }\n}\n```\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Test Your Setup\n\nStart the development server:\n\n```bash\nnpm run dev\n```\n\nTest your endpoints:\n\n<Tabs items={['Hello', 'Environment Info', 'Process Data']}>\n<Tab value=\"Hello\">\n```bash\ncurl \"http://localhost:3000/hello?input=%7B%22name%22%3A%22Lambda%22%7D\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"greeting\": \"Hello Lambda from Lambda!\",\n      \"region\": \"us-east-1\",\n      \"timestamp\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Environment Info\">\n```bash\ncurl \"http://localhost:3000/getEnvironment\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"nodeVersion\": \"v18.18.0\",\n      \"region\": \"us-east-1\",\n      \"functionName\": \"trpc-lambda-api-dev-api\",\n      \"memorySize\": \"1024\",\n      \"runtime\": \"AWS_Lambda_nodejs18.x\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Process Data\">\n```bash\ncurl -X POST \"http://localhost:3000/processData\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"data\": [1, 2, 3, 4, 5], \"operation\": \"average\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"operation\": \"average\",\n      \"input\": [1, 2, 3, 4, 5],\n      \"result\": 3,\n      \"processedAt\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n## Add Database Integration\n\n### With DynamoDB\n\n```bash\nnpm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n```\n\n```typescript title=\"src/dynamodb.ts\"\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand, GetCommand, ScanCommand } from '@aws-sdk/lib-dynamodb';\n\nconst client = new DynamoDBClient({\n  region: process.env.AWS_REGION || 'us-east-1',\n});\n\nconst docClient = DynamoDBDocumentClient.from(client);\n\nexport const dynamoRouter = router({\n  createUser: publicProcedure\n    .input(z.object({\n      name: z.string(),\n      email: z.string().email(),\n    }))\n    .mutation(async ({ input }) => {\n      const user = {\n        id: Date.now().toString(),\n        ...input,\n        createdAt: new Date().toISOString(),\n      };\n\n      await docClient.send(new PutCommand({\n        TableName: 'Users',\n        Item: user,\n      }));\n\n      return user;\n    }),\n\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .query(async ({ input }) => {\n      const result = await docClient.send(new GetCommand({\n        TableName: 'Users',\n        Key: { id: input.id },\n      }));\n\n      if (!result.Item) {\n        throw new Error('User not found');\n      }\n\n      return result.Item;\n    }),\n\n  listUsers: publicProcedure.query(async () => {\n    const result = await docClient.send(new ScanCommand({\n      TableName: 'Users',\n    }));\n\n    return result.Items || [];\n  }),\n});\n```\n\nAdd DynamoDB table to serverless.yml:\n\n```yaml title=\"serverless.yml\"\nresources:\n  Resources:\n    UsersTable:\n      Type: AWS::DynamoDB::Table\n      Properties:\n        TableName: Users-${self:provider.stage}\n        BillingMode: PAY_PER_REQUEST\n        AttributeDefinitions:\n          - AttributeName: id\n            AttributeType: S\n        KeySchema:\n          - AttributeName: id\n            KeyType: HASH\n```\n\n### With RDS/Aurora\n\n```bash\nnpm install @aws-sdk/client-rds-data\n```\n\n```typescript title=\"src/rds.ts\"\nimport { RDSDataClient, ExecuteStatementCommand } from '@aws-sdk/client-rds-data';\n\nconst rdsClient = new RDSDataClient({\n  region: process.env.AWS_REGION || 'us-east-1',\n});\n\nexport const rdsRouter = router({\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string(),\n      content: z.string(),\n    }))\n    .mutation(async ({ input }) => {\n      const result = await rdsClient.send(new ExecuteStatementCommand({\n        resourceArn: process.env.RDS_CLUSTER_ARN,\n        secretArn: process.env.RDS_SECRET_ARN,\n        database: process.env.RDS_DATABASE,\n        sql: 'INSERT INTO posts (title, content) VALUES (:title, :content)',\n        parameters: [\n          { name: 'title', value: { stringValue: input.title } },\n          { name: 'content', value: { stringValue: input.content } },\n        ],\n      }));\n\n      return { success: true, insertId: result.generatedFields?.[0]?.longValue };\n    }),\n});\n```\n\n## Deploy to AWS\n\nDeploy to development:\n\n```bash\nnpm run deploy\n```\n\nDeploy to production:\n\n```bash\nnpm run deploy:prod\n```\n\nYour API will be available at:\n\n```\nhttps://your-api-id.execute-api.region.amazonaws.com/stage/\n```\n\n## Add Authentication\n\n### With AWS Cognito\n\n```typescript title=\"src/auth.ts\"\nimport { CognitoJwtVerifier } from 'aws-jwt-verify';\n\nconst verifier = CognitoJwtVerifier.create({\n  userPoolId: process.env.COGNITO_USER_POOL_ID!,\n  tokenUse: 'access',\n  clientId: process.env.COGNITO_CLIENT_ID!,\n});\n\nconst createContext = async ({ event, context }: { event: APIGatewayProxyEvent; context: Context }) => {\n  let user = null;\n\n  const authHeader = event.headers.Authorization || event.headers.authorization;\n  if (authHeader) {\n    try {\n      const token = authHeader.replace('Bearer ', '');\n      const payload = await verifier.verify(token);\n      user = {\n        id: payload.sub,\n        email: payload.email,\n        username: payload.username,\n      };\n    } catch (error) {\n      console.warn('Invalid token:', error);\n    }\n  }\n\n  return {\n    event,\n    context,\n    user,\n  };\n};\n\n// Protected procedure\nexport const protectedProcedure = publicProcedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n```\n\n### With API Gateway Authorizers\n\n```yaml title=\"serverless.yml\"\nfunctions:\n  api:\n    handler: src/lambda.handler\n    events:\n      - http:\n          path: /{proxy+}\n          method: ANY\n          cors: true\n          authorizer:\n            name: cognitoAuthorizer\n            type: COGNITO_USER_POOLS\n            arn: arn:aws:cognito-idp:region:account:userpool/pool-id\n```\n\n## Monitoring and Logging\n\n### With CloudWatch\n\n```typescript title=\"src/monitoring.ts\"\nexport const monitoredRouter = router({\n  processLargeData: publicProcedure\n    .input(z.object({ data: z.array(z.number()) }))\n    .mutation(async ({ input }) => {\n      const startTime = Date.now();\n\n      console.log('Processing data:', { count: input.data.length });\n\n      try {\n        // Your processing logic\n        const result = processData(input.data);\n\n        const duration = Date.now() - startTime;\n        console.log('Processing completed:', { duration, resultSize: result.length });\n\n        return result;\n      } catch (error) {\n        console.error('Processing failed:', error);\n        throw error;\n      }\n    }),\n});\n```\n\n### With X-Ray Tracing\n\nAdd to serverless.yml:\n\n```yaml\nprovider:\n  tracing:\n    lambda: true\n    apiGateway: true\n```\n\n## Client Usage\n\n```typescript title=\"client.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './src/router';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'https://your-api-id.execute-api.us-east-1.amazonaws.com/dev',\n      headers() {\n        const token = localStorage.getItem('auth-token');\n        return token ? { authorization: `Bearer ${token}` } : {};\n      },\n    }),\n  ],\n});\n\n// Usage\nasync function examples() {\n  const hello = await client.hello.query({ name: 'Lambda User' });\n  console.log(hello.greeting);\n\n  const env = await client.getEnvironment.query();\n  console.log('Running on:', env.runtime);\n}\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"DynamoDB\" href=\"https://docs.aws.amazon.com/dynamodb/\">\n    Learn about AWS's NoSQL database\n  </Card>\n  <Card title=\"API Gateway\" href=\"https://docs.aws.amazon.com/apigateway/\">\n    Advanced API Gateway configuration\n  </Card>\n  <Card title=\"CloudWatch\" href=\"https://docs.aws.amazon.com/cloudwatch/\">\n    Monitor your Lambda functions\n  </Card>\n  <Card title=\"Cognito\" href=\"https://docs.aws.amazon.com/cognito/\">\n    Add user authentication and management\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion title=\"Cold Starts\">\nLambda cold starts can be reduced by:\n- Keeping bundle size small\n- Using provisioned concurrency for critical functions\n- Implementing proper connection pooling\n\n```yaml\nfunctions:\n  api:\n    handler: src/lambda.handler\n    provisionedConcurrency: 5 # Keep 5 instances warm\n```\n\n</Accordion>\n\n<Accordion title=\"Bundle Size\">\nOptimize Lambda bundle size:\n- Use webpack or esbuild\n- Exclude dev dependencies\n- Use AWS SDK v3 with selective imports\n\n```javascript title=\"webpack.config.js\"\nmodule.exports = {\n  externals: ['aws-sdk'],\n  target: 'node',\n  mode: 'production',\n};\n```\n\n</Accordion>\n\n<Accordion title=\"Environment Variables\">\nUse AWS Systems Manager for sensitive data:\n\n```yaml\nprovider:\n  environment:\n    DB_PASSWORD: ${ssm:/myapp/db/password}\n```\n\n</Accordion>\n</Accordions>\n"}, {"info":{"path":"server/framework/express.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/express.mdx"},"lastModified":null,"data":{"title":"Express Setup","description":"Get started with tRPC in Express.js for traditional server APIs","icon":"IconServer","index":false},"content":"\nExpress.js is one of the most popular Node.js frameworks. This guide will show you how to integrate tRPC with Express to build type-safe APIs.\n\n## Installation\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/server express zod npm install -D @types/express\n    @types/node tsx typescript ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/server express zod pnpm add -D @types/express\n    @types/node tsx typescript ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/server express zod yarn add -D @types/express\n    @types/node tsx typescript ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/server express zod bun add -D @types/express\n    @types/node tsx typescript ```\n  </Tab>\n</Tabs>\n\n## Setup Guide\n\n### 1. Create tRPC Instance\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Create Your API Router\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Mock database\nconst posts: Array<{\n  id: string;\n  title: string;\n  content: string;\n  createdAt: Date;\n}> = [];\n\nexport const appRouter = router({\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.name ?? 'World'}!`,\n      };\n    }),\n\n  getPosts: publicProcedure.query(() => {\n    return posts;\n  }),\n\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(({ input }) => {\n      const post = {\n        id: Date.now().toString(),\n        ...input,\n        createdAt: new Date(),\n      };\n      posts.push(post);\n      return post;\n    }),\n\n  deletePost: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .mutation(({ input }) => {\n      const index = posts.findIndex(p => p.id === input.id);\n      if (index === -1) {\n        throw new Error('Post not found');\n      }\n      const deleted = posts.splice(index, 1)[0];\n      return deleted;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### 3. Setup Express Server\n\n```typescript title=\"src/server.ts\"\nimport express from 'express';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport { appRouter } from './router';\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// Create context\nconst createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  return {\n    req,\n    res,\n    // Add user info, database connections, etc.\n  };\n};\n\n// Add tRPC middleware\napp.use(\n  '/api/trpc',\n  createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  })\n);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n});\n\napp.listen(port, () => {\n  console.log(`üöÄ Server running at http://localhost:${port}`);\n  console.log(`üì° tRPC endpoint at http://localhost:${port}/api/trpc`);\n});\n```\n\n### 4. Add Scripts to package.json\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"dev\": \"tsx watch src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  }\n}\n```\n\n### 5. Create TypeScript Config\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Test Your Setup\n\nStart your server:\n\n```bash\nnpm run dev\n```\n\nTest your endpoints:\n\n<Tabs items={['Hello Query', 'Get Posts', 'Create Post', 'Delete Post']}>\n<Tab value=\"Hello Query\">\n```bash\ncurl \"http://localhost:3000/api/trpc/hello?input=%7B%22name%22%3A%22World%22%7D\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"greeting\": \"Hello World!\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Get Posts\">\n```bash\ncurl \"http://localhost:3000/api/trpc/getPosts\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": []\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Create Post\">\n```bash\ncurl -X POST \"http://localhost:3000/api/trpc/createPost\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"My First Post\", \"content\": \"Hello tRPC!\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"id\": \"1234567890\",\n      \"title\": \"My First Post\",\n      \"content\": \"Hello tRPC!\",\n      \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Delete Post\">\n```bash\ncurl -X POST \"http://localhost:3000/api/trpc/deletePost\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\": \"1234567890\"}'\n```\n</Tab>\n</Tabs>\n\n## Add Database Integration\n\nHere's how to integrate with popular databases:\n\n<Tabs items={['Prisma', 'Drizzle', 'Raw SQL']}>\n<Tab value=\"Prisma\">\n```bash\nnpm install prisma @prisma/client\nnpx prisma init\n```\n\n```typescript title=\"src/context.ts\"\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport const createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\nexport type Context = ReturnType<typeof createContext>;\n```\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  getPosts: publicProcedure.query(async ({ ctx }) => {\n    return await ctx.prisma.post.findMany({\n      orderBy: { createdAt: 'desc' },\n    });\n  }),\n\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      return await ctx.prisma.post.create({\n        data: input,\n      });\n    }),\n});\n```\n\n</Tab>\n<Tab value=\"Drizzle\">\n```bash\nnpm install drizzle-orm\nnpm install -D drizzle-kit\n```\n\n```typescript title=\"src/db/schema.ts\"\nimport { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\n\nexport const posts = pgTable('posts', {\n  id: serial('id').primaryKey(),\n  title: text('title').notNull(),\n  content: text('content').notNull(),\n  createdAt: timestamp('created_at').defaultNow(),\n});\n```\n\n```typescript title=\"src/context.ts\"\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { Pool } from 'pg';\nimport * as schema from './db/schema';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nconst db = drizzle(pool, { schema });\n\nexport const createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  return {\n    req,\n    res,\n    db,\n  };\n};\n```\n\n</Tab>\n<Tab value=\"Raw SQL\">\n```bash\nnpm install pg\nnpm install -D @types/pg\n```\n\n```typescript title=\"src/context.ts\"\nimport { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  return {\n    req,\n    res,\n    db: pool,\n  };\n};\n\nexport type Context = ReturnType<typeof createContext>;\n```\n\n```typescript title=\"src/router.ts\"\nexport const appRouter = router({\n  getPosts: publicProcedure.query(async ({ ctx }) => {\n    const result = await ctx.db.query(\n      'SELECT * FROM posts ORDER BY created_at DESC'\n    );\n    return result.rows;\n  }),\n\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      const result = await ctx.db.query(\n        'INSERT INTO posts (title, content) VALUES ($1, $2) RETURNING *',\n        [input.title, input.content]\n      );\n      return result.rows[0];\n    }),\n});\n```\n\n</Tab>\n</Tabs>\n\n## Add Authentication\n\nHere's how to add JWT authentication:\n\n```typescript title=\"src/auth.ts\"\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n\nexport function verifyToken(token: string) {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string; email: string };\n  } catch {\n    return null;\n  }\n}\n\nexport function signToken(payload: { userId: string; email: string }) {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });\n}\n```\n\n```typescript title=\"src/context.ts\"\nimport express from 'express';\nimport { verifyToken } from './auth';\n\nexport const createContext = ({ req, res }: { req: express.Request; res: express.Response }) => {\n  // Extract token from Authorization header\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  const user = token ? verifyToken(token) : null;\n\n  return {\n    req,\n    res,\n    user,\n  };\n};\n\nexport type Context = ReturnType<typeof createContext>;\n```\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n\n// Protected procedure\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n```\n\n```typescript title=\"src/router.ts\"\nexport const appRouter = router({\n  // Public routes\n  hello: publicProcedure.query(() => ({ message: 'Hello World!' })),\n\n  // Protected routes\n  getProfile: protectedProcedure.query(({ ctx }) => {\n    return {\n      userId: ctx.user.userId,\n      email: ctx.user.email,\n    };\n  }),\n\n  createPost: protectedProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // User is guaranteed to exist here\n      return await createPost({\n        ...input,\n        authorId: ctx.user.userId,\n      });\n    }),\n});\n```\n\n## Client Usage\n\nCreate a client to consume your API:\n\n```typescript title=\"client.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './src/router';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n      headers() {\n        const token = localStorage.getItem('auth-token');\n        return token ? { authorization: `Bearer ${token}` } : {};\n      },\n    }),\n  ],\n});\n\n// Usage examples\nasync function examples() {\n  // Query\n  const hello = await client.hello.query({ name: 'tRPC' });\n  console.log(hello.greeting);\n\n  // Mutation\n  const post = await client.createPost.mutate({\n    title: 'My Post',\n    content: 'Hello World!',\n  });\n  console.log('Created post:', post);\n\n  // Get all posts\n  const posts = await client.getPosts.query();\n  console.log('All posts:', posts);\n}\n```\n\n## Add CORS Support\n\nFor frontend applications on different domains:\n\n```bash\nnpm install cors\nnpm install -D @types/cors\n```\n\n```typescript title=\"src/server.ts\"\nimport express from 'express';\nimport cors from 'cors';\nimport { createExpressMiddleware } from '@trpc/server/adapters/express';\nimport { appRouter } from './router';\n\nconst app = express();\n\n// Add CORS middleware\napp.use(cors({\n  origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n  credentials: true,\n}));\n\n// Add tRPC middleware\napp.use(\n  '/api/trpc',\n  createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  })\n);\n\n// ... rest of server setup\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Add Database\" href=\"/docs/server/quickstart\">\n    Integrate with Prisma, Drizzle, or your preferred database\n  </Card>\n  <Card title=\"Authentication\" href=\"/docs/server/authorization\">\n    Add user authentication and role-based access control\n  </Card>\n  <Card title=\"Validation\" href=\"/docs/server/validators\">\n    Learn advanced input and output validation\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Handle errors gracefully with proper HTTP status codes\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion title=\"CORS Issues\">\nIf your frontend can't connect to your API, make sure CORS is properly configured:\n\n```typescript\napp.use(cors({\n  origin: ['http://localhost:3000', 'https://yourapp.com'],\n  credentials: true,\n}));\n```\n\n</Accordion>\n\n<Accordion title=\"Type Errors\">\nMake sure your TypeScript configuration is correct and all dependencies are installed:\n\n```bash\nnpm install -D typescript @types/node @types/express\n```\n\n</Accordion>\n\n<Accordion title=\"Port Already in Use\">\nIf port 3000 is already in use, change it in your server.ts file or use an environment variable:\n\n```typescript\nconst port = process.env.PORT || 3001;\n```\n\n</Accordion>\n</Accordions>\n"}, {"info":{"path":"server/framework/fastify.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/fastify.mdx"},"lastModified":null,"data":{"title":"Fastify Setup","description":"Get started with tRPC in Fastify for high-performance APIs","icon":"IconBolt","index":false},"content":"\nFastify is a high-performance Node.js framework. This guide shows you how to integrate tRPC with Fastify for blazing-fast APIs.\n\n## Installation\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/server fastify zod npm install -D @types/node tsx\n    typescript ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/server fastify zod pnpm add -D @types/node tsx\n    typescript ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/server fastify zod yarn add -D @types/node tsx\n    typescript ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/server fastify zod bun add -D @types/node tsx\n    typescript ```\n  </Tab>\n</Tabs>\n\n## Setup Guide\n\n### 1. Create tRPC Instance\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Create Your API Router\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Mock database\nconst posts: Array<{\n  id: string;\n  title: string;\n  content: string;\n  createdAt: Date;\n}> = [];\n\nexport const appRouter = router({\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.name ?? 'World'}!`,\n      };\n    }),\n\n  getPosts: publicProcedure.query(() => {\n    return posts;\n  }),\n\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(({ input }) => {\n      const post = {\n        id: Date.now().toString(),\n        ...input,\n        createdAt: new Date(),\n      };\n      posts.push(post);\n      return post;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### 3. Setup Fastify Server\n\n```typescript title=\"src/server.ts\"\nimport Fastify from 'fastify';\nimport { fastifyTRPCPlugin } from '@trpc/server/adapters/fastify';\nimport { appRouter } from './router';\n\nconst fastify = Fastify({\n  maxParamLength: 5000,\n  logger: true,\n});\n\n// Create context\nfunction createContext({ req, res }: { req: any; res: any }) {\n  return {\n    req,\n    res,\n    // Add user info, database connections, etc.\n  };\n}\n\n// Register tRPC plugin\nawait fastify.register(fastifyTRPCPlugin, {\n  prefix: '/api/trpc',\n  trpcOptions: {\n    router: appRouter,\n    createContext,\n    onError({ path, error }) {\n      console.error(`‚ùå tRPC failed on ${path ?? '<no-path>'}:`, error);\n    },\n  },\n});\n\n// Health check route\nfastify.get('/health', async () => {\n  return { status: 'ok', timestamp: new Date().toISOString() };\n});\n\n// Start server\nconst start = async () => {\n  try {\n    const port = process.env.PORT ? Number(process.env.PORT) : 3000;\n    await fastify.listen({ port, host: '0.0.0.0' });\n\n    console.log(`üöÄ Server running at http://localhost:${port}`);\n    console.log(`üì° tRPC endpoint at http://localhost:${port}/api/trpc`);\n  } catch (err) {\n    fastify.log.error(err);\n    process.exit(1);\n  }\n};\n\nstart();\n```\n\n### 4. Add Scripts to package.json\n\n```json title=\"package.json\"\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"tsx watch src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  }\n}\n```\n\n### 5. Create TypeScript Config\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"allowJs\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Test Your Setup\n\nStart your server:\n\n```bash\nnpm run dev\n```\n\nTest your endpoints:\n\n<Tabs items={['Hello Query', 'Get Posts', 'Create Post']}>\n<Tab value=\"Hello Query\">\n```bash\ncurl \"http://localhost:3000/api/trpc/hello?input=%7B%22name%22%3A%22Fastify%22%7D\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"greeting\": \"Hello Fastify!\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Get Posts\">\n```bash\ncurl \"http://localhost:3000/api/trpc/getPosts\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": []\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Create Post\">\n```bash\ncurl -X POST \"http://localhost:3000/api/trpc/createPost\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Fast Post\", \"content\": \"Hello Fastify!\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"id\": \"1234567890\",\n      \"title\": \"Fast Post\",\n      \"content\": \"Hello Fastify!\",\n      \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n## Add Authentication\n\n```typescript title=\"src/auth.ts\"\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n\nexport function verifyToken(token: string) {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string; email: string };\n  } catch {\n    return null;\n  }\n}\n```\n\n```typescript title=\"src/context.ts\"\nimport { FastifyRequest, FastifyReply } from 'fastify';\nimport { verifyToken } from './auth';\n\nexport function createContext({ req, res }: { req: FastifyRequest; res: FastifyReply }) {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  const user = token ? verifyToken(token) : null;\n\n  return {\n    req,\n    res,\n    user,\n  };\n}\n\nexport type Context = ReturnType<typeof createContext>;\n```\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n```\n\n## Add CORS Support\n\n```typescript title=\"src/server.ts\"\nimport Fastify from 'fastify';\n\nconst fastify = Fastify({ logger: true });\n\n// Register CORS\nawait fastify.register(import('@fastify/cors'), {\n  origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n  credentials: true,\n});\n\n// Register tRPC plugin\nawait fastify.register(fastifyTRPCPlugin, {\n  prefix: '/api/trpc',\n  trpcOptions: { router: appRouter, createContext },\n});\n```\n\n## Client Usage\n\n```typescript title=\"client.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './src/router';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n    }),\n  ],\n});\n\n// Usage\nasync function examples() {\n  const hello = await client.hello.query({ name: 'Fastify' });\n  console.log(hello.greeting);\n\n  const post = await client.createPost.mutate({\n    title: 'My Post',\n    content: 'Hello World!',\n  });\n  console.log('Created post:', post);\n}\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Add Database\" href=\"/docs/server/quickstart\">\n    Integrate with Prisma, Drizzle, or your preferred database\n  </Card>\n  <Card title=\"Authentication\" href=\"/docs/server/authorization\">\n    Add user authentication and authorization\n  </Card>\n  <Card title=\"Validation\" href=\"/docs/server/validators\">\n    Learn advanced input and output validation\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Handle errors gracefully with proper HTTP status codes\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion title=\"ESM Issues\">\nMake sure your package.json has `\"type\": \"module\"` and use ESM imports:\n\n```json\n{\n  \"type\": \"module\"\n}\n```\n\n</Accordion>\n\n<Accordion title=\"Plugin Registration\">\nFastify plugins must be registered with `await`:\n\n```typescript\nawait fastify.register(fastifyTRPCPlugin, options);\n```\n\n</Accordion>\n</Accordions>\n"}, {"info":{"path":"server/framework/nextjs.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/nextjs.mdx"},"lastModified":null,"data":{"title":"Next.js Setup","description":"Get started with tRPC in Next.js with App Router and Pages Router support","icon":"IconBrandNextjs","index":false},"content":"\ntRPC works seamlessly with Next.js, supporting both App Router and Pages Router. This guide will get you up and running in minutes.\n\n<Callout title=\"App Router Recommended\">\n  While both App Router and Pages Router are supported, App Router is\n  recommended for new projects.\n</Callout>\n\n## Installation\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/server @trpc/client @trpc/next zod ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/server @trpc/client @trpc/next zod ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/server @trpc/client @trpc/next zod ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/server @trpc/client @trpc/next zod ```\n  </Tab>\n</Tabs>\n\n## Setup Guide\n\n### 1. Create tRPC Instance\n\n```typescript title=\"src/server/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Create Your API Router\n\n```typescript title=\"src/server/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\nexport const appRouter = router({\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.name ?? 'World'}!`,\n      };\n    }),\n\n  createPost: publicProcedure\n    .input(z.object({\n      title: z.string().min(1),\n      content: z.string().min(1),\n    }))\n    .mutation(({ input }) => {\n      // Here you would save to your database\n      return {\n        id: Date.now().toString(),\n        ...input,\n        createdAt: new Date(),\n      };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### 3. Setup API Route\n\n<Tabs items={['App Router', 'Pages Router']}>\n<Tab value=\"App Router\">\n```typescript title=\"src/app/api/trpc/[trpc]/route.ts\"\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '../../../../server/router';\n\nconst handler = (req: Request) =>\nfetchRequestHandler({\nendpoint: '/api/trpc',\nreq,\nrouter: appRouter,\ncreateContext: () => ({}),\n});\n\nexport { handler as GET, handler as POST };\n```\n</Tab>\n<Tab value=\"Pages Router\">\n```typescript title=\"src/pages/api/trpc/[trpc].ts\"\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { appRouter } from '../../../server/router';\n\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: () => ({}),\n});\n```\n</Tab>\n</Tabs>\n\n### 4. Setup tRPC Client\n\n```typescript title=\"src/utils/trpc.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: '/api/trpc',\n    }),\n  ],\n});\n```\n\n### 5. Use in Your Components\n\n<Tabs items={['App Router', 'Pages Router', 'Client Component']}>\n<Tab value=\"App Router\">\n```typescript title=\"src/app/page.tsx\"\nimport { trpc } from '../utils/trpc';\n\nexport default async function HomePage() {\n  const hello = await trpc.hello.query({ name: 'tRPC' });\n\nreturn (\n\n<div>\n  <h1>{hello.greeting}</h1>\n</div>\n); }\n\n````\n</Tab>\n<Tab value=\"Pages Router\">\n```typescript title=\"src/pages/index.tsx\"\nimport { useEffect, useState } from 'react';\nimport { trpc } from '../utils/trpc';\n\nexport default function HomePage() {\n  const [greeting, setGreeting] = useState('');\n\n  useEffect(() => {\n    trpc.hello.query({ name: 'tRPC' }).then(setGreeting);\n  }, []);\n\n  return (\n    <div>\n      <h1>{greeting}</h1>\n    </div>\n  );\n}\n````\n\n</Tab>\n<Tab value=\"Client Component\">\n```typescript title=\"src/components/CreatePost.tsx\"\n'use client';\n\nimport { useState } from 'react';\nimport { trpc } from '../utils/trpc';\n\nexport default function CreatePost() {\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n\nconst handleSubmit = async (e: React.FormEvent) => {\ne.preventDefault();\n\n    try {\n      const post = await trpc.createPost.mutate({ title, content });\n      console.log('Created post:', post);\n\n      // Reset form\n      setTitle('');\n      setContent('');\n    } catch (error) {\n      console.error('Error creating post:', error);\n    }\n\n};\n\nreturn (\n\n<form onSubmit={handleSubmit}>\n  <input\n    type=\"text\"\n    value={title}\n    onChange={(e) => setTitle(e.target.value)}\n    placeholder=\"Post title\"\n    required\n  />\n  <textarea\n    value={content}\n    onChange={(e) => setContent(e.target.value)}\n    placeholder=\"Post content\"\n    required\n  />\n  <button type=\"submit\">Create Post</button>\n</form>\n); }\n\n````\n</Tab>\n</Tabs>\n\n## Test Your Setup\n\nStart your Next.js development server:\n\n```bash\nnpm run dev\n````\n\nTest your API by visiting:\n\n- `http://localhost:3000/api/trpc/hello?input={\"name\":\"World\"}`\n\nYou should see:\n\n```json\n{ \"result\": { \"data\": { \"greeting\": \"Hello World!\" } } }\n```\n\n## Add React Query Integration (Optional)\n\nFor a better client experience with caching and mutations:\n\n### Install React Query\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/react-query @tanstack/react-query ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/react-query @tanstack/react-query ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/react-query @tanstack/react-query ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/react-query @tanstack/react-query ```\n  </Tab>\n</Tabs>\n\n### Setup React Query Client\n\n```typescript title=\"src/utils/trpc.ts\"\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n### Setup Providers\n\n<Tabs items={['App Router', 'Pages Router']}>\n<Tab value=\"App Router\">\n```typescript title=\"src/app/providers.tsx\"\n'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { trpc } from '../utils/trpc';\n\nexport default function Providers({ children }: { children: React.ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: '/api/trpc',\n        }),\n      ],\n    }),\n  );\n\nreturn (\n\n<trpc.Provider client={trpcClient} queryClient={queryClient}>\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n</trpc.Provider>\n); }\n\n````\n\n```typescript title=\"src/app/layout.tsx\"\nimport Providers from './providers';\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <Providers>\n          {children}\n        </Providers>\n      </body>\n    </html>\n  );\n}\n````\n\n</Tab>\n<Tab value=\"Pages Router\">\n```typescript title=\"src/pages/_app.tsx\"\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { trpc } from '../utils/trpc';\nimport type { AppType } from 'next/app';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\nconst [queryClient] = useState(() => new QueryClient());\nconst [trpcClient] = useState(() =>\ntrpc.createClient({\nlinks: [\nhttpBatchLink({\nurl: '/api/trpc',\n}),\n],\n}),\n);\n\nreturn (\n\n<trpc.Provider client={trpcClient} queryClient={queryClient}>\n  <QueryClientProvider client={queryClient}>\n    <Component {...pageProps} />\n  </QueryClientProvider>\n</trpc.Provider>\n); };\n\nexport default trpc.withTRPC(MyApp);\n```\n</Tab>\n</Tabs>\n\n### Use React Query Hooks\n\n```typescript title=\"src/components/PostList.tsx\"\n'use client';\n\nimport { trpc } from '../utils/trpc';\n\nexport default function PostList() {\n  const { data: hello, isLoading } = trpc.hello.useQuery({ name: 'tRPC' });\n  const createPost = trpc.createPost.useMutation();\n\n  if (isLoading) return <div>Loading...</div>;\n\n  return (\n    <div>\n      <h1>{hello?.greeting}</h1>\n      <button\n        onClick={() =>\n          createPost.mutate({\n            title: 'My Post',\n            content: 'Hello World!'\n          })\n        }\n        disabled={createPost.isLoading}\n      >\n        {createPost.isLoading ? 'Creating...' : 'Create Post'}\n      </button>\n    </div>\n  );\n}\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Add Database\" href=\"/docs/server/quickstart\">\n    Learn to connect your database with Prisma, Drizzle, or raw SQL\n  </Card>\n  <Card title=\"Authentication\" href=\"/docs/server/authorization\">\n    Add user authentication and authorization to your API\n  </Card>\n  <Card title=\"Validation\" href=\"/docs/server/validators\">\n    Learn advanced input and output validation with Zod\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Handle errors gracefully with proper HTTP status codes\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion title=\"Module not found errors\">\nMake sure you've installed all required dependencies and your TypeScript configuration is correct.\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true\n  }\n}\n```\n\n</Accordion>\n\n<Accordion title=\"CORS issues\">\nIf you're calling your API from a different domain, you may need to configure CORS:\n\n```typescript title=\"src/pages/api/trpc/[trpc].ts\"\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { appRouter } from '../../../server/router';\n\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: () => ({}),\n  responseMeta() {\n    return {\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET,OPTIONS,PATCH,DELETE,POST,PUT',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n      },\n    };\n  },\n});\n```\n\n</Accordion>\n</Accordions>\n"}, {"info":{"path":"server/framework/standalone.mdx","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/standalone.mdx"},"lastModified":null,"data":{"title":"Standalone Server","description":"Run tRPC as a standalone HTTP server without any framework","icon":"IconServer2","index":false},"content":"\nThe standalone adapter lets you run tRPC as a plain HTTP server without any framework dependencies. Perfect for microservices, simple APIs, or when you want maximum control.\n\n## Installation\n\n<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>\n  <Tab value=\"npm\">\n    ```bash npm install @trpc/server zod npm install -D @types/node tsx\n    typescript ```\n  </Tab>\n  <Tab value=\"pnpm\">\n    ```bash pnpm add @trpc/server zod pnpm add -D @types/node tsx typescript ```\n  </Tab>\n  <Tab value=\"yarn\">\n    ```bash yarn add @trpc/server zod yarn add -D @types/node tsx typescript ```\n  </Tab>\n  <Tab value=\"bun\">\n    ```bash bun add @trpc/server zod bun add -D @types/node tsx typescript ```\n  </Tab>\n</Tabs>\n\n## Setup Guide\n\n### 1. Create tRPC Instance\n\n```typescript title=\"src/trpc.ts\"\nimport { initTRPC } from '@trpc/server';\nimport { ZodError } from 'zod';\n\nconst t = initTRPC.create({\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n### 2. Create Your API Router\n\n```typescript title=\"src/router.ts\"\nimport { z } from 'zod';\nimport { router, publicProcedure } from './trpc';\n\n// Mock database\nconst users: Array<{\n  id: string;\n  name: string;\n  email: string;\n  createdAt: Date;\n}> = [\n  { id: '1', name: 'John Doe', email: 'john@example.com', createdAt: new Date() },\n  { id: '2', name: 'Jane Smith', email: 'jane@example.com', createdAt: new Date() },\n];\n\nexport const appRouter = router({\n  hello: publicProcedure\n    .input(z.object({ name: z.string().optional() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.name ?? 'World'}!`,\n        timestamp: new Date(),\n      };\n    }),\n\n  getUsers: publicProcedure.query(() => {\n    return users;\n  }),\n\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .query(({ input }) => {\n      const user = users.find(u => u.id === input.id);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      return user;\n    }),\n\n  createUser: publicProcedure\n    .input(z.object({\n      name: z.string().min(2),\n      email: z.string().email(),\n    }))\n    .mutation(({ input }) => {\n      const user = {\n        id: Date.now().toString(),\n        ...input,\n        createdAt: new Date(),\n      };\n      users.push(user);\n      return user;\n    }),\n\n  updateUser: publicProcedure\n    .input(z.object({\n      id: z.string(),\n      name: z.string().optional(),\n      email: z.string().email().optional(),\n    }))\n    .mutation(({ input }) => {\n      const userIndex = users.findIndex(u => u.id === input.id);\n      if (userIndex === -1) {\n        throw new Error('User not found');\n      }\n\n      const { id, ...updates } = input;\n      Object.assign(users[userIndex], updates);\n\n      return users[userIndex];\n    }),\n\n  deleteUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .mutation(({ input }) => {\n      const userIndex = users.findIndex(u => u.id === input.id);\n      if (userIndex === -1) {\n        throw new Error('User not found');\n      }\n\n      const deletedUser = users.splice(userIndex, 1)[0];\n      return deletedUser;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n### 3. Create Standalone Server\n\n```typescript title=\"src/server.ts\"\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './router';\n\n// Create context\nfunction createContext(opts: any) {\n  return {\n    req: opts.req,\n    res: opts.res,\n    // Add user info, database connections, etc.\n  };\n}\n\n// Create HTTP server\nconst server = createHTTPServer({\n  router: appRouter,\n  createContext,\n  onError({ path, error }) {\n    console.error(`‚ùå tRPC failed on ${path ?? '<no-path>'}:`, error);\n  },\n});\n\nconst port = process.env.PORT ? Number(process.env.PORT) : 3000;\n\nserver.listen(port);\n\nconsole.log(`üöÄ Server running at http://localhost:${port}`);\nconsole.log(`üì° tRPC endpoint at http://localhost:${port}`);\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\nüõë Shutting down server...');\n  server.close(() => {\n    console.log('‚úÖ Server closed');\n    process.exit(0);\n  });\n});\n```\n\n### 4. Add Scripts to package.json\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"dev\": \"tsx watch src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  }\n}\n```\n\n### 5. Create TypeScript Config\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Test Your Setup\n\nStart your server:\n\n```bash\nnpm run dev\n```\n\nTest your endpoints:\n\n<Tabs items={['Hello', 'Get Users', 'Create User', 'Update User', 'Delete User']}>\n<Tab value=\"Hello\">\n```bash\ncurl \"http://localhost:3000/hello?input=%7B%22name%22%3A%22tRPC%22%7D\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"greeting\": \"Hello tRPC!\",\n      \"timestamp\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Get Users\">\n```bash\ncurl \"http://localhost:3000/getUsers\"\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": [\n      {\n        \"id\": \"1\",\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n      },\n      {\n        \"id\": \"2\",\n        \"name\": \"Jane Smith\",\n        \"email\": \"jane@example.com\",\n        \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n      }\n    ]\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Create User\">\n```bash\ncurl -X POST \"http://localhost:3000/createUser\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice Johnson\", \"email\": \"alice@example.com\"}'\n```\n\nResponse:\n\n```json\n{\n  \"result\": {\n    \"data\": {\n      \"id\": \"1234567890\",\n      \"name\": \"Alice Johnson\",\n      \"email\": \"alice@example.com\",\n      \"createdAt\": \"2024-01-15T10:30:00.000Z\"\n    }\n  }\n}\n```\n\n</Tab>\n<Tab value=\"Update User\">\n```bash\ncurl -X POST \"http://localhost:3000/updateUser\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\": \"1\", \"name\": \"John Updated\"}'\n```\n</Tab>\n<Tab value=\"Delete User\">\n```bash\ncurl -X POST \"http://localhost:3000/deleteUser\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\": \"1\"}'\n```\n</Tab>\n</Tabs>\n\n## Add Custom HTTP Handling\n\nThe standalone server gives you full control over HTTP handling:\n\n```typescript title=\"src/custom-server.ts\"\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './router';\nimport { IncomingMessage, ServerResponse } from 'http';\n\nconst server = createHTTPServer({\n  router: appRouter,\n  createContext,\n\n  // Custom request handling\n  onError({ path, error, req }) {\n    console.error(`‚ùå Error on ${req.method} ${req.url}:`, error);\n  },\n\n  // Custom response headers\n  responseMeta({ ctx, path, type, errors }) {\n    const headers: Record<string, string> = {\n      'X-Custom-Header': 'tRPC-Standalone',\n    };\n\n    // Add CORS headers\n    if (ctx?.req) {\n      headers['Access-Control-Allow-Origin'] = '*';\n      headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS';\n      headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n    }\n\n    return { headers };\n  },\n});\n\n// Add health check endpoint manually\nconst originalListener = server.requestListener;\nserver.requestListener = (req: IncomingMessage, res: ServerResponse) => {\n  // Handle health check\n  if (req.url === '/health' && req.method === 'GET') {\n    res.writeHead(200, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({\n      status: 'ok',\n      timestamp: new Date().toISOString()\n    }));\n    return;\n  }\n\n  // Handle OPTIONS for CORS\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200, {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    });\n    res.end();\n    return;\n  }\n\n  // Default tRPC handling\n  originalListener(req, res);\n};\n\nconst port = 3000;\nserver.listen(port);\nconsole.log(`üöÄ Custom server running at http://localhost:${port}`);\n```\n\n## Add Authentication\n\n```typescript title=\"src/auth.ts\"\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { TRPCError } from '@trpc/server';\n\n// Simple API key authentication\nfunction createContext({ req }: { req: any }) {\n  const apiKey = req.headers['x-api-key'];\n\n  // Check if API key is valid (in real app, check against database)\n  const validApiKeys = ['demo-key-123', 'admin-key-456'];\n  const isAuthenticated = validApiKeys.includes(apiKey);\n\n  return {\n    req,\n    apiKey,\n    isAuthenticated,\n    isAdmin: apiKey === 'admin-key-456',\n  };\n}\n\n// Create protected procedure\nconst protectedProcedure = publicProcedure.use(({ ctx, next }) => {\n  if (!ctx.isAuthenticated) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'API key required',\n    });\n  }\n  return next();\n});\n\n// Create admin procedure\nconst adminProcedure = protectedProcedure.use(({ ctx, next }) => {\n  if (!ctx.isAdmin) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Admin access required',\n    });\n  }\n  return next();\n});\n\n// Update router with auth\nexport const authRouter = router({\n  // Public endpoints\n  hello: publicProcedure.query(() => ({ message: 'Hello World!' })),\n\n  // Protected endpoints\n  getUsers: protectedProcedure.query(() => users),\n\n  // Admin endpoints\n  deleteAllUsers: adminProcedure.mutation(() => {\n    const count = users.length;\n    users.splice(0);\n    return { deletedCount: count };\n  }),\n});\n```\n\n## Client Usage\n\n```typescript title=\"client.ts\"\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './src/router';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n      headers() {\n        return {\n          'x-api-key': 'demo-key-123',\n        };\n      },\n    }),\n  ],\n});\n\n// Usage examples\nasync function examples() {\n  // Query\n  const hello = await client.hello.query({ name: 'Standalone' });\n  console.log(hello.greeting);\n\n  // Get all users\n  const users = await client.getUsers.query();\n  console.log('Users:', users);\n\n  // Create a user\n  const newUser = await client.createUser.mutate({\n    name: 'Bob Wilson',\n    email: 'bob@example.com',\n  });\n  console.log('Created user:', newUser);\n\n  // Update a user\n  const updatedUser = await client.updateUser.mutate({\n    id: newUser.id,\n    name: 'Bob Wilson Updated',\n  });\n  console.log('Updated user:', updatedUser);\n}\n\nexamples().catch(console.error);\n```\n\n## Docker Support\n\nCreate a Dockerfile for easy deployment:\n\n```dockerfile title=\"Dockerfile\"\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# Copy source code\nCOPY dist ./dist\n\n# Expose port\nEXPOSE 3000\n\n# Set environment\nENV NODE_ENV=production\n\n# Start server\nCMD [\"node\", \"dist/server.js\"]\n```\n\n```yaml title=\"docker-compose.yml\"\nversion: '3.8'\nservices:\n  trpc-server:\n    build: .\n    ports:\n      - '3000:3000'\n    environment:\n      - NODE_ENV=production\n      - PORT=3000\n```\n\n## Next Steps\n\n<Cards>\n  <Card title=\"Add Database\" href=\"/docs/server/quickstart\">\n    Integrate with your preferred database solution\n  </Card>\n  <Card title=\"Authentication\" href=\"/docs/server/authorization\">\n    Add JWT or session-based authentication\n  </Card>\n  <Card title=\"Validation\" href=\"/docs/server/validators\">\n    Learn advanced input and output validation\n  </Card>\n  <Card title=\"Error Handling\" href=\"/docs/server/error-handling\">\n    Handle errors gracefully with proper HTTP status codes\n  </Card>\n</Cards>\n\n## Common Issues\n\n<Accordions>\n<Accordion title=\"Port Already in Use\">\nChange the port in your server.ts file or use an environment variable:\n\n```typescript\nconst port = process.env.PORT ? Number(process.env.PORT) : 3001;\n```\n\n</Accordion>\n\n<Accordion title=\"CORS Issues\">\nAdd CORS headers manually or use the responseMeta option:\n\n```typescript\nconst server = createHTTPServer({\n  router: appRouter,\n  createContext,\n  responseMeta() {\n    return {\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n      },\n    };\n  },\n});\n```\n\n</Accordion>\n\n<Accordion title=\"Request Body Parsing\">\nThe standalone adapter handles JSON parsing automatically. For custom parsing, implement your own server:\n\n```typescript\nimport { createServer } from 'http';\nimport { createFetchHandler } from '@trpc/server/adapters/fetch';\n\nconst server = createServer(async (req, res) => {\n  const handler = createFetchHandler({\n    endpoint: '/',\n    req: new Request(`http://localhost${req.url}`, {\n      method: req.method,\n      headers: req.headers as any,\n      body: req.readable ? req : undefined,\n    }),\n    router: appRouter,\n    createContext,\n  });\n});\n```\n\n</Accordion>\n</Accordions>\n"}], [{"info":{"path":"meta.json","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/meta.json"},"data":{"pages":["framework","server","client"]}}, {"info":{"path":"client/meta.json","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/client/meta.json"},"data":{"title":"tRPC Client","pages":["---Getting Started---","index","installation","setup","---React Integration---","tanstack-react-query","react-hooks","server-components","error-handling","typescript","---Framework Integrations---","nextjs","react","vanilla","---Configuration---","links","cors","headers","aborting-requests","---Advanced---","optimistic-updates","infinite-queries","subscriptions","testing"],"description":"Integrate tRPC with your frontend applications","root":true,"icon":"IconDeviceDesktop"}}, {"info":{"path":"framework/meta.json","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/framework/meta.json"},"data":{"title":"tRPC Framework","pages":["---Getting Started---","index","installation","quickstart","---Core Concepts---","concepts","---Learning Resources---","getting-started","example-apps","---Community---","videos-and-community-resources"],"description":"End-to-end typesafe APIs made easy","root":true,"icon":"IconBrandTypescript"}}, {"info":{"path":"server/meta.json","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/meta.json"},"data":{"title":"tRPC Server","pages":["---Getting Started---","index","framework","quickstart","---Core Concepts---","procedures","routers","context","---Input & Output---","validators","data-transformers","---Logic & Security---","middlewares","authorization","---Error Handling---","error-handling","error-formatting","---Advanced---","file-uploads","server-side-calls","subscriptions","websockets","caching","testing","metadata"],"description":"Build end-to-end typesafe APIs with tRPC server","root":true,"icon":"Server"}}, {"info":{"path":"server/framework/meta.json","absolutePath":"/Users/cameron/Desktop/trpc-docs/docs/content/docs/server/framework/meta.json"},"data":{"title":"Framework Setup","pages":["nextjs","express","fastify","standalone","cloudflare-workers","aws-lambda"],"description":"Get started with tRPC in your preferred framework","icon":"IconCode"}}], "docs", _sourceConfig)