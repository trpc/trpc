import { DocsLayout } from '../../components/DocsLayout';

export const meta = {
  title: 'Introduction',
};

# Introduction

tRPC allows you to easily build & consume fully typesafe APIs, without schemas or code generation.

As TypeScript and static typing increasingly becomes a best practice in web programming, the API presents a major pain point. We need better ways to statically type our API endpoints and share those types between our client and server (or server-to-server). We set out to build a simple library for building typesafe APIs that leverages the full power of modern TypeScript. Introducing tRPC!

## An alternative to traditional REST or GraphQL

Currently GraphQL is the dominant way to implement typesafe APIs in TypeScript (and it's amazing!). Since GraphQL is designed as a language-agnostic specification for implementing APIs, it doesn't take full advantage of the power of a language like TypeScript - further reading.

If your project is built with full-stack TypeScript, you can share types directly between your client and server, without relying on code generation.

## Features

- âœ…&nbsp; Well-tested and production ready.
- ğŸ§™â€â™‚ï¸&nbsp; Full static typesafety & autocompletion on the client, for inputs, outputs and errors.
- ğŸ&nbsp; Snappy DX - No code generation, run-time bloat, or build pipeline.
- ğŸƒ&nbsp; Light - tRPC has zero deps and a tiny client-side footprint.
- ğŸ»&nbsp; Easy to add to your existing brownfield project.
- ğŸ”‹&nbsp; Batteries included - React.js/Next.js/Express.js/Fastify adapters. _(But tRPC is not tied to React - [reach out](https://twitter.com/alexdotjs) if you want to make a Svelte/Vue/... adapter)_
- ğŸ¥ƒ&nbsp; Subscriptions support.
- âš¡ï¸&nbsp; Request batching - requests made at the same time can be automatically combined into one.
- ğŸ‘€&nbsp; Quite a few [examples](example-apps.md) that you can use for reference or as a starting point.

export default ({ children }) => (
  <DocsLayout meta={meta}>{children}</DocsLayout>
);
