---
title: Procedures
description: Build type-safe queries, mutations, and subscriptions with tRPC procedures
icon: IconFunction
---

Procedures are the building blocks of your tRPC API. They define individual endpoints that your client can call with complete type safety. Learn how to create powerful, type-safe procedures for every use case.

## What are Procedures?

A **procedure** is a function on your tRPC server that can be called from your client. Think of procedures as your API endpoints, but with automatic type inference and validation.

```typescript
// Server: Define a procedure
const getUserById = t.procedure.input(z.string()).query(({ input }) => {
  return db.user.findUnique({ where: { id: input } });
});

// Client: Call it with full type safety
const user = await trpc.getUserById.query('user_123');
//    ^? User | null - TypeScript automatically knows the return type
```

## Types of Procedures

tRPC has three types of procedures, each optimized for different use cases:

<Cards>
  <Card icon={<IconSearch />} title="Query">
    For reading data. Safe, cacheable, and idempotent operations.
  </Card>

<Card icon={<IconEdit />} title="Mutation">
  For writing data. Operations that change server state.
</Card>

  <Card icon={<IconWifi />} title="Subscription">
    For real-time data streams. Push updates from server to client.
  </Card>
</Cards>

## Query Procedures

Use `.query()` for operations that **read** data without side effects:

### Basic Query

```typescript title="server/routers/posts.ts"
import { z } from 'zod';
import { t } from '../trpc';

export const postsRouter = t.router({
  // Get all posts
  list: t.procedure.query(async () => {
    return await db.post.findMany({
      orderBy: { createdAt: 'desc' },
      include: { author: true },
    });
  }),

  // Get post by ID
  byId: t.procedure.input(z.string()).query(async ({ input }) => {
    const post = await db.post.findUnique({
      where: { id: input },
      include: { author: true, comments: true },
    });

    if (!post) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Post not found',
      });
    }

    return post;
  }),
});
```

### Query with Complex Input

```typescript title="server/routers/search.ts"
const searchSchema = z.object({
  query: z.string().min(1),
  category: z.enum(['posts', 'users', 'comments']).optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  sortBy: z.enum(['relevance', 'date', 'popularity']).default('relevance'),
});

export const searchRouter = t.router({
  search: t.procedure.input(searchSchema).query(async ({ input }) => {
    const { query, category, limit, offset, sortBy } = input;

    // Build dynamic search query
    const results = await searchService.search({
      query,
      category,
      limit,
      offset,
      sortBy,
    });

    return {
      results,
      totalCount: results.length,
      hasMore: results.length === limit,
    };
  }),
});
```

### Client Usage

```tsx title="components/posts.tsx"
import { useQuery } from '@tanstack/react-query';
import { useTRPC } from '../lib/trpc';

export function PostsList() {
  const trpc = useTRPC();

  // Simple query
  const postsQuery = useQuery(trpc.posts.list.queryOptions());

  // Query with input
  const featuredPostQuery = useQuery(
    trpc.posts.byId.queryOptions('featured-post-id'),
  );

  // Complex search query
  const searchQuery = useQuery(
    trpc.search.search.queryOptions({
      query: 'react hooks',
      category: 'posts',
      limit: 10,
      sortBy: 'relevance',
    }),
  );

  return (
    <div>
      {postsQuery.data?.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>By {post.author.name}</p>
        </article>
      ))}
    </div>
  );
}
```

## Mutation Procedures

Use `.mutation()` for operations that **modify** server state:

### Basic Mutations

```typescript title="server/routers/posts.ts"
export const postsRouter = t.router({
  // Create a new post
  create: t.procedure
    .input(
      z.object({
        title: z.string().min(1).max(200),
        content: z.string().min(1),
        tags: z.array(z.string()).max(10).default([]),
        published: z.boolean().default(false),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      // Check if user is authenticated
      if (!ctx.user) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'You must be logged in to create a post',
        });
      }

      const post = await db.post.create({
        data: {
          ...input,
          authorId: ctx.user.id,
        },
        include: { author: true },
      });

      // Optionally trigger side effects
      await notificationService.notifyFollowers(ctx.user.id, post);

      return post;
    }),

  // Update existing post
  update: t.procedure
    .input(
      z.object({
        id: z.string(),
        title: z.string().min(1).max(200).optional(),
        content: z.string().min(1).optional(),
        tags: z.array(z.string()).max(10).optional(),
        published: z.boolean().optional(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const { id, ...updateData } = input;

      // Check ownership
      const existingPost = await db.post.findUnique({
        where: { id },
        select: { authorId: true },
      });

      if (!existingPost) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Post not found',
        });
      }

      if (existingPost.authorId !== ctx.user?.id) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You can only edit your own posts',
        });
      }

      return await db.post.update({
        where: { id },
        data: updateData,
        include: { author: true },
      });
    }),

  // Delete post
  delete: t.procedure
    .input(z.string())
    .mutation(async ({ input: postId, ctx }) => {
      const post = await db.post.findUnique({
        where: { id: postId },
        select: { authorId: true, title: true },
      });

      if (!post) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Post not found',
        });
      }

      if (post.authorId !== ctx.user?.id) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You can only delete your own posts',
        });
      }

      await db.post.delete({ where: { id: postId } });

      return { success: true, title: post.title };
    }),
});
```

### Batch Operations

```typescript title="server/routers/batch.ts"
export const batchRouter = t.router({
  // Bulk create posts
  createMany: t.procedure
    .input(
      z
        .array(
          z.object({
            title: z.string().min(1),
            content: z.string().min(1),
            tags: z.array(z.string()).default([]),
          }),
        )
        .max(10),
    ) // Limit batch size
    .mutation(async ({ input, ctx }) => {
      if (!ctx.user) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }

      const posts = await db.$transaction(
        input.map((post) =>
          db.post.create({
            data: {
              ...post,
              authorId: ctx.user.id,
            },
          }),
        ),
      );

      return posts;
    }),

  // Bulk update
  updateMany: t.procedure
    .input(
      z.object({
        ids: z.array(z.string()).min(1).max(50),
        data: z.object({
          published: z.boolean().optional(),
          tags: z.array(z.string()).optional(),
        }),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      // Verify user owns all posts
      const posts = await db.post.findMany({
        where: {
          id: { in: input.ids },
          authorId: ctx.user?.id,
        },
        select: { id: true },
      });

      if (posts.length !== input.ids.length) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You can only update your own posts',
        });
      }

      await db.post.updateMany({
        where: { id: { in: input.ids } },
        data: input.data,
      });

      return { updated: input.ids.length };
    }),
});
```

### Client Usage

```tsx title="components/post-form.tsx"
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useTRPC } from '../lib/trpc';

export function PostForm() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  // Create post mutation
  const createPost = useMutation(
    trpc.posts.create.mutationOptions({
      onSuccess: (newPost) => {
        // Update the posts list cache
        queryClient.invalidateQueries(trpc.posts.list.queryKey());

        // Add new post to cache
        queryClient.setQueryData(trpc.posts.byId.queryKey(newPost.id), newPost);

        // Show success message
        toast.success(`Post "${newPost.title}" created!`);
      },
      onError: (error) => {
        toast.error(error.message);
      },
    }),
  );

  // Update post mutation
  const updatePost = useMutation(
    trpc.posts.update.mutationOptions({
      onSuccess: (updatedPost) => {
        // Update specific post in cache
        queryClient.setQueryData(
          trpc.posts.byId.queryKey(updatedPost.id),
          updatedPost,
        );

        // Optionally invalidate list to reorder
        queryClient.invalidateQueries(trpc.posts.list.queryKey());
      },
    }),
  );

  const handleSubmit = (data: PostFormData) => {
    if (editingPost) {
      updatePost.mutate({ id: editingPost.id, ...data });
    } else {
      createPost.mutate(data);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button
        type="submit"
        disabled={createPost.isPending || updatePost.isPending}
      >
        {editingPost ? 'Update' : 'Create'} Post
      </button>
    </form>
  );
}
```

## Subscription Procedures

Use `.subscription()` for real-time data streams:

### Basic Subscription

```typescript title="server/routers/realtime.ts"
import { EventEmitter } from 'events';
import { observable } from '@trpc/server/observable';

// Global event emitter for this example
const ee = new EventEmitter();

export const realtimeRouter = t.router({
  // Post updates subscription
  onPostUpdate: t.procedure
    .input(z.object({ postId: z.string() }))
    .subscription(({ input }) => {
      return observable<{ type: string; post: Post }>((emit) => {
        const onUpdate = (data: { postId: string; post: Post }) => {
          if (data.postId === input.postId) {
            emit.next({ type: 'update', post: data.post });
          }
        };

        const onDelete = (data: { postId: string }) => {
          if (data.postId === input.postId) {
            emit.next({ type: 'delete', post: null });
          }
        };

        // Listen for events
        ee.on('post:update', onUpdate);
        ee.on('post:delete', onDelete);

        // Cleanup function
        return () => {
          ee.off('post:update', onUpdate);
          ee.off('post:delete', onDelete);
        };
      });
    }),

  // Live comments stream
  onNewComment: t.procedure
    .input(z.object({ postId: z.string() }))
    .subscription(({ input }) => {
      return observable<Comment>((emit) => {
        const onComment = (comment: Comment) => {
          if (comment.postId === input.postId) {
            emit.next(comment);
          }
        };

        ee.on('comment:new', onComment);

        return () => {
          ee.off('comment:new', onComment);
        };
      });
    }),
});
```

### Advanced Subscription with Authentication

```typescript title="server/routers/notifications.ts"
export const notificationsRouter = t.router({
  // User-specific notifications
  onNotification: protectedProcedure.subscription(({ ctx }) => {
    return observable<Notification>((emit) => {
      const userId = ctx.user.id;

      const onNotification = (notification: Notification) => {
        if (notification.userId === userId) {
          emit.next(notification);
        }
      };

      ee.on('notification:new', onNotification);

      // Send existing unread notifications
      db.notification
        .findMany({
          where: { userId, read: false },
          orderBy: { createdAt: 'desc' },
        })
        .then((notifications) => {
          notifications.forEach((notification) => {
            emit.next(notification);
          });
        });

      return () => {
        ee.off('notification:new', onNotification);
      };
    });
  }),
});
```

### Client Usage

```tsx title="components/live-comments.tsx"
import { useTRPC } from '../lib/trpc';

export function LiveComments({ postId }: { postId: string }) {
  const trpc = useTRPC();
  const [comments, setComments] = useState<Comment[]>([]);

  // Subscribe to new comments
  trpc.realtime.onNewComment.useSubscription(
    { postId },
    {
      onData: (comment) => {
        setComments((prev) => [comment, ...prev]);
      },
      onError: (error) => {
        console.error('Subscription error:', error);
      },
    },
  );

  return (
    <div>
      <h3>Live Comments</h3>
      {comments.map((comment) => (
        <div key={comment.id}>
          <strong>{comment.author.name}</strong>: {comment.content}
        </div>
      ))}
    </div>
  );
}
```

## Input Validation

### Zod Schemas

tRPC works perfectly with Zod for input validation:

```typescript title="server/schemas/post.ts"
import { z } from 'zod';

export const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z
    .string()
    .min(10, 'Content must be at least 10 characters')
    .max(50000, 'Content too long'),
  tags: z.array(z.string()).max(10, 'Too many tags').default([]),
  published: z.boolean().default(false),
  scheduledFor: z.date().optional(),
});

export const updatePostSchema = createPostSchema.partial().extend({
  id: z.string(),
});

export const postFiltersSchema = z.object({
  author: z.string().optional(),
  tags: z.array(z.string()).optional(),
  published: z.boolean().optional(),
  createdAfter: z.date().optional(),
  createdBefore: z.date().optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
});
```

### Custom Validation

```typescript title="server/routers/posts.ts"
export const postsRouter = t.router({
  create: t.procedure
    .input(
      createPostSchema.refine(
        (data) => {
          // Custom validation: if scheduled, must be in future
          if (data.scheduledFor && data.scheduledFor <= new Date()) {
            return false;
          }
          return true;
        },
        {
          message: 'Scheduled date must be in the future',
          path: ['scheduledFor'],
        },
      ),
    )
    .mutation(async ({ input, ctx }) => {
      // Additional validation in the procedure
      if (input.published && !ctx.user?.canPublish) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to publish posts',
        });
      }

      return await db.post.create({
        data: {
          ...input,
          authorId: ctx.user.id,
        },
      });
    }),
});
```

## Output Transformation

### Basic Output Shaping

```typescript title="server/routers/users.ts"
export const usersRouter = t.router({
  profile: t.procedure.input(z.string()).query(async ({ input }) => {
    const user = await db.user.findUnique({
      where: { id: input },
      include: {
        posts: {
          select: { id: true, title: true, createdAt: true },
          orderBy: { createdAt: 'desc' },
          take: 5,
        },
        _count: {
          select: {
            posts: true,
            followers: true,
            following: true,
          },
        },
      },
    });

    if (!user) {
      throw new TRPCError({ code: 'NOT_FOUND' });
    }

    // Transform output
    return {
      id: user.id,
      name: user.name,
      bio: user.bio,
      avatar: user.avatar,
      joinedAt: user.createdAt,
      stats: {
        posts: user._count.posts,
        followers: user._count.followers,
        following: user._count.following,
      },
      recentPosts: user.posts,
    };
  }),
});
```

### Conditional Fields

```typescript title="server/routers/posts.ts"
export const postsRouter = t.router({
  byId: t.procedure
    .input(
      z.object({
        id: z.string(),
        includeComments: z.boolean().default(false),
        includeAnalytics: z.boolean().default(false),
      }),
    )
    .query(async ({ input, ctx }) => {
      const { id, includeComments, includeAnalytics } = input;

      const post = await db.post.findUnique({
        where: { id },
        include: {
          author: true,
          comments: includeComments
            ? {
                include: { author: true },
                orderBy: { createdAt: 'desc' },
              }
            : false,
          // Only include analytics for post author
          analytics: includeAnalytics && ctx.user?.id === post?.authorId,
        },
      });

      if (!post) {
        throw new TRPCError({ code: 'NOT_FOUND' });
      }

      return post;
    }),
});
```

## Error Handling

### Custom Error Types

```typescript title="server/errors.ts"
import { TRPCError } from '@trpc/server';

export class ValidationError extends TRPCError {
  constructor(message: string, field?: string) {
    super({
      code: 'BAD_REQUEST',
      message,
      cause: { field },
    });
  }
}

export class NotFoundError extends TRPCError {
  constructor(resource: string, id?: string) {
    super({
      code: 'NOT_FOUND',
      message: `${resource} not found`,
      cause: { resource, id },
    });
  }
}

export class ForbiddenError extends TRPCError {
  constructor(action: string) {
    super({
      code: 'FORBIDDEN',
      message: `You are not allowed to ${action}`,
      cause: { action },
    });
  }
}
```

### Error Handling in Procedures

```typescript title="server/routers/posts.ts"
export const postsRouter = t.router({
  update: t.procedure
    .input(updatePostSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        const { id, ...updateData } = input;

        // Check if post exists
        const existingPost = await db.post.findUnique({
          where: { id },
          select: { authorId: true, published: true },
        });

        if (!existingPost) {
          throw new NotFoundError('Post', id);
        }

        // Check ownership
        if (existingPost.authorId !== ctx.user?.id) {
          throw new ForbiddenError('edit this post');
        }

        // Validate business rules
        if (existingPost.published && updateData.published === false) {
          throw new ValidationError(
            'Cannot unpublish a published post',
            'published',
          );
        }

        return await db.post.update({
          where: { id },
          data: updateData,
          include: { author: true },
        });
      } catch (error) {
        // Log error for debugging
        console.error('Post update failed:', error);

        // Re-throw tRPC errors
        if (error instanceof TRPCError) {
          throw error;
        }

        // Handle unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An unexpected error occurred',
          cause: error,
        });
      }
    }),
});
```

## Best Practices

<Accordions>
<Accordion id='input-validation' title="Input Validation">

- Always validate inputs with Zod schemas
- Use descriptive error messages
- Validate business rules in procedures
- Consider rate limiting for expensive operations

```typescript
// Good: Comprehensive validation
const schema = z
  .object({
    email: z.string().email('Invalid email format'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Passwords must match',
    path: ['confirmPassword'],
  });
```

</Accordion>

<Accordion id='error-handling' title="Error Handling">

- Use specific error codes for different scenarios
- Provide helpful error messages
- Log errors appropriately
- Handle both expected and unexpected errors

```typescript
// Good: Specific error handling
if (!user) {
  throw new TRPCError({
    code: 'NOT_FOUND',
    message: 'User not found',
  });
}

if (user.id !== ctx.user?.id) {
  throw new TRPCError({
    code: 'FORBIDDEN',
    message: 'You can only edit your own profile',
  });
}
```

</Accordion>

<Accordion id='performance' title="Performance">

- Use database indexes for frequently queried fields
- Implement pagination for large datasets
- Consider caching for expensive operations
- Use database transactions for related operations

```typescript
// Good: Efficient querying with pagination
const posts = await db.post.findMany({
  take: input.limit,
  skip: input.offset,
  orderBy: { createdAt: 'desc' },
  include: {
    author: {
      select: { id: true, name: true, avatar: true },
    },
  },
});
```

</Accordion>
</Accordions>

---

Procedures are the foundation of your tRPC API. With proper input validation, error handling, and type safety, they provide a robust foundation for building reliable applications.
