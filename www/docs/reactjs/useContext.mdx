---
id: useContext
title: useContext
sidebar_label: useContext()
slug: /useContext
---

`useContext` is a hook that gives you access to helpers that let you interact with the cache of the queries that you execute via `@trpc/react`. These helpers are actually thin wrappers around `@tanstack/react-query`'s [`QueryClient`](https://tanstack.com/query/v4/docs/reference/QueryClient) methods. If you want more in-depth information about options and usage patterns for `useContext` helpers than what we provide here, we will link to their respective `@tanstack/react-query` docs so you can refer to them accordingly.

## Usage

`useContext` returns an object with all the available queries you have in your routers. You use it the same way as your `trpc` client object. Once you reach a query, you'll have access to the query helpers. For example, let's say you have a `post` router with an `all` query:

```twoslash include server
// @target: esnext

// @filename: server.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;
```

```ts twoslash title='server.ts'
// @include: server
```

Now in our component, when we navigate the object `useContext` gives us and reach the `post.all` query, we'll get access to our query helpers!

```tsx twoslash title="MyComponent.tsx"
// @target: esnext
// @include: server
// @filename: MyComponent.tsx
import { createTRPCReact } from '@trpc/react';
import type { AppRouter } from './server';

const trpc = createTRPCReact<AppRouter>();

// ---cut---
// @noErrors
function MyComponent() {
  const utils = trpc.useContext();
  utils.post.all.f;
  //              ^|
  // [...]
}
```

## Helpers

These are the helpers you'll get access to via `useContext`. The table below will help you know which tRPC helper wraps which `@tanstack/react-query` helper method. Each react-query method will link to its respective docs/guide:

| tRPC helper wrapper | `@tanstack/react-query` helper method                                                                                            |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `fetch`             | [`queryClient.fetchQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientfetchquery)                       |
| `prefetch`          | [`queryClient.prefetchQuery`](https://tanstack.com/query/v4/docs/guides/prefetching)                                             |
| `fetchInfinite`     | [`queryClient.fetchInfiniteQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientfetchinfinitequery)       |
| `prefetchInfinite`  | [`queryClient.prefetchInfiniteQuery`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientprefetchinfinitequery) |
| `invalidate`        | [`queryClient.invalidateQueries`](https://tanstack.com/query/v4/docs/guides/query-invalidation)                                  |
| `refetch`           | [`queryClient.refetchQueries`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientrefetchqueries)               |
| `cancel`            | [`queryClient.cancelQuery`](https://tanstack.com/query/v4/docs/guides/query-cancellation)                                        |
| `setData`           | [`queryClient.setQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientsetquerydata)                   |
| `getData`           | [`queryClient.getQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientgetquerydata)                   |
| `setInfiniteData`   | [`queryClient.setInfiniteQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientsetquerydata)           |
| `getInfiniteData`   | [`queryClient.getInfiniteData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientgetquerydata)                |

## Query Invalidation

### Invalidating a single query

You can invalidate a query relating to a single procedure and even filter based
on the input passed to it to prevent unnecessary calls to the back end.

#### Example code

```tsx
import { trpc } from '../utils/trpc';

function MyComponent() {
  const utils = trpc.useContext();

  const mutation = trpc.post.edit.useMutation({
    onSuccess(input) {
      utils.post.all.invalidate();
      utils.post.byId.invalidate({ id: input.id }); // Will not invalidate queries for other id's üëç
    },
  });

  // [...]
}
```

### Invalidating across whole routers

It is also possible to invalidate queries across an entire router rather then
just one query.

When doing this it is still possible to filter queries that will be invalidated
by their input values. tRPC will even infer the types of these possible input values
for you; across all queries that could be affected!

#### Example code

<details><summary>Backend code</summary>

```tsx title='server/routers/_app.ts'
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  // sub Post router
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
    byId: t.procedure
      .input(
        z.object({
          id: z.string(),
        }),
      )
      .query(({ input }) => {
        return {
          post: { id: input?.id, title: 'Look me up!' },
        };
      }),
    edit: t.procedure
      .input(z.object({ id: z.number(), title: z.string() }))
      .mutation(({ input }) => {
        return { post: { id: input.id, title: input.title } };
      }),
  }),
  // separate user router
  user: t.router({
    all: t.procedure.query(() => {
      return { users: [{ name: 'Dave Grohl' }, { name: 'Haruki Murakami' }] };
    }),
  }),
});
```

</details>

```tsx
import { trpc } from '../utils/trpc';

function MyComponent() {
  const utils = trpc.useContext();

  const invalidateAllQueriesAcrossAllRouters = () => {
    // 1Ô∏è‚É£
    // All queries on all routers will be invalidated üî•
    utils.invalidate();
  };

  const invalidateAllPostQueries = () => {
    // 2Ô∏è‚É£
    // All post queries will be invalidated üì≠
    utils.post.invalidate();
  };

  const invalidateAllPostQueriesWithMatchingInputs = () => {
    // 3Ô∏è‚É£
    // All queries in the post router with input {id:1} invalidated üì≠
    utils.post.invalidate({ id: 1 });
  };

  // Example queries
  trpc.user.all.useQuery(); // Would only be validated by 1Ô∏è‚É£ only.
  trpc.post.all.useQuery(); // Would be invalidated by 1Ô∏è‚É£ & 2Ô∏è‚É£
  trpc.post.byId.useQuery({ id: 1 }); // Would be invalidated by 1Ô∏è‚É£, 2Ô∏è‚É£ and 3Ô∏è‚É£
  trpc.post.byId.useQuery({ id: 2 }); // would be invalidated by 1Ô∏è‚É£ and 2Ô∏è‚É£ but NOT 3Ô∏è‚É£!

  // [...]
}
```

### Invalidate full cache on every mutation

Keeping track of exactly what a queries a mutation should invalidate is hard, therefore, it can be a pragmatic solution to invalidate the _full cache_ as a side-effect on any mutation. Since we have request batching, this invalidation will simply refetch all queries on the page you're looking at in one single request.

:::caution
We have marked this API as `unstable_` as the exact API might change without a major version bump on tRPC, keep an eye on the release notes if you want to use this.
:::

We have added a feature to help with this:

```ts
export const trpc = createTRPCReact<AppRouter, SSRContext>({
  unstable_overrides: {
    useMutation: {
      /**
       * This function is called whenever a `.useMutation` succeeds
       **/
      async onSuccess(opts) {
        /**
         * @note that order here matters:
         * The order here allows route changes in `onSuccess` without
         * having a flash of content change whilst redirecting.
         **/

        // Calls the `onSuccess` defined in the `useQuery()`-options:
        await opts.originalFn();

        // Invalidate all queries in the react-query cache:
        await opts.queryClient.invalidateQueries();
      },
    },
  },
});
```

## Additional Options

Aside from the query helpers, the object `useContext` also contains the following properties:

```ts
export interface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {
  /**
   * The `TRPCClient`
   */
  client: TRPCClient<TRouter>;
  /**
   * The SSR context when server-side rendering
   * @default null
   */
  ssrContext?: TSSRContext | null;
  /**
   * State of SSR hydration.
   * - `false` if not using SSR.
   * - `prepass` when doing a prepass to fetch queries' data
   * - `mounting` before TRPCProvider has been rendered on the client
   * - `mounted` when the TRPCProvider has been rendered on the client
   * @default false
   */
  ssrState?: SSRState;
  /**
   * Abort loading query calls when unmounting a component - usually when navigating to a new page
   * @default false
   */
  abortOnUnmount?: boolean;
}
```
